---
title: "设计模式之结构型模式"
date: 2022-05-06
tags: ["设计模式",""]
description: "设计模式的一些列文章之一，还在写"
draft: false
---

> 结构型模式介绍如何将对象和类组装成较大的结构，并同时保持结构的灵活和高效

# 适配器

# 桥接

# 组合

> 组合模式是一种结构型设计模式，你可以使用它将对象组合成树状结构，并且能像使用独立对象一样使用它们。

在组合模式中，无论是复杂的还是简单的对象共用一个接口。在这个统一接口的帮助下，客户端不必在意其对象的具体类

# 装饰

> 装饰模式是一种结构型设计模式，允许你通过将对象放入包含行为的特殊封装对象中来为原对象绑定新的行为。

```go
package main

import "fmt"

type drink interface {
	getPrice() int
}

type coffee struct {
}

func (c *coffee) getPrice() int {
	return 20
}

type addMilk struct {
	drink drink
}

func (add *addMilk) getPrice() int {
	drinkPrice := add.drink.getPrice()
	return drinkPrice + 5
}

type addSugar struct {
	drink drink
}

func (add *addSugar) getPrice() int {
	drinkPrice := add.drink.getPrice()
	return drinkPrice + 2
}

func main() {
	coffee := &coffee{}
	// add milk
	coffeeWithMilk := &addMilk{drink: coffee}
	// add sugar
	coffeeWithMilkAndSugar := &addSugar{drink: coffeeWithMilk}
	fmt.Printf("The drink price is %d", coffeeWithMilkAndSugar.getPrice())
}
```

很多饮料都能都加糖或者是加牛奶，如果有一天牛奶涨价，需要加10块钱

那么就只需要改动`addMilk`中的价格了

# 外观

> 外观模式是一种结构型设计模式，能为程序库、框架或者其他复杂类提供一个简单

# 享元

摒弃了在每个对象中保存所有数据的方式，通过共享多个对象所共有的相同状态，让你能在有限的内存容量中载入更多对象。

# 代理

> 让你能够提供对象的替代品或者其占位符。代理控制着对于原对象的访问，并允许在将请求提交给对象前后进行一些处理。

代理对象拥有和服务对象相同的接口，它能够提供真实服务对象的替代品给客户端使用。代理接收客户端的请求并进行一些处理（访问控制和缓存等），然后再将请求传递给服务对象。

最常见的例子就是`nginx`，或者是一些数据库的`proxy`了，代理能够进行访问控制、缓存结果、记录日志等功能。
