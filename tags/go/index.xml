<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>go on 大猫的博客</title><link>https://aladdinding.cn/tags/go/</link><description>Recent content in go on 大猫的博客</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Thu, 28 Jul 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://aladdinding.cn/tags/go/index.xml" rel="self" type="application/rss+xml"/><item><title>gRPC 框架入门</title><link>https://aladdinding.cn/post/grpc-%E6%A1%86%E6%9E%B6%E5%85%A5%E9%97%A8/</link><pubDate>Thu, 28 Jul 2022 00:00:00 +0000</pubDate><guid>https://aladdinding.cn/post/grpc-%E6%A1%86%E6%9E%B6%E5%85%A5%E9%97%A8/</guid><description>近期上线项目优化，需要将节点与 master 交互方式从之前的短轮训改进到长连接，同时也需要改进序列化传输方式（之前使用的是序列化 pythoon 对象的 ujosn），很自然就想到了 grpc。
gRPC 是什么 gRPC 是一种现代化开源的高性能 RPC 框架，能够运行于任意环境之中。最初由谷歌进行开发。它使用 HTTP/2 作为传输协议。
使用 gRPC， 我们可以一次性的在一个 .proto 文件中定义服务并使用任何支持它的语言去实现客户端和服务端，反过来，它们可以应用在各种场景中，从 Google 的服务器到你自己的平板电脑—— gRPC 帮你解决了不同语言及环境间通信的复杂性。使用 protocol buffers 还能获得其他好处，包括高效的序列化，简单的 IDL 以及容易进行接口更新。总之一句话，使用 gRPC 能让我们更容易编写跨语言的分布式代码。
IDL（Interface description language）是指接口描述语言，是用来描述软件组件接口的一种计算机语言，是跨平台开发的基础。IDL 通过一种中立的方式来描述接口，使得在不同平台上运行的对象和用不同语言编写的程序可以相互通信交流；比如，一个组件用 C++ 写成，另一个组件用 Go 写成。
编写 .proto 文件 官方提供的教学场景（导航服务）很适合入门，覆盖了 RPC 的四种模式，创建 route_guide.proto 文件，定义以下消息和服务
syntax = &amp;#34;proto3&amp;#34;;option go_package = &amp;#34;./protos&amp;#34;;package routeguide;// Interface exported by the server. service RouteGuide { // A simple RPC. // // Obtains the feature at a given position.</description></item><item><title>GO中的Interfaces类型与值、指针接收者</title><link>https://aladdinding.cn/post/go%E4%B8%AD%E7%9A%84interfaces%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%80%BC%E6%8C%87%E9%92%88%E6%8E%A5%E6%94%B6%E8%80%85/</link><pubDate>Mon, 25 Jul 2022 00:00:00 +0000</pubDate><guid>https://aladdinding.cn/post/go%E4%B8%AD%E7%9A%84interfaces%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%80%BC%E6%8C%87%E9%92%88%E6%8E%A5%E6%94%B6%E8%80%85/</guid><description>以下代码有几点说明：
Cat 和 Dog 都实现了 Animal 接口的 SetName 方法 Cat 实现的接口为值接收者（value receiver） Dog 实现的接口为指针接收者（pointer receiver） package main import ( &amp;#34;fmt&amp;#34; ) type Animal interface { SetName() } type Cat struct { Name string } func (c Cat) SetName() { c.Name = &amp;#34;喵星人&amp;#34; } type Dog struct { Name string } func (d *Dog) SetName() { d.Name = &amp;#34;汪星人&amp;#34; } func main() { var a1 Animal = Cat{} a1.SetName() fmt.</description></item><item><title>GO 中的 string、rune 和 byte</title><link>https://aladdinding.cn/post/go-%E4%B8%AD%E7%9A%84-stringrune-%E5%92%8C-byte/</link><pubDate>Tue, 19 Jul 2022 00:00:00 +0000</pubDate><guid>https://aladdinding.cn/post/go-%E4%B8%AD%E7%9A%84-stringrune-%E5%92%8C-byte/</guid><description>Go 语言中的 byte 和 rune 实际上是 uin8 和 int32 类型
byte 一般来表示一些原始数据（如网络中的数据传输） rune 则用来表示 Unciode 字符 在 go 中 string 的底层用的就是 byte 字节数组存储的，它的遍历有两种情况
package main import ( &amp;#34;fmt&amp;#34; ) func main() { s := &amp;#34;abc汉字&amp;#34; for i := 0; i &amp;lt;len(s); i++ { fmt.Printf(&amp;#34;%c,&amp;#34;, s[i]) } fmt.Println() for _, r := range s { fmt.Printf(&amp;#34;%c,&amp;#34;, r) } } // 结果 // a,b,c,æ,±,,å,­,, // a,b,c,汉,字, 想获取字符串中的字符个数需要转换 []rune 数组，获取中文字符下标同理</description></item><item><title>使用 air 实现 go 程序热加载</title><link>https://aladdinding.cn/post/%E4%BD%BF%E7%94%A8-air-%E5%AE%9E%E7%8E%B0-go-%E7%A8%8B%E5%BA%8F%E7%83%AD%E5%8A%A0%E8%BD%BD/</link><pubDate>Thu, 21 Apr 2022 00:00:00 +0000</pubDate><guid>https://aladdinding.cn/post/%E4%BD%BF%E7%94%A8-air-%E5%AE%9E%E7%8E%B0-go-%E7%A8%8B%E5%BA%8F%E7%83%AD%E5%8A%A0%E8%BD%BD/</guid><description>在使用 Python Web 框架 Django 本地 runserver 启动后修改了代码，程序够自动重新加载并执行（live-reload），在开发调试阶段非常实用，可以提高开发效率。
在使用 Go 开发自己的项目或者使用 gin 框架进行本地调试的时候，也需要在文件修改后自动编译运行查看效果，那么则可以使用 air 这个工具。
AIR air 使用 go 语言开发，可以实现 go 语言应用程序的热加载，它支持以下特性：
彩色日志输出 自定义构建或二进制命令 支持忽略子目录 启动后支持监听新目录 更好的构建流程 安装 由于是 go 语言开发，对于我来说就直接下载二进制文件放到系统 PATH 目录下了，当然也可以使用 go get 、Docker 等方式安装，具体可以查看 Readme 中其他的安装方法，这里就不再赘述了
使用 写好 .air.conf 文件放在项目目录下然后直接执行 air 命令就行，非常简单
完整的示例以及注释如下，需要新增环境变量或者是命令行参数的可以在 full_bin 前后添加
# [Air](https://github.com/cosmtrek/air) TOML 格式的配置文件 # 工作目录 # 使用 . 或绝对路径，请注意 `tmp_dir` 目录必须在 `root` 目录下 root = &amp;#34;.&amp;#34; tmp_dir = &amp;#34;tmp&amp;#34; [build] # 只需要写你平常编译使用的 shell 命令。你也可以使用 `make` cmd = &amp;#34;go build -o .</description></item><item><title>Go 语言跨平台编译</title><link>https://aladdinding.cn/post/go-%E8%AF%AD%E8%A8%80%E8%B7%A8%E5%B9%B3%E5%8F%B0%E7%BC%96%E8%AF%91/</link><pubDate>Fri, 29 Oct 2021 00:00:00 +0000</pubDate><guid>https://aladdinding.cn/post/go-%E8%AF%AD%E8%A8%80%E8%B7%A8%E5%B9%B3%E5%8F%B0%E7%BC%96%E8%AF%91/</guid><description>go build 使用：
go build [-o 输出名] [-i] [编译标记] [包名] 默认我们 go build 的可执行文件都是当前操作系统可执行的文件，如果我想在 macOS 下编译一个 linux 下可执行文件，那需要怎么做呢？
只需要指定目标操作系统的平台和处理器架构即可，例如 Window 平台终端下按如下方式指定环境变量。
SET CGO_ENABLED=0 // 禁用 CGO SET GOOS=linux // 目标平台是 linux SET GOARCH=amd64 // 目标处理器架构是 amd64 macOS 编译 Linux 和 Windows 平台 64 位 可执行程序:
CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build CGO_ENABLED=0 GOOS=windows GOARCH=amd64 go build Linux 编译 Mac 和 Windows 平台 64 位可执行程序：
CGO_ENABLED=0 GOOS=darwin GOARCH=amd64 go build CGO_ENABLED=0 GOOS=windows GOARCH=amd64 go build Windows 编译 Mac 平台 64 位可执行程序</description></item></channel></rss>