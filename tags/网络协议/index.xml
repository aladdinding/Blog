<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>网络协议 on 大猫的博客</title><link>https://aladdinding.cn/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/</link><description>Recent content in 网络协议 on 大猫的博客</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Tue, 26 Jul 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://aladdinding.cn/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/index.xml" rel="self" type="application/rss+xml"/><item><title>Protocol Buffers协议使用小结</title><link>https://aladdinding.cn/post/protocol-buffers%E5%8D%8F%E8%AE%AE%E4%BD%BF%E7%94%A8%E5%B0%8F%E7%BB%93/</link><pubDate>Tue, 26 Jul 2022 00:00:00 +0000</pubDate><guid>https://aladdinding.cn/post/protocol-buffers%E5%8D%8F%E8%AE%AE%E4%BD%BF%E7%94%A8%E5%B0%8F%E7%BB%93/</guid><description>官方文档 Language Guide (proto3)
protocol-buffers 代码生成指南
网络上关于 Protocol Buffers 的翻译已经很多了，这里就不再重新写一遍了，主要记录一下常用语法。其实就是定义一个 .proto 文件，然后根据不同语言的插件生成不同的代码，通常代码会分为两个文件，以 go 语言为例子
xxx.pb.go 主要包含消息定义的 go 语言代码 xxx_grpc.pb.go 主要包含 grpc，也就是服务端，客户端之间交互的代码 至于为什么要分成两个文件（记得之前版本 go 语言只生成一个文件），应该是不同语言 grpc 的通信实现有很多吧，像 python 就有 gevent 和 asyncio 两种，拆分也是让文件分工更加清晰
至于 .proto 文件也是主要以：定义消息、定义服务、其他规范：注释、选项等等 组成
其他规范 文件开头通常是 syntax = &amp;quot;proto3&amp;quot;;，这个必须写在开头，表示使用的是 proto3 的语法，不写的话默认为 proto2
其次是类似 option go_package = &amp;quot;example.com/proto&amp;quot;; 这样的选项，用于不同语言生成代码的参数
注释与 c/c++ 语法相同，使用：//（单行注释）和 /* ... */（多行注释）
Message 命名采用驼峰命名方式，字段命名采用小写字母加下划线分隔方式</description></item><item><title>HTTPS 协议是如何握手的</title><link>https://aladdinding.cn/post/https-%E5%8D%8F%E8%AE%AE%E6%98%AF%E5%A6%82%E4%BD%95%E6%8F%A1%E6%89%8B%E7%9A%84/</link><pubDate>Tue, 23 Nov 2021 00:00:00 +0000</pubDate><guid>https://aladdinding.cn/post/https-%E5%8D%8F%E8%AE%AE%E6%98%AF%E5%A6%82%E4%BD%95%E6%8F%A1%E6%89%8B%E7%9A%84/</guid><description>Hypertext Transfer Protocol Secure (HTTPS) is an extension of the Hypertext Transfer Protocol (HTTP). It is used for secure communication over a computer network, and is widely used on the Internet. In HTTPS, the communication protocol is encrypted using Transport Layer Security (TLS) or, formerly, its predecessor, Secure Sockets Layer (SSL). The protocol is therefore also often referred to as HTTP over TLS, or HTTP over SSL.
HTTPS (Hypertext Transfer Protocol Secure) 是基于 HTTP 的扩展，用于计算机网络的安全通信，已经在互联网得到广泛应用。在 HTTPS 中，原有的 HTTP 协议会得到 TLS （安全传输层协议） 或其前辈 SSL （安全套接层） 的加密。因此 HTTPS 也常指 HTTP over TLS 或 HTTP over SSL。</description></item><item><title>SOCKS 协议交互流程记录</title><link>https://aladdinding.cn/post/socks-%E5%8D%8F%E8%AE%AE%E4%BA%A4%E4%BA%92%E6%B5%81%E7%A8%8B%E8%AE%B0%E5%BD%95/</link><pubDate>Sun, 19 Jul 2020 00:00:00 +0000</pubDate><guid>https://aladdinding.cn/post/socks-%E5%8D%8F%E8%AE%AE%E4%BA%A4%E4%BA%92%E6%B5%81%E7%A8%8B%E8%AE%B0%E5%BD%95/</guid><description>SOCKS 是一种网络传输协议，主要用于客户端与外网服务器之间通讯的中间传递。SOCKS 是 &amp;ldquo;Socket Secure&amp;rdquo; 的缩写。当防火墙后的客户端要访问外部的服务器时，就跟 SOCKS 代理服务器连接。这个代理服务器控制客户端访问外网的资格，允许的话，就将客户端的请求发往外部的服务器。这个协议最初由 David Koblas 开发，而后由 NEC 的 Ying-Da Lee 将其扩展到 SOCKS4。最新协议是 SOCKS5，与前一版本相比，增加支持 UDP（用户数据报协议）、验证，以及 IPv6。根据 OSI 模型，SOCKS 是 会话层 的协议，位于 表示层 与 传输层 之间。SOCKS 协议不提供 加密。
SOCKS5 SOCKS 协议版本认证 创建与 SOCKS5 服务器的 TCP 连接后客户端需要先发送请求来确认协议版本及认证方式（以字节为单位）
client send 1# +----+----------+----------+ 2# |VER | NMETHODS | METHODS | 3# +----+----------+----------+ 4# | 1 | 1 | 1 to 255 | 5# +----+----------+----------+ VER：SOCKS5 协议版本 0x05 NMETHODS：METHODS 所占字节长度 METHODS：客户端支持的认证方式列表，每个方法占 1 字节 0x00 不需要认证 0x01 GSSAPI 0x02 用户名、密码认证 0x03 to 0x7F 由 IANA 分配（保留） 0x80 to 0xFE 私人方法保留 0xFF 无可接受的方法 服务器从客户端提供的 METHODS 中选择一个并通过以下消息通知客户端</description></item></channel></rss>