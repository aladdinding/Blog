<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>gRPC on 大猫的本地回环地址</title><link>https://aladdinding.cn/tags/grpc/</link><description>Recent content in gRPC on 大猫的本地回环地址</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Thu, 01 Sep 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://aladdinding.cn/tags/grpc/index.xml" rel="self" type="application/rss+xml"/><item><title>gRPC发送已经序列化好的数据</title><link>https://aladdinding.cn/post/grpc%E5%8F%91%E9%80%81%E5%B7%B2%E7%BB%8F%E5%BA%8F%E5%88%97%E5%8C%96%E5%A5%BD%E7%9A%84%E6%95%B0%E6%8D%AE/</link><pubDate>Thu, 01 Sep 2022 00:00:00 +0000</pubDate><guid>https://aladdinding.cn/post/grpc%E5%8F%91%E9%80%81%E5%B7%B2%E7%BB%8F%E5%BA%8F%E5%88%97%E5%8C%96%E5%A5%BD%E7%9A%84%E6%95%B0%E6%8D%AE/</guid><description>场景 在之前的 gRPC 系统中加了个 redis 缓存临时缓冲要上报的数据，对于数据反复序列化肯定是有性能损耗的
而且 gRPC 提供的接口似乎没有可以直接发送已经序列化好的数据，似乎只能从生成的 gRPC 代码下手
实现 以 Python 代码举例：
发现在 xxx_pb2_grpc.py 文件中无论是 Stub 还是 Master 的消息参数中有下面两项，使用默认值 None 的话就可以直接传递序列化好的字节了
request_deserializer：An optional :term:deserializer for request deserialization
response_serializer：An optional :term:serializer for response serialization
为了不直接修改 xxx_pb2_grpc.py，于是继承 Stub 重写 __init__ 好了
class WithoutSerializerStub(xxx_pb2_grpc.Stub): &amp;#34;&amp;#34;&amp;#34;Missing associated documentation comment in .proto file.&amp;#34;&amp;#34;&amp;#34; def __init__(self, channel): &amp;#34;&amp;#34;&amp;#34;Constructor. Args: channel: A grpc.Channel. &amp;#34;&amp;#34;&amp;#34; self.msg = channel.stream_unary( &amp;#39;/server/msg&amp;#39;, request_serializer=None, response_deserializer=None, ) 成功搞定！</description></item><item><title>gRPC 框架入门</title><link>https://aladdinding.cn/post/grpc-%E6%A1%86%E6%9E%B6%E5%85%A5%E9%97%A8/</link><pubDate>Thu, 28 Jul 2022 00:00:00 +0000</pubDate><guid>https://aladdinding.cn/post/grpc-%E6%A1%86%E6%9E%B6%E5%85%A5%E9%97%A8/</guid><description>近期上线项目优化，需要将节点与 master 交互方式从之前的短轮训改进到长连接，同时也需要改进序列化传输方式（之前使用的是序列化 pythoon 对象的 ujosn），很自然就想到了 grpc。
gRPC 是什么 gRPC 是一种现代化开源的高性能 RPC 框架，能够运行于任意环境之中。最初由谷歌进行开发。它使用 HTTP/2 作为传输协议。
使用 gRPC， 我们可以一次性的在一个 .proto 文件中定义服务并使用任何支持它的语言去实现客户端和服务端，反过来，它们可以应用在各种场景中，从 Google 的服务器到你自己的平板电脑—— gRPC 帮你解决了不同语言及环境间通信的复杂性。使用 protocol buffers 还能获得其他好处，包括高效的序列化，简单的 IDL 以及容易进行接口更新。总之一句话，使用 gRPC 能让我们更容易编写跨语言的分布式代码。
IDL（Interface description language）是指接口描述语言，是用来描述软件组件接口的一种计算机语言，是跨平台开发的基础。IDL 通过一种中立的方式来描述接口，使得在不同平台上运行的对象和用不同语言编写的程序可以相互通信交流；比如，一个组件用 C++ 写成，另一个组件用 Go 写成。
编写 .proto 文件 官方提供的教学场景（导航服务）很适合入门，覆盖了 RPC 的四种模式，创建 route_guide.proto 文件，定义以下消息和服务
syntax = &amp;#34;proto3&amp;#34;;option go_package = &amp;#34;./protos&amp;#34;;package routeguide;// Interface exported by the server. service RouteGuide { // A simple RPC. // // Obtains the feature at a given position.</description></item></channel></rss>