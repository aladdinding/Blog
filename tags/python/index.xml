<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>python on 大猫的博客</title><link>https://aladdinding.cn/tags/python/</link><description>Recent content in python on 大猫的博客</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Thu, 28 Jul 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://aladdinding.cn/tags/python/index.xml" rel="self" type="application/rss+xml"/><item><title>gRPC框架入门demo</title><link>https://aladdinding.cn/post/grpc%E6%A1%86%E6%9E%B6%E5%85%A5%E9%97%A8demo/</link><pubDate>Thu, 28 Jul 2022 00:00:00 +0000</pubDate><guid>https://aladdinding.cn/post/grpc%E6%A1%86%E6%9E%B6%E5%85%A5%E9%97%A8demo/</guid><description>近期上线项目优化，需要将节点与master交互方式从之前的短轮训改进到长连接，同时也需要改进序列化传输方式（之前使用的是序列化pythoon对象的ujosn），很自然就想到了grpc
gRPC是什么 gRPC是一种现代化开源的高性能RPC框架，能够运行于任意环境之中。最初由谷歌进行开发。它使用HTTP/2作为传输协议。
使用gRPC， 我们可以一次性的在一个.proto文件中定义服务并使用任何支持它的语言去实现客户端和服务端，反过来，它们可以应用在各种场景中，从Google的服务器到你自己的平板电脑—— gRPC帮你解决了不同语言及环境间通信的复杂性。使用protocol buffers还能获得其他好处，包括高效的序列化，简单的IDL以及容易进行接口更新。总之一句话，使用gRPC能让我们更容易编写跨语言的分布式代码。
IDL（Interface description language）是指接口描述语言，是用来描述软件组件接口的一种计算机语言，是跨平台开发的基础。IDL通过一种中立的方式来描述接口，使得在不同平台上运行的对象和用不同语言编写的程序可以相互通信交流；比如，一个组件用C++写成，另一个组件用Go写成。
编写.proto文件 官方提供的教学场景（导航服务）很适合入门，覆盖了RPC的四种模式，创建route_guide.proto文件，定义以下消息和服务
// Copyright 2015 gRPC authors. // // Licensed under the Apache License, Version 2.0 (the &amp;#34;License&amp;#34;); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an &amp;#34;AS IS&amp;#34; BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</description></item><item><title>Python 中的线程安全和原子操作</title><link>https://aladdinding.cn/post/python-%E4%B8%AD%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E5%92%8C%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C/</link><pubDate>Tue, 19 Apr 2022 00:00:00 +0000</pubDate><guid>https://aladdinding.cn/post/python-%E4%B8%AD%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E5%92%8C%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C/</guid><description>经常看到一些 Python 第三方库的 features 中都写到了 Thread safety（线程安全），那么究竟什么是线程安全呢？
线程不安全 首先看看线程不安全的情况，下面一段代码开启的了两个线程，对全局变量 number 自增 100 万次
from threading import Thread number = 0 def target(): global number for _ in range(1000000): number += 1 thread_01 = Thread(target=target) thread_02 = Thread(target=target) thread_01.start() thread_02.start() thread_01.join() thread_02.join() print(number) 1476577 1134416 1437371 连续输出多次发现结果并不是我们想要的 200 万，这就是线程不安全。究其原因就是 number+=1 这段代码不是原子操作
原子操作 原子操作（atomic operation），指不会被线程调度机制打断的操作，这种操作一旦开始，就一直运行到结束，中间不会切换到其他线程，有点类似数据库中的事务。
在 Python 的 官方文档 中就列出了哪些操作是原子操作（L、L1、L2 是列表，D、D1、D2 是字典，x、y 是对象，i、j 是 int）
L.append(x) L1.extend(L2) x = L[i] x = L.</description></item><item><title>The Zen of Python</title><link>https://aladdinding.cn/post/the-zen-of-python/</link><pubDate>Thu, 16 Jan 2020 00:00:00 +0000</pubDate><guid>https://aladdinding.cn/post/the-zen-of-python/</guid><description>原文 Beautiful is better than ugly. Explicit is better than implicit. Simple is better than complex. Complex is better than complicated. Flat is better than nested. Sparse is better than dense. Readability counts. Special cases aren&amp;rsquo;t special enough to break the rules. Although practicality beats purity. Errors should never pass silently. Unless explicitly silenced. In the face of ambiguity, refuse the temptation to guess. There should be one&amp;ndash; and preferably only one &amp;ndash;obvious way to do it.</description></item></channel></rss>