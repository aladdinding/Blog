<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Python on 大猫的博客</title><link>https://aladdinding.cn/tags/python/</link><description>Recent content in Python on 大猫的博客</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Tue, 19 Apr 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://aladdinding.cn/tags/python/index.xml" rel="self" type="application/rss+xml"/><item><title>Python 中的线程安全和原子操作</title><link>https://aladdinding.cn/post/python-%E4%B8%AD%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E5%92%8C%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C/</link><pubDate>Tue, 19 Apr 2022 00:00:00 +0000</pubDate><guid>https://aladdinding.cn/post/python-%E4%B8%AD%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E5%92%8C%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C/</guid><description>经常看到一些 Python 第三方库的 features 中都写到了 Thread safety（线程安全），那么究竟什么是线程安全呢？
线程不安全 首先看看线程不安全的情况，下面一段代码开启的了两个线程，对全局变量 number 自增 100 万次
1from threading import Thread 2 3number = 0 4 5def target(): 6 global number 7 for _ in range(1000000): 8 number += 1 9 10thread_01 = Thread(target=target) 11thread_02 = Thread(target=target) 12thread_01.start() 13thread_02.start() 14 15thread_01.join() 16thread_02.join() 17 18print(number) 11476577 21134416 31437371 连续输出多次发现结果并不是我们想要的 200 万，这就是线程不安全。究其原因就是 number+=1 这段代码不是原子操作
原子操作 原子操作（atomic operation），指不会被线程调度机制打断的操作，这种操作一旦开始，就一直运行到结束，中间不会切换到其他线程，有点类似数据库中的事务。
在 Python 的 官方文档 中就列出了哪些操作是原子操作（L、L1、L2 是列表，D、D1、D2 是字典，x、y 是对象，i、j 是 int）</description></item><item><title>The Zen of Python</title><link>https://aladdinding.cn/post/the-zen-of-python/</link><pubDate>Thu, 16 Jan 2020 00:00:00 +0000</pubDate><guid>https://aladdinding.cn/post/the-zen-of-python/</guid><description>原文 Beautiful is better than ugly. Explicit is better than implicit. Simple is better than complex. Complex is better than complicated. Flat is better than nested. Sparse is better than dense. Readability counts. Special cases aren&amp;rsquo;t special enough to break the rules. Although practicality beats purity. Errors should never pass silently. Unless explicitly silenced. In the face of ambiguity, refuse the temptation to guess. There should be one&amp;ndash; and preferably only one &amp;ndash;obvious way to do it.</description></item></channel></rss>