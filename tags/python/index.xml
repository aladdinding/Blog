<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>python on 大猫的博客</title><link>https://aladdinding.cn/tags/python/</link><description>Recent content in python on 大猫的博客</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Thu, 28 Jul 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://aladdinding.cn/tags/python/index.xml" rel="self" type="application/rss+xml"/><item><title>gRPC 框架入门</title><link>https://aladdinding.cn/post/grpc-%E6%A1%86%E6%9E%B6%E5%85%A5%E9%97%A8/</link><pubDate>Thu, 28 Jul 2022 00:00:00 +0000</pubDate><guid>https://aladdinding.cn/post/grpc-%E6%A1%86%E6%9E%B6%E5%85%A5%E9%97%A8/</guid><description>近期上线项目优化，需要将节点与 master 交互方式从之前的短轮训改进到长连接，同时也需要改进序列化传输方式（之前使用的是序列化 pythoon 对象的 ujosn），很自然就想到了 grpc。
gRPC 是什么 gRPC 是一种现代化开源的高性能 RPC 框架，能够运行于任意环境之中。最初由谷歌进行开发。它使用 HTTP/2 作为传输协议。
使用 gRPC， 我们可以一次性的在一个 .proto 文件中定义服务并使用任何支持它的语言去实现客户端和服务端，反过来，它们可以应用在各种场景中，从 Google 的服务器到你自己的平板电脑—— gRPC 帮你解决了不同语言及环境间通信的复杂性。使用 protocol buffers 还能获得其他好处，包括高效的序列化，简单的 IDL 以及容易进行接口更新。总之一句话，使用 gRPC 能让我们更容易编写跨语言的分布式代码。
IDL（Interface description language）是指接口描述语言，是用来描述软件组件接口的一种计算机语言，是跨平台开发的基础。IDL 通过一种中立的方式来描述接口，使得在不同平台上运行的对象和用不同语言编写的程序可以相互通信交流；比如，一个组件用 C++ 写成，另一个组件用 Go 写成。
编写 .proto 文件 官方提供的教学场景（导航服务）很适合入门，覆盖了 RPC 的四种模式，创建 route_guide.proto 文件，定义以下消息和服务
syntax = &amp;#34;proto3&amp;#34;;option go_package = &amp;#34;./protos&amp;#34;;package routeguide;// Interface exported by the server. service RouteGuide { // A simple RPC. // // Obtains the feature at a given position.</description></item><item><title>Python 中的线程安全和原子操作</title><link>https://aladdinding.cn/post/python-%E4%B8%AD%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E5%92%8C%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C/</link><pubDate>Tue, 19 Apr 2022 00:00:00 +0000</pubDate><guid>https://aladdinding.cn/post/python-%E4%B8%AD%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E5%92%8C%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C/</guid><description>经常看到一些 Python 第三方库的 features 中都写到了 Thread safety（线程安全），那么究竟什么是线程安全呢？
线程不安全 首先看看线程不安全的情况，下面一段代码开启的了两个线程，对全局变量 number 自增 100 万次
from threading import Thread number = 0 def target(): global number for _ in range(1000000): number += 1 thread_01 = Thread(target=target) thread_02 = Thread(target=target) thread_01.start() thread_02.start() thread_01.join() thread_02.join() print(number) 1476577 1134416 1437371 连续输出多次发现结果并不是我们想要的 200 万，这就是线程不安全。究其原因就是 number+=1 这段代码不是原子操作
原子操作 原子操作（atomic operation），指不会被线程调度机制打断的操作，这种操作一旦开始，就一直运行到结束，中间不会切换到其他线程，有点类似数据库中的事务。
在 Python 的 官方文档 中就列出了哪些操作是原子操作（L、L1、L2 是列表，D、D1、D2 是字典，x、y 是对象，i、j 是 int）
L.append(x) L1.extend(L2) x = L[i] x = L.</description></item><item><title>The Zen of Python</title><link>https://aladdinding.cn/post/the-zen-of-python/</link><pubDate>Thu, 16 Jan 2020 00:00:00 +0000</pubDate><guid>https://aladdinding.cn/post/the-zen-of-python/</guid><description>原文 Beautiful is better than ugly. Explicit is better than implicit. Simple is better than complex. Complex is better than complicated. Flat is better than nested. Sparse is better than dense. Readability counts. Special cases aren&amp;rsquo;t special enough to break the rules. Although practicality beats purity. Errors should never pass silently. Unless explicitly silenced. In the face of ambiguity, refuse the temptation to guess. There should be one&amp;ndash; and preferably only one &amp;ndash;obvious way to do it.</description></item></channel></rss>