<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on 大猫的本地回环地址</title><link>https://aladdinding.cn/post/</link><description>Recent content in Posts on 大猫的本地回环地址</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Thu, 01 Sep 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://aladdinding.cn/post/index.xml" rel="self" type="application/rss+xml"/><item><title>读《如何成为一名黑客》有感</title><link>https://aladdinding.cn/post/%E8%AF%BB%E5%A6%82%E4%BD%95%E6%88%90%E4%B8%BA%E4%B8%80%E5%90%8D%E9%BB%91%E5%AE%A2%E6%9C%89%E6%84%9F/</link><pubDate>Mon, 06 Apr 2020 00:00:00 +0000</pubDate><guid>https://aladdinding.cn/post/%E8%AF%BB%E5%A6%82%E4%BD%95%E6%88%90%E4%B8%BA%E4%B8%80%E5%90%8D%E9%BB%91%E5%AE%A2%E6%9C%89%E6%84%9F/</guid><description>从我毕业进入公司起，负责人就一直在提及一点：「编程不仅仅是知识和技能，更重要的是去领会编程领域的文化」。刚进入公司的我似乎并没有马上接受这一点，认为这可能只是所谓的 “玄学” 罢了，所以也就是当作任务记下了，并没有很好的理会。
直到我工作了一年后，疫情期间读完负责人发来的一篇《如何成为一名黑客》，文章似乎解答了我初入编程行业的疑惑并且指明了未来的方向。
标题是如何成为一名黑客，这里的黑客并不是我们所认为的在网络中来无影去无踪的 “黑客”。在我看来，这篇文章讲述的是你如何成为一名优秀并且受人尊敬的计算机工程师。
基本的态度 这个世界充满了令人着迷的问题等着我们去解决 你要从解决问题，磨练技术，以及锻炼智力中得到基本的享受以及动力。的确，回想这一年的工作时光，另我开心的事情莫过于解决了棘手问题，学习了一门新的语言，自己完成的功能第二天就上线，得到了客户的认可等等。
一个问题不应该被解决两次 不应该把宝贵的时间浪费在发明轮子上。初入公司我想着把很多 python2 的代码重构成 python3，现在想想确实浪费时间，应该着重于解决新的问题而不是在旧问题上浪费时间。
无聊和乏味的工作是罪恶的 重复性劳动浪费我们解决新问题的时间，而解决新问题才是最大的价值所在。提取公共函数，将日常的工作变成自动化等等。
崇尚自由 其实这一点并不是很理解，产品经理提出无理的需求？？？
2020/09/10 更新：这个上升到政治层面就比较好理解了，比如美国打压 WeChat 和 Tik Tok
态度不能代替能力 只具备这些态度并不能使你成为一名黑客，也不能使你成为一个运动健将和摇滚明星。成为一名黑客需要智力、实践、奉献精神、以及辛苦的工作。
基本的技能 学习如何编程（这里包括以下内容有几句话写的很好，我想全搬运过来） 有一个大体的规律，就是如果你过于偏重使用一种语言，这种语言一方面会成为你得心应手的工具，另一方面也会阻碍你的学习。有这个问题的不只是编程语言，类似 RubyOnRails、CakePHP、以及 Django 的 web 应用框架也有这个问题，它们只会让你肤浅地懂得一些东西，当你碰到难以解决的问题或者需要调试时，你就可能不知所措了。
单单学习编程语言并不会让你达到黑客的程度，甚至连程序员的程度都难企及——你需要脱离某种编程语言的束缚，学习通过编程解决问题的思路。要成为一个真正的黑客，你需要达到几天就能学会一门编程语言的水平，你可以将文档里的信息和你已经掌握的知识结合起来，很快就学会一门编程语言。这意味着你需要先学会机种思路截然不同的语言才行。
编程是一个复杂的技能，我无法给你完整的指南来教会你如何编程，不过我可以告诉你，书本和课程也无法教会你如何编程——很多黑客，或者也许几乎所有的黑客，都是靠自学的。你从书本上学到语言的特点——只是一些皮毛，但要使书面知识成为自身技能，你只能通过实践和虚心向他人学习。因此你要做的就是 (a) 读代码，(b) 写代码。
学习编程就象学习自然语言写作一样。最好的做法是读一些大师的名著，试着自己写点东西，再读些，再写点，再读些，再写点…… 如此往复，直到你的文章具备范文的力量和感觉为止。
学会使用开源的 Unix 系统 Unix 还是 Internet 的操作系统。你可以学会上网却不知道 Unix，但你不了解 Unix 就无法成为一名 Internet 黑客。因此，今天的黑客文化在很大程度上是以 Unix 为核心的。（这点并不总是真的，一些很早的黑客对此一直很不满，但 Unix 和 Internet 之间的联系已是如此之强，就连 Microsoft 这样强力的公司也对此也无可奈何。）</description></item><item><title>gRPC发送已经序列化好的数据</title><link>https://aladdinding.cn/post/grpc%E5%8F%91%E9%80%81%E5%B7%B2%E7%BB%8F%E5%BA%8F%E5%88%97%E5%8C%96%E5%A5%BD%E7%9A%84%E6%95%B0%E6%8D%AE/</link><pubDate>Thu, 01 Sep 2022 00:00:00 +0000</pubDate><guid>https://aladdinding.cn/post/grpc%E5%8F%91%E9%80%81%E5%B7%B2%E7%BB%8F%E5%BA%8F%E5%88%97%E5%8C%96%E5%A5%BD%E7%9A%84%E6%95%B0%E6%8D%AE/</guid><description>场景 在之前的 gRPC 系统中加了个 redis 缓存临时缓冲要上报的数据，对于数据反复序列化肯定是有性能损耗的
而且 gRPC 提供的接口似乎没有可以直接发送已经序列化好的数据，似乎只能从生成的 gRPC 代码下手
实现 以 Python 代码举例：
发现在 xxx_pb2_grpc.py 文件中无论是 Stub 还是 Master 的消息参数中有下面两项，使用默认值 None 的话就可以直接传递序列化好的字节了
request_deserializer：An optional :term:deserializer for request deserialization
response_serializer：An optional :term:serializer for response serialization
为了不直接修改 xxx_pb2_grpc.py，于是继承 Stub 重写 __init__ 好了
class WithoutSerializerStub(xxx_pb2_grpc.Stub): &amp;#34;&amp;#34;&amp;#34;Missing associated documentation comment in .proto file.&amp;#34;&amp;#34;&amp;#34; def __init__(self, channel): &amp;#34;&amp;#34;&amp;#34;Constructor. Args: channel: A grpc.Channel. &amp;#34;&amp;#34;&amp;#34; self.msg = channel.stream_unary( &amp;#39;/server/msg&amp;#39;, request_serializer=None, response_deserializer=None, ) 成功搞定！</description></item><item><title>gRPC 框架入门</title><link>https://aladdinding.cn/post/grpc-%E6%A1%86%E6%9E%B6%E5%85%A5%E9%97%A8/</link><pubDate>Thu, 28 Jul 2022 00:00:00 +0000</pubDate><guid>https://aladdinding.cn/post/grpc-%E6%A1%86%E6%9E%B6%E5%85%A5%E9%97%A8/</guid><description>近期上线项目优化，需要将节点与 master 交互方式从之前的短轮训改进到长连接，同时也需要改进序列化传输方式（之前使用的是序列化 pythoon 对象的 ujosn），很自然就想到了 grpc。
gRPC 是什么 gRPC 是一种现代化开源的高性能 RPC 框架，能够运行于任意环境之中。最初由谷歌进行开发。它使用 HTTP/2 作为传输协议。
使用 gRPC， 我们可以一次性的在一个 .proto 文件中定义服务并使用任何支持它的语言去实现客户端和服务端，反过来，它们可以应用在各种场景中，从 Google 的服务器到你自己的平板电脑—— gRPC 帮你解决了不同语言及环境间通信的复杂性。使用 protocol buffers 还能获得其他好处，包括高效的序列化，简单的 IDL 以及容易进行接口更新。总之一句话，使用 gRPC 能让我们更容易编写跨语言的分布式代码。
IDL（Interface description language）是指接口描述语言，是用来描述软件组件接口的一种计算机语言，是跨平台开发的基础。IDL 通过一种中立的方式来描述接口，使得在不同平台上运行的对象和用不同语言编写的程序可以相互通信交流；比如，一个组件用 C++ 写成，另一个组件用 Go 写成。
编写 .proto 文件 官方提供的教学场景（导航服务）很适合入门，覆盖了 RPC 的四种模式，创建 route_guide.proto 文件，定义以下消息和服务
syntax = &amp;#34;proto3&amp;#34;;option go_package = &amp;#34;./protos&amp;#34;;package routeguide;// Interface exported by the server. service RouteGuide { // A simple RPC. // // Obtains the feature at a given position.</description></item><item><title>Protocol Buffers协议使用小结</title><link>https://aladdinding.cn/post/protocol-buffers%E5%8D%8F%E8%AE%AE%E4%BD%BF%E7%94%A8%E5%B0%8F%E7%BB%93/</link><pubDate>Tue, 26 Jul 2022 00:00:00 +0000</pubDate><guid>https://aladdinding.cn/post/protocol-buffers%E5%8D%8F%E8%AE%AE%E4%BD%BF%E7%94%A8%E5%B0%8F%E7%BB%93/</guid><description>官方文档 Language Guide (proto3)
protocol-buffers 代码生成指南
网络上关于 Protocol Buffers 的翻译已经很多了，这里就不再重新写一遍了，主要记录一下常用语法。其实就是定义一个 .proto 文件，然后根据不同语言的插件生成不同的代码，通常代码会分为两个文件，以 go 语言为例子
xxx.pb.go 主要包含消息定义的 go 语言代码 xxx_grpc.pb.go 主要包含 grpc，也就是服务端，客户端之间交互的代码 至于为什么要分成两个文件（记得之前版本 go 语言只生成一个文件），应该是不同语言 grpc 的通信实现有很多吧，像 python 就有 gevent 和 asyncio 两种，拆分也是让文件分工更加清晰
至于 .proto 文件也是主要以：定义消息、定义服务、其他规范：注释、选项等等 组成
其他规范 文件开头通常是 syntax = &amp;quot;proto3&amp;quot;;，这个必须写在开头，表示使用的是 proto3 的语法，不写的话默认为 proto2
其次是类似 option go_package = &amp;quot;example.com/proto&amp;quot;; 这样的选项，用于不同语言生成代码的参数
注释与 c/c++ 语法相同，使用：//（单行注释）和 /* ... */（多行注释）
Message 命名采用驼峰命名方式，字段命名采用小写字母加下划线分隔方式</description></item><item><title>go 中的 Interfaces 类型与值、指针接收者</title><link>https://aladdinding.cn/post/go-%E4%B8%AD%E7%9A%84-interfaces-%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%80%BC%E6%8C%87%E9%92%88%E6%8E%A5%E6%94%B6%E8%80%85/</link><pubDate>Mon, 25 Jul 2022 00:00:00 +0000</pubDate><guid>https://aladdinding.cn/post/go-%E4%B8%AD%E7%9A%84-interfaces-%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%80%BC%E6%8C%87%E9%92%88%E6%8E%A5%E6%94%B6%E8%80%85/</guid><description>以下代码有几点说明：
Cat 和 Dog 都实现了 Animal 接口的 SetName 方法 Cat 实现的接口为值接收者（value receiver） Dog 实现的接口为指针接收者（pointer receiver） package main import ( &amp;#34;fmt&amp;#34; ) type Animal interface { SetName() } type Cat struct { Name string } func (c Cat) SetName() { c.Name = &amp;#34;喵星人&amp;#34; } type Dog struct { Name string } func (d *Dog) SetName() { d.Name = &amp;#34;汪星人&amp;#34; } func main() { var a1 Animal = Cat{} a1.SetName() fmt.</description></item><item><title>go 中的 string、rune 和 byte</title><link>https://aladdinding.cn/post/go-%E4%B8%AD%E7%9A%84-stringrune-%E5%92%8C-byte/</link><pubDate>Tue, 19 Jul 2022 00:00:00 +0000</pubDate><guid>https://aladdinding.cn/post/go-%E4%B8%AD%E7%9A%84-stringrune-%E5%92%8C-byte/</guid><description>Go 语言中的 byte 和 rune 实际上是 uin8 和 int32 类型
byte 一般来表示一些原始数据（如网络中的数据传输） rune 则用来表示 Unciode 字符 在 go 中 string 的底层用的就是 byte 字节数组存储的，它的遍历有两种情况
package main import ( &amp;#34;fmt&amp;#34; ) func main() { s := &amp;#34;abc汉字&amp;#34; for i := 0; i &amp;lt;len(s); i++ { fmt.Printf(&amp;#34;%c,&amp;#34;, s[i]) } fmt.Println() for _, r := range s { fmt.Printf(&amp;#34;%c,&amp;#34;, r) } } // 结果 // a,b,c,æ,±,,å,­,, // a,b,c,汉,字, 想获取字符串中的字符个数需要转换 []rune 数组，获取中文字符下标同理</description></item><item><title>Web安全基础学习</title><link>https://aladdinding.cn/post/web%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/</link><pubDate>Wed, 11 May 2022 00:00:00 +0000</pubDate><guid>https://aladdinding.cn/post/web%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/</guid><description>首先说下自己并不是专门做安全的，此次总结也确实是工作中遇到了这类问题需要解决
当然如果你自己有过搭建服务的经历，或许会在服务的访问记录中看到各种乱七八载的访问
如果有以下情况的话，就送他一个iptables套餐吧
SQL注入 SQL注入是一种代码注入技术，用于攻击数据驱动的应用程序。 在应用程序中，如果没有做恰当的过滤，则可能使得恶意的SQL语句被插入输入字段中执行（例如将数据库内容转储给攻击者）
报错注入
extractvalue(1, concat(0x5c,(select user()))) updatexml(0x3a,concat(1,(select user())),1) http://ns2.stats.gov.cn/comment/api/index.php?gid=1&amp;amp;page=2&amp;amp;rlist%5B%5D=%40%60%27%60%2C+extractvalue%281%2C+concat_ws%280x20%2C+0x5c%2C%28select+md5%28202072102%29%29%29%29%2C%40%60%27%60 http://14.29.113.88:9292/api/sms_check.php?param=1%27+and+updatexml%281%2Cconcat%280x7e%2C%28SELECT+MD5%281234%29%29%2C0x7e%29%2C1%29--+ 数据路检测（mysql）
sleep：sleep(1) 让sql运行多少秒 字符串连接：SELECT CONCAT(’some‘, &amp;lsquo;string&amp;rsquo;) 报错注入：convert(int, (db_name())) 等等 http://218.13.13.90:8081/fsGovPlatform/js/(select(0)from(select(sleep(34)))v)%2f*&amp;#39;+(select(0)from(select(sleep(34)))v)+&amp;#39;&amp;#34;&amp;#34;+(select(0)from(select(sleep(34)))v)+&amp;#34;&amp;#34;*%2f/timepicker/jquery-ui-timepicker-addon.js http://210.76.74.50/faq.php?action=grouppermission&amp;amp;gids%5B100%5D%5B0%5D=%29+and+%28select+1+from+%28select+count%28%2A%29%2Cconcat%28%28select+concat%28user%2C0x3a%2Cmd5%281234%29%2C0x3a%29+from+mysql.user+limit+0%2C1%29%2Cfloor%28rand%280%29%2A2%29%29x+from+information_schema.tables+group+by+x%29a%29%23&amp;amp;gids%5B99%5D=%27 http://xwrz.huizhou.gov.cn/invest-client/rzcs/index.html?assureType=123456&amp;amp;minBalance=convert%28int%2Csys.fn_sqlvarbasetostr%28HashBytes%28%27MD5%27%2C%271078491144%27%29%29%29&amp;amp;moneyrateStart=123456&amp;amp;type=123456 XSS XSS全称为Cross Site Scripting，为了和CSS分开简写为XSS，中文名为跨站脚本。该漏洞发生在用户端，是指在渲染过程中发生了不在预期过程中的JavaScript代码执行。XSS通常被用于获取Cookie、以受攻击者的身份进行操作等行为
# 特征 &amp;lt;script src=&amp;#34;...&amp;#34;&amp;gt;&amp;lt;/script&amp;gt; http://qqt.gdqy.gov.cn/tomcat-docs/appdev/sample/web/hello.jsp?test=&amp;lt;script&amp;gt;alert(12345)&amp;lt;/script&amp;gt; CSRF 跨站请求伪造 (Cross-Site Request Forgery, CSRF)，也被称为 One Click Attack 或者 Session Riding ，通常缩写为CSRF，是一种对网站的恶意利用。尽管听起来像XSS，但它与XSS非常不同，XSS利用站点内的信任用户，而CSRF则通过伪装来自受信任用户的请求来利用受信任的网站
SSRF 服务端请求伪造（Server Side Request Forgery, SSRF）指的是攻击者在未能取得服务器所有权限时，利用服务器漏洞以服务器的身份发送一条构造好的请求给服务器所在内网。SSRF攻击通常针对外部网络无法直接访问的内部系统
通过各种非http协议 file:///path/to/file http://183.63.186.68/Web/file:%2f%2f%2fetc%2fpasswd.html 命令注入 命令注入通常因为指Web应用在服务器上拼接系统命令而造成的漏洞。</description></item><item><title>设计模式之结构型模式</title><link>https://aladdinding.cn/post/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/</link><pubDate>Fri, 06 May 2022 00:00:00 +0000</pubDate><guid>https://aladdinding.cn/post/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/</guid><description>结构型模式介绍如何将对象和类组装成较大的结构，并同时保持结构的灵活和高效
适配器 桥接 组合 组合模式是一种结构型设计模式，你可以使用它将对象组合成树状结构，并且能像使用独立对象一样使用它们。
在组合模式中，无论是复杂的还是简单的对象共用一个接口。在这个统一接口的帮助下，客户端不必在意其对象的具体类
装饰 装饰模式是一种结构型设计模式，允许你通过将对象放入包含行为的特殊封装对象中来为原对象绑定新的行为。
package main import &amp;#34;fmt&amp;#34; type drink interface { getPrice() int } type coffee struct { } func (c *coffee) getPrice() int { return 20 } type addMilk struct { drink drink } func (add *addMilk) getPrice() int { drinkPrice := add.drink.getPrice() return drinkPrice + 5 } type addSugar struct { drink drink } func (add *addSugar) getPrice() int { drinkPrice := add.</description></item><item><title>Git常用模版文件</title><link>https://aladdinding.cn/post/git%E5%B8%B8%E7%94%A8%E6%A8%A1%E7%89%88%E6%96%87%E4%BB%B6/</link><pubDate>Sun, 24 Apr 2022 00:00:00 +0000</pubDate><guid>https://aladdinding.cn/post/git%E5%B8%B8%E7%94%A8%E6%A8%A1%E7%89%88%E6%96%87%E4%BB%B6/</guid><description>.gitignore # vim *.swp *.swo *.so # vim plugin # https://github.com/tpope/vim-projectionist .projections.json # TOOD file TODO.md TODO.txt todo.md todo.txt # python .ropeproject/ *.pyc *.pyo # testfile run_admin.sh wnntest.sh wnnrun.sh wnntodo.md run.sh .python-version .tmp # mvn mvn_publish.sh # js/node .tern-port .tern-project t.js node_modules/ # ag silver searcher .agignore # IDE .idea # mac .DS_Store # personal mydoc # golang .gometalinter.json .netrwhist # redis dump.rdb Commit 模版 # head: &amp;lt;type&amp;gt;(&amp;lt;scope&amp;gt;): &amp;lt;subject&amp;gt; # - type: feat, fix, docs, style, refactor, test, chore # - scope: can be empty (eg.</description></item><item><title>Git 常用命令总结</title><link>https://aladdinding.cn/post/git-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/</link><pubDate>Thu, 21 Apr 2022 00:00:00 +0000</pubDate><guid>https://aladdinding.cn/post/git-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/</guid><description>Git Documentation
Git 教程 - 廖雪峰
Git 常用命令 git init 初始化本地 git 环境 git clone &amp;lt;repository&amp;gt; 克隆一份代码到本地仓库 git pull 把远程仓库代码更新到本地，等于 git fetch + git merge git pull --rebase origin master 强制把远程仓库的代码更新到当前分支上面 git fetch 把远程库的代码更新到本地 git add . 把本地改动过的文件添加到暂存区中 git commit -m '&amp;lt;commit message&amp;gt;' 把暂存区中的修改提交到本地库 git push 把本地库的修改提交到远程库中 git push origin &amp;lt;branch name&amp;gt; 提交一个分支到远程库中 git branch -r/-a 查看远程分支 / 全部分支 git checkout master/bugfix 切换到某个分支 git checkout -b bugfix 新建 bugfix 分支 git checkout -d bugfix 删除 bugfix 分支 git merge master 假设当前在 bugfix 分支上，把 master 分支上的修改同步到 bugfix 分支上 git merge tool 调用 merge 工具 git stash 把未完成的修改保存起来 git stash list 查看所有保存列表 git stash pop 恢复本地分支到缓存状态 git blame &amp;lt;file name&amp;gt; 查看某个文件每一行的修改记录，谁在什么时候修改的 git status 查看当前分支有哪些修改 git log 查看当前分支上面的日志信息 git diff 查看当前没有 add 的内容 git diff --cached 查看已经 add 但是没有 commit 的内容 git diff HEAD 上面两个命令显示内容的合并 git reset --hard HEAD 撤销本地修改 团队协作 Git 流程 克隆新项目，完成功能并提交 git clone &amp;lt;repository&amp;gt; 克隆代码仓库 git checkout -b &amp;lt;branch name&amp;gt; 新建分支 &amp;lt;modify your code&amp;gt; 完成功能的开发，代码的修改 git add .</description></item><item><title>使用 air 实现 go 程序热加载</title><link>https://aladdinding.cn/post/%E4%BD%BF%E7%94%A8-air-%E5%AE%9E%E7%8E%B0-go-%E7%A8%8B%E5%BA%8F%E7%83%AD%E5%8A%A0%E8%BD%BD/</link><pubDate>Thu, 21 Apr 2022 00:00:00 +0000</pubDate><guid>https://aladdinding.cn/post/%E4%BD%BF%E7%94%A8-air-%E5%AE%9E%E7%8E%B0-go-%E7%A8%8B%E5%BA%8F%E7%83%AD%E5%8A%A0%E8%BD%BD/</guid><description>在使用 Python Web 框架 Django 本地 runserver 启动后修改了代码，程序够自动重新加载并执行（live-reload），在开发调试阶段非常实用，可以提高开发效率。
在使用 Go 开发自己的项目或者使用 gin 框架进行本地调试的时候，也需要在文件修改后自动编译运行查看效果，那么则可以使用 air 这个工具。
AIR air 使用 go 语言开发，可以实现 go 语言应用程序的热加载，它支持以下特性：
彩色日志输出 自定义构建或二进制命令 支持忽略子目录 启动后支持监听新目录 更好的构建流程 安装 由于是 go 语言开发，对于我来说就直接下载二进制文件放到系统 PATH 目录下了，当然也可以使用 go get 、Docker 等方式安装，具体可以查看 Readme 中其他的安装方法，这里就不再赘述了
使用 写好 .air.conf 文件放在项目目录下然后直接执行 air 命令就行，非常简单
完整的示例以及注释如下，需要新增环境变量或者是命令行参数的可以在 full_bin 前后添加
# [Air](https://github.com/cosmtrek/air) TOML 格式的配置文件 # 工作目录 # 使用 . 或绝对路径，请注意 `tmp_dir` 目录必须在 `root` 目录下 root = &amp;#34;.&amp;#34; tmp_dir = &amp;#34;tmp&amp;#34; [build] # 只需要写你平常编译使用的 shell 命令。你也可以使用 `make` cmd = &amp;#34;go build -o .</description></item><item><title>Python 中的线程安全和原子操作</title><link>https://aladdinding.cn/post/python-%E4%B8%AD%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E5%92%8C%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C/</link><pubDate>Tue, 19 Apr 2022 00:00:00 +0000</pubDate><guid>https://aladdinding.cn/post/python-%E4%B8%AD%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E5%92%8C%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C/</guid><description>经常看到一些 Python 第三方库的 features 中都写到了 Thread safety（线程安全），那么究竟什么是线程安全呢？
线程不安全 首先看看线程不安全的情况，下面一段代码开启的了两个线程，对全局变量 number 自增 100 万次
from threading import Thread number = 0 def target(): global number for _ in range(1000000): number += 1 thread_01 = Thread(target=target) thread_02 = Thread(target=target) thread_01.start() thread_02.start() thread_01.join() thread_02.join() print(number) 1476577 1134416 1437371 连续输出多次发现结果并不是我们想要的 200 万，这就是线程不安全。究其原因就是 number+=1 这段代码不是原子操作
原子操作 原子操作（atomic operation），指不会被线程调度机制打断的操作，这种操作一旦开始，就一直运行到结束，中间不会切换到其他线程，有点类似数据库中的事务。
在 Python 的 官方文档 中就列出了哪些操作是原子操作（L、L1、L2 是列表，D、D1、D2 是字典，x、y 是对象，i、j 是 int）
L.append(x) L1.extend(L2) x = L[i] x = L.</description></item><item><title>武汉海昌极地海洋世界游玩tips</title><link>https://aladdinding.cn/post/%E6%AD%A6%E6%B1%89%E6%B5%B7%E6%98%8C%E6%9E%81%E5%9C%B0%E6%B5%B7%E6%B4%8B%E4%B8%96%E7%95%8C%E6%B8%B8%E7%8E%A9tips/</link><pubDate>Mon, 04 Apr 2022 00:00:00 +0000</pubDate><guid>https://aladdinding.cn/post/%E6%AD%A6%E6%B1%89%E6%B5%B7%E6%98%8C%E6%9E%81%E5%9C%B0%E6%B5%B7%E6%B4%8B%E4%B8%96%E7%95%8C%E6%B8%B8%E7%8E%A9tips/</guid><description>入园以后先获取园区地图和当天各个表演的时间，合理安排游玩路线
必看表演 狂欢大巡游（全园区的大迅游，上午下午各一次，特别热闹） 功夫山庄（动物表演，有海象、海豹、水獭等，建议提前10分钟占好位置） 极地奇缘（海豚表演剧场，建议提前10分钟占好位置） 白鲸之恋（白鲸与饲养员的互动） 人鱼华尔兹（美人鱼演员表演） 各展厅推荐游览方案 企鹅展厅 一定要在企鹅喂食的时间观看，喂食过程很好玩，而且吃完东西的企鹅很活泼，到处跑到处游
白鲸展厅 请务必17点以后去一趟白鲸展厅，那个时候大部分游客都已经玩累了出园回家了，你可以一个人享受整个白鲸展厅，这个时候你会看到不一样的白鲸，强烈推荐！！！
海底两万里 这里也建议17点以后再去一趟，体验一下一个人的海底，才能值回票价！
总结 17点以后的海洋公园才是最好玩的海洋公园，不到清场不要离开园区！我入园的时候比较晚，下午2点才入园，以为体验会很赶，但是17点以后的白鲸馆和海底两万里让我感觉赚了！表演尽量都看完，合理安排时间，不要走马观花，多停留一段时间可以看到不一样的场景。</description></item><item><title>JetBrains 开发者工具相关资源（含破解）</title><link>https://aladdinding.cn/post/jetbrains-%E5%BC%80%E5%8F%91%E8%80%85%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3%E8%B5%84%E6%BA%90%E5%90%AB%E7%A0%B4%E8%A7%A3/</link><pubDate>Thu, 23 Dec 2021 00:00:00 +0000</pubDate><guid>https://aladdinding.cn/post/jetbrains-%E5%BC%80%E5%8F%91%E8%80%85%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3%E8%B5%84%E6%BA%90%E5%90%AB%E7%A0%B4%E8%A7%A3/</guid><description>Whatever platform or language you work with, JetBrains has a development tool for you.
JetBrains 旗下的 IDE 不论是界面布局还是快捷键等都是通用的，所以掌握好 JetBrains 下产品的使用技巧还是非常值得的。
教程 JetBrains 自家产品的帮助中心已经非常完善了
JetBrains Product Documentation
以 PyCharm 举例，用户界面描述：
Editor 编辑 Action indicators and action list 行动指标和行动清单 Navigation bar 导航栏 Status bar 状态栏 Tool windows 工具窗口 Context menus 上下文菜单 Popup menus 弹出菜单 Main window 主窗口 其他产品的用户界面类似，具体的也可以去文档中心中查看
破解&amp;amp;白嫖 正常情况下 JetBrains 公司的每个 IDE 分为 Ultimate（企业版）、Professional（专业版）和 Community（社区免费）这几个版本，其中企业版和专业版是要收费的，相比于社区版功能更多。
利用 JetBrains 家产品都有免费一个月的试用期，所以安装一个到期重置试用插件即可。</description></item><item><title>HTTPS 协议是如何握手的</title><link>https://aladdinding.cn/post/https-%E5%8D%8F%E8%AE%AE%E6%98%AF%E5%A6%82%E4%BD%95%E6%8F%A1%E6%89%8B%E7%9A%84/</link><pubDate>Tue, 23 Nov 2021 00:00:00 +0000</pubDate><guid>https://aladdinding.cn/post/https-%E5%8D%8F%E8%AE%AE%E6%98%AF%E5%A6%82%E4%BD%95%E6%8F%A1%E6%89%8B%E7%9A%84/</guid><description>Hypertext Transfer Protocol Secure (HTTPS) is an extension of the Hypertext Transfer Protocol (HTTP). It is used for secure communication over a computer network, and is widely used on the Internet. In HTTPS, the communication protocol is encrypted using Transport Layer Security (TLS) or, formerly, its predecessor, Secure Sockets Layer (SSL). The protocol is therefore also often referred to as HTTP over TLS, or HTTP over SSL.
HTTPS (Hypertext Transfer Protocol Secure) 是基于 HTTP 的扩展，用于计算机网络的安全通信，已经在互联网得到广泛应用。在 HTTPS 中，原有的 HTTP 协议会得到 TLS （安全传输层协议） 或其前辈 SSL （安全套接层） 的加密。因此 HTTPS 也常指 HTTP over TLS 或 HTTP over SSL。</description></item><item><title>Redis 源码之简单动态字符串</title><link>https://aladdinding.cn/post/redis-%E6%BA%90%E7%A0%81%E4%B9%8B%E7%AE%80%E5%8D%95%E5%8A%A8%E6%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2/</link><pubDate>Fri, 05 Nov 2021 00:00:00 +0000</pubDate><guid>https://aladdinding.cn/post/redis-%E6%BA%90%E7%A0%81%E4%B9%8B%E7%AE%80%E5%8D%95%E5%8A%A8%E6%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2/</guid><description>Redis 中字符串的实现并没有完全使用 C 字符串，而是重新定义了简单动态字符串 SDS（Simple Dynamic String）用来表示字符串（Redis 3.2前）。
sds.h/sdshdr
struct sdshdr { unsigned int len; // 记录 buf 数组中已使字节的数量 unsigned int free; // 记录 buf 数组中未使用字节的数量 char buf[]; // 字节数组，用于保存字符串 }; buf 数组长度不一定就是字符串长度 + 1（&amp;quot;\0&amp;quot;），还有 free 空间，数组内未使用的字节通过 free 属性记录。
相比于 C 字符串，SDS 有以下优势：
兼容部分 C 字符串函数 sds.c/sdsnew
* mystring = sdsnewlen(&amp;#34;abc&amp;#34;,3); * * You can print the string with printf() as there is an implicit \0 at the * end of the string.</description></item><item><title>静态博客部署的最佳实践（适用 Hugo、Hexo）</title><link>https://aladdinding.cn/post/%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E9%80%82%E7%94%A8-hugohexo/</link><pubDate>Thu, 04 Nov 2021 00:00:00 +0000</pubDate><guid>https://aladdinding.cn/post/%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E9%80%82%E7%94%A8-hugohexo/</guid><description>有关静态博客部署的文章、视频教程已经很多了。
大致总结可以分为三类：
Github Pages + Github Action（网站托管，如：Vercel） 本地编译 + rsync 远程服务器 本地编译 + 推送对象存储（七牛云） 最佳实践 本地更新完文章提交推送 触发 Github Action Action 的 workflow 中完成静态资源的编译、推送至云服务器 云服务器 Nginx 访问静态资源 之前博客一直部署在 Github+Vercel，奈何美国服务器延迟太高，
国内的阿里云、腾讯云的网站托管、云开发体验太差，
刚好双十一购入三年的 2 核 4G 8M 带宽的轻量服务器（腾讯云 YYDS）！！！
趁着周末研究研究如何部署到云服务器上，
总体体验不错，满足了我既要远程编译，Github 托管代码、访问速度要快的需求，
这套流程中你只需要写好文章（不需要编博客译环境），推送至 Github 即可，
没有跑完这整个流程之前还比较担心 Github rsync 到腾讯云服务器会不会要很久，毕竟 Github 服务器在美国
实际测试 30s 内就可以完成整套 workflow，还是比较满意的
PS：首次可能会慢点，后续的 rsync 应该都是增量更新
顺带也开启了 HTTP/2.0，还是挺香的
部分配置文件 使用 PEM 格式生成公钥私钥
ssh-keygen -m PEM -t rsa -b 4096 生成的公钥追加到 authorized_keys 中</description></item><item><title>go 语言跨平台编译及优化二进制体积</title><link>https://aladdinding.cn/post/go-%E8%AF%AD%E8%A8%80%E8%B7%A8%E5%B9%B3%E5%8F%B0%E7%BC%96%E8%AF%91%E5%8F%8A%E4%BC%98%E5%8C%96%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%93%E7%A7%AF/</link><pubDate>Fri, 29 Oct 2021 00:00:00 +0000</pubDate><guid>https://aladdinding.cn/post/go-%E8%AF%AD%E8%A8%80%E8%B7%A8%E5%B9%B3%E5%8F%B0%E7%BC%96%E8%AF%91%E5%8F%8A%E4%BC%98%E5%8C%96%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%93%E7%A7%AF/</guid><description>编译 go build
使用：
go build [-o 输出名] [-i] [编译标记] [包名] 默认我们 go build 的可执行文件都是当前操作系统可执行的文件，如果我想在 macOS 下编译一个 linux 下可执行文件，那需要怎么做呢？
只需要指定目标操作系统的平台和处理器架构即可，例如 Window 平台终端下按如下方式指定环境变量。
SET CGO_ENABLED=0 // 禁用 CGO SET GOOS=linux // 目标平台是 linux SET GOARCH=amd64 // 目标处理器架构是 amd64 macOS 编译 Linux 和 Windows 平台 64 位 可执行程序:
CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build CGO_ENABLED=0 GOOS=windows GOARCH=amd64 go build Linux 编译 Mac 和 Windows 平台 64 位可执行程序：
CGO_ENABLED=0 GOOS=darwin GOARCH=amd64 go build CGO_ENABLED=0 GOOS=windows GOARCH=amd64 go build Windows 编译 Mac 平台 64 位可执行程序</description></item><item><title>炖排骨汤的技巧</title><link>https://aladdinding.cn/post/%E7%82%96%E6%8E%92%E9%AA%A8%E6%B1%A4%E7%9A%84%E6%8A%80%E5%B7%A7/</link><pubDate>Mon, 13 Sep 2021 00:00:00 +0000</pubDate><guid>https://aladdinding.cn/post/%E7%82%96%E6%8E%92%E9%AA%A8%E6%B1%A4%E7%9A%84%E6%8A%80%E5%B7%A7/</guid><description>处理排骨 排骨冷水下锅，放入生姜、葱段、料酒去腥 水开后撇去浮沫 倒出排骨，冷水冲洗，沥干水分 煎制排骨 热锅凉油放入生姜葱段爆香 倒入沥干水分的排骨煎制两面金黄 淋入料酒去腥 倒入开水淹没过排骨 砂锅炖汤 水沸后转入砂锅 加入姜片、花椒、葱结、料酒去腥 大火炖煮至沸腾 加入配菜，如：玉米、山药、胡萝卜等 转小火继续炖煮 1 小时左右（切记不要炖久了，肉会烂成肉渣） 中途不要放盐，吃的时候在放盐</description></item><item><title>学习《深入理解计算机系统》</title><link>https://aladdinding.cn/post/%E5%AD%A6%E4%B9%A0%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/</link><pubDate>Sat, 21 Aug 2021 00:00:00 +0000</pubDate><guid>https://aladdinding.cn/post/%E5%AD%A6%E4%B9%A0%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/</guid><description>本书主要介绍了计算机系统的基本概念, 包括最底层的内存中的数据表示、流水线指令的构成、虚拟存储器、编译系统、动态加载库以及用户应用等。书中提供了大量实际操作, 可以帮助读者更好地理解程序执行的方式, 改进程序的执行效率。
一本相见恨晚的书，非计科出身果然还是有很长的路要走。
首次阅读确实不是很懂，可以暂时放一放
当有了实际编码经验、抽象思维逻辑再阅读，你会有所收获的！
教材 我用阿里云盘分享了「深入理解计算机系统（第三版）.pdf」，你可以不限速下载🚀 复制这段内容打开「阿里云盘」App 即可获取 链接：https://www.aliyundrive.com/s/bTBiCehPPJv 视频
#biliplayer {
width: 100%;
height: 550px;
}
@media only screen and (min-device-width: 320px) and (max-device-width: 480px) {
#biliplayer {
width: 100%;
height: 250px;
}
}
其他 https://github.com/EugeneLiu/translationCSAPP
https://www.zhihu.com/question/20354069</description></item><item><title>MacOS 使用小方法总结</title><link>https://aladdinding.cn/post/macos-%E4%BD%BF%E7%94%A8%E5%B0%8F%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/</link><pubDate>Fri, 30 Jul 2021 00:00:00 +0000</pubDate><guid>https://aladdinding.cn/post/macos-%E4%BD%BF%E7%94%A8%E5%B0%8F%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/</guid><description>忽略 macOS Catalina 10.15 更新通知 隐藏 / 关闭更新通知依次打开 启动台 - 其他 - 终端，输入以下神秘代码，Enter 后输入用户密码即可。
sudo softwareupdate --ignore &amp;#34;macOS Catalina&amp;#34; 将来要是想开了，又想更新了，再次输入以下神秘代码即可。
sudo softwareupdate --reset-ignored Tip：此方法在 macOS 10.16 Big Sur 已经不适用，暂时没有找到合适的方法
屏蔽升级 Catalina 软件更新小红点 如果在此之前已经点击了软件更新出现了小红点，对于强迫症用户十分不友好。
打开 启动台 - 其他 - 终端 - 输入
defaults write com.apple.systempreferences AttentionPrefBundleIDs 0 然后继续输入
killall Dock 烦人的小红点就消失了！！！
外接显示器 Dock 栏会乱跑 鼠标在上方屏幕红框处，也就是鼠标移不下去的地方放置一两秒，Dock 栏就会跑到上方屏幕
同理，鼠标放下下方屏幕，鼠标移不下去的地方放置，Dock 栏就会跑到下方屏幕
个人感觉这个设计很烂，而且也没有开关能永久固定 Dock 栏，希望 Appple 设计师能改改！！！
也可以在设置 -&amp;gt; 调度中心取消勾选「显示器具有单独的空间」
按住 Command 连续选中文件 Command 键是 macOS 上最基础的文件选择辅助按键之一。按住 Command 后再选文件，只要保持 Command 键一直按着，已经选中的文件就会一直保持被选中的状态。 相关的快捷键有：Command+A 全选所有文件</description></item><item><title>Docker 部署并破解 Confluence、JIRA 及插件</title><link>https://aladdinding.cn/post/docker-%E9%83%A8%E7%BD%B2%E5%B9%B6%E7%A0%B4%E8%A7%A3-confluencejira-%E5%8F%8A%E6%8F%92%E4%BB%B6/</link><pubDate>Sun, 25 Jul 2021 00:00:00 +0000</pubDate><guid>https://aladdinding.cn/post/docker-%E9%83%A8%E7%BD%B2%E5%B9%B6%E7%A0%B4%E8%A7%A3-confluencejira-%E5%8F%8A%E6%8F%92%E4%BB%B6/</guid><description>Confluence Confluence 是一个专业的企业知识管理与协同软件，也可以用于构建企业 wiki。使用简单，但它强大的编辑和站点管理特征能够帮助团队成员之间共享信息、文档协作、集体讨论，信息推送
数据库设置 不建议将数据库部署在 Docker 容器，推荐使用云数据库或者物理机数据库。
文档 Confluence Data Center and Server documentation
Database Configuration
数据库设置 选择安装的 Confluence 版本，阅读 Database Setup For MySQL 后，修改Mysql 配置文件，本文以 Mysql 8.0 为例
[mysqld] ... character-set-server=utf8mb4 collation-server=utf8mb4_bin default-storage-engine=INNODB max_allowed_packet=256M innodb_log_file_size=2GB transaction-isolation=READ-COMMITTED binlog_format=row log-bin-trust-function-creators = 1 // 如果为 Mysql5.7，关闭 derived_merge 能优化仪表板加载缓慢 optimizer_switch = derived_merge=off ... 如果 sql_mode = NO_AUTO_VALUE_ON_ZERO，请删除此选项
创建数据库 &amp;amp; 用户 创建数据库 CREATEDATABASE&amp;lt;database-name&amp;gt;CHARACTERSETutf8mb4COLLATEutf8mb4_bin; 创建用户 CREATEuser&amp;#39;&amp;lt;confluenceuser&amp;gt;&amp;#39;@&amp;#39;localhost&amp;#39;IDENTIFIEDBY&amp;#39;&amp;lt;password&amp;gt;&amp;#39;;如果 Confluence 与数据库不在同一台服务器上运行（或者是 Docker 用户），请用 Confluence 服务器的主机名或 IP 地址替换 localhost（也可以使用 %，表示允许所有 host）</description></item><item><title>数据结构与算法之时间、空间复杂度</title><link>https://aladdinding.cn/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%B6%E9%97%B4%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/</link><pubDate>Sat, 24 Jul 2021 00:00:00 +0000</pubDate><guid>https://aladdinding.cn/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%B6%E9%97%B4%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/</guid><description>时间复杂度 算法的执行时间与算法输入值之间的的关系，即算法的执行效率
大 O 表示法 用常数 1 取代运行时间中的所有加法常数。 在修改后的运行次数函数中，只保留最高阶项。 如果最高阶项存在且不是 1，则去除与这个项相乘的常数。得到的结果就是大 O 阶 常见时间复杂度 O(1) 常数阶 def O1(num): i = num j = num*2 return i + j O(logn) 对数阶 def OlogN(num): i = 1 while (i &amp;lt; num): i = i * 2 return i O(n) 线性阶 def ON(num): total = 0 for i in range(num): total += i return total O(nlogn) nlogn 阶 def ONlogN(num): total = 0 for i in range(num): j = 1 while (j &amp;lt; num): total += i+j j = j * 2 return total O(n^2) 平方阶 def ON2(num): total = 0 for i in range(num): for j in range(num): total += i+j return total 对比 常用时间复杂度所耗费的时间从小到大依次是：</description></item><item><title>MacOS 终端配置记录</title><link>https://aladdinding.cn/post/macos-%E7%BB%88%E7%AB%AF%E9%85%8D%E7%BD%AE%E8%AE%B0%E5%BD%95/</link><pubDate>Fri, 04 Jun 2021 00:00:00 +0000</pubDate><guid>https://aladdinding.cn/post/macos-%E7%BB%88%E7%AB%AF%E9%85%8D%E7%BD%AE%E8%AE%B0%E5%BD%95/</guid><description>安装 iTerm2 使用 iTerm2 替代 macOS 自带终端 Terminal
Home&amp;amp;Download：https://iterm2.com/
安装 iTerm2 主题 This is a set of color schemes for iTerm (aka iTerm2).
Github：https://github.com/mbadolato/iTerm2-Color-Schemes
Example:
Dracula iterm2-material-design 安装 oh-my-zsh Oh My Zsh is a delightful, open source, community-driven framework for managing your Zsh configuration.
Home：https://ohmyz.sh/
Github：https://github.com/ohmyzsh/ohmyzsh
# Install oh-my-zsh $ sh -c &amp;#34;$(curl -fsSL https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh)&amp;#34; 安装 zplug 插件管理器 Github：https://github.com/zplug/zplug
$ curl -sL --proto-redir -all,https https://raw.githubusercontent.com/zplug/installer/master/installer.zsh | zsh 安装命令行工具 fzf 命令行模糊搜索</description></item><item><title>代理服务器如何支持 HTTPS</title><link>https://aladdinding.cn/post/%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%A6%82%E4%BD%95%E6%94%AF%E6%8C%81-https/</link><pubDate>Mon, 10 May 2021 00:00:00 +0000</pubDate><guid>https://aladdinding.cn/post/%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%A6%82%E4%BD%95%E6%94%AF%E6%8C%81-https/</guid><description>说到 HTTPS 协议，很多人想到的是配置各种复杂的证书。其实不然，可以说大多数代理能够支持 https 都是通过 http 协议中的 Web 隧道（也有叫做 HTTP 隧道）功能来实现的。
Web 隧道 Web 隧道允许用户通过 HTTP 连接发送非 HTTP 流量（例如 FTP，Telnet，SMTP），这样就可以在 HTTP 上携带其他协议数据了。使用 Web 隧道最常见的原因就是要在 HTTP 链接中嵌入非 HTTP 流量。我们知道很多软件都是实现了自己的应用层协议，但是这些软件都支持设置代理，如 QQ，微信。
Web 隧道是用 HTTP 的 CONNECT 方法建立起来的。CONNECT 方法并不是 HTTP/1.1 核心规范的一部分，但却是一种得到广泛应用的扩展。CONNECT 方法请求隧道网关创建一条到达任意目的服务器和端口的 TCP 连接，并对客户端和服务器之间的后继数据进行盲转发。下面截取《HTTP 权威指南》配图，讲讲 CONNECT 方法如何建立一条 Web 隧道。
客户端首先发送了一条 CONNECT 请求给代理服务器。 代理服务器收到了 CONNECT 请求，解析出报文中客户端希望访问的域名及端口号，然后向目标服务器进行 TCP 连接。（图中是到打开到主机 orders.joes-hardware.com 的标准 SSL 端口 443 的连接） 代理服务器一旦和目标网站建立了 TCP 连接，就发送一条 HTTP 200 Connection Established 的响应来通知客户端 Web 隧道建立成功，可以发送数据了。 此时客户端通过 Web 隧道发送的所有数据都会被代理服务器直接转发给目标网站。（如果是 HTTPS 协议则是各种 SSL 握手信息，加密后的 HTTP 报文） 客户端只有收到 200 Connection Established 才会继续发送数据。如果代理服务器和目标网站连接不成功怎么办呢？代理服务器可以自己灵活自定义：连接目标网站失败 502 Bad Gateway、代理认证未通过 407 Proxy Authentication Required 等等。</description></item><item><title>MacOS 相关资源合集</title><link>https://aladdinding.cn/post/macos-%E7%9B%B8%E5%85%B3%E8%B5%84%E6%BA%90%E5%90%88%E9%9B%86/</link><pubDate>Sat, 20 Mar 2021 00:00:00 +0000</pubDate><guid>https://aladdinding.cn/post/macos-%E7%9B%B8%E5%85%B3%E8%B5%84%E6%BA%90%E5%90%88%E9%9B%86/</guid><description> Now we have become very big, Different from the original idea. Collect premium software in various categories.
awesome-mac
官方 macOS 最新系统：https://www.apple.com.cn/macos
macOS 支持：https://support.apple.com/zh-cn/macos
制作 macOS 安装器：https://support.apple.com/zh-cn/HT201372
macOS 使用手册：https://support.apple.com/zh-cn/guide/mac-help/welcome/mac
序列号查询：https://checkcoverage.apple.com/cn/zh/
软件下载 MacWk：https://macwk.com/
马可菠萝：https://www.macbl.com/
瓜子云盘：https://yun.naodai.org/Software
appstorrent：https://www.appstorrent.ru/
Xclient：https://xclient.info/
麦氪搜：https://www.imacso.com/
Github：https://github.com/search?q=macos
兼容检测 Arm 芯片兼容：https://isapplesiliconready.com/zh</description></item><item><title>浅谈 vpn、proxy、shadowsocks、机场之间的联系和区别</title><link>https://aladdinding.cn/post/%E6%B5%85%E8%B0%88-vpnproxyshadowsocks%E6%9C%BA%E5%9C%BA%E4%B9%8B%E9%97%B4%E7%9A%84%E8%81%94%E7%B3%BB%E5%92%8C%E5%8C%BA%E5%88%AB/</link><pubDate>Sat, 20 Mar 2021 00:00:00 +0000</pubDate><guid>https://aladdinding.cn/post/%E6%B5%85%E8%B0%88-vpnproxyshadowsocks%E6%9C%BA%E5%9C%BA%E4%B9%8B%E9%97%B4%E7%9A%84%E8%81%94%E7%B3%BB%E5%92%8C%E5%8C%BA%E5%88%AB/</guid><description>墙的原理 在讨论 vpn、proxy 这些之前，有必要先提一下目前主流防火墙的实现原理。GFW 实现网络封锁的手段主要有两种：dns 劫持和 ip 封锁（除此之外，还有 dns 污染和关键词过滤，这里我们不讨论）。
Dns 劫持 ip 是网络上各主机的 “地址”，要想访问 “别人家”，当然得要有地址。但 ip 是一串数字，是给电脑看的，人记起来太麻烦，所以就有了域名（也就是我们常说的网址）和 dns（网域名称系统，Domain Name System）。
域名是一串英文字符串，方便人记忆。dns 将域名和 ip 关联起来，形成映射。用户访问域名所在的目标网站前，将域名发给 dns 服务器询问这对映射关系，拿到对应的 ip 后就可以在茫茫网海中找到那个 “她” 了。而 GFW 所做的就是站在用户和 dns 服务器之间，破坏它们的正常通讯，并向用户回传一个假 ip。用户拿不到真正的 ip，自然也就访问不到本想访问的网站了。
Dns 劫持是 GFW 早期唯一的技术手段，所以那个时候的用户通过修改 Hosts 文件的方式就可以零成本突破封锁了。
IP 封锁 dns 劫持之后，GFW 引入了 ip 封锁，直接锁住了访问目标网站的去路，用户发往被封锁 ip 的任何数据都会被墙截断。
这个时候，依靠类似于修改 Hosts 文件这种低成本方法突破封锁就显得有些天方夜谭了。那么，解决办法是什么呢？答案是：在第三方架设翻墙服务器，中转与目标服务器间的来往流量。目前为止，GFW 采用的是黑名单模式，像 Google、Facebook 这种在黑名单上的网站的 ip 无法访问，而不在黑名单上的第三方不记名 ip 可以。
于是，一切就很明朗了，我们目前几乎所有的翻墙手段都是基于上述原理实现的。vpn 是，shadowsocks 是，还有一些比较冷门的（比如 v2ray）同样如此，只不过它们的技术细节不同（这个我们不会深入）。
VPN VPN，全称 “虚拟私人网络（Virtual Private Network）” 或者是“虚拟专用网络”，是一种加密通讯技术。vpn 是一个统称，它有很多的具体实现，比如 PPTP、L2TP/IPSec 等。</description></item><item><title>Linux 命令行快捷键</title><link>https://aladdinding.cn/post/linux-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%BF%AB%E6%8D%B7%E9%94%AE/</link><pubDate>Fri, 21 Aug 2020 00:00:00 +0000</pubDate><guid>https://aladdinding.cn/post/linux-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%BF%AB%E6%8D%B7%E9%94%AE/</guid><description>终端快捷键 快捷键应该是每一个需要和终端天天打交道的程序员必备的技能了，如果你还停留在每次前后左右一个字符一个字符移动光标的话，那你需要好好学习下面的终端快捷键，这可以大大提高你的效率
最常用 tab 命令或路径的补全键 移动光标 Ctrl + a/Home 切换到命令行开始 Ctrl + e/End 切换到命令行末尾 Ctrl + f 光标向右移动一个字符（相当于方向键右键） Ctrl + b 光标向右移动一个字符（相当于方向键左键） 剪切、粘贴、清除 Ctrl + l 清除屏幕内容，效果等同于 clear 命令 Ctrl + u 清除剪切光标之前的内容 Ctrl + k 剪切清除光标之后的内容 Ctrl + y 粘贴刚才所删除的字符 Ctrl + w 剪切光标所在处之前的一个词（以空格、标点等为分隔符） Ctrl + h 删除光标所在处的前一个字符（相当于退格键） Ctrl + t 颠倒光标所在处及其之前的字符位置，并将光标移动到下一个字符 Alt + t 交换当前与以前单词的位置 Alt + d 剪切光标之后的词 控制快捷键 Ctrl + c 终止命令 Ctrl + s 锁住终端 Ctrl + q 解锁终端 Ctrl + z 转入后台运行, 但在当前用户退出后就会终止 Ctrl + d 退出 shell，logout Ctrl +（x u） 按住 Ctrl 的同时再先后按 x 和 u，撤销刚才的操作 重复执行命令、查找历史命令 Ctrl + o 重复执行命令 Ctrl + r 在历史命令中查找 （这个非常好用，输入关键字就调出以前的命令了） history 显示你所有执行过的编号 + 历史命令。这个可以配合 !</description></item><item><title>Linux系统目录结构备忘</title><link>https://aladdinding.cn/post/linux%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84%E5%A4%87%E5%BF%98/</link><pubDate>Tue, 11 Aug 2020 00:00:00 +0000</pubDate><guid>https://aladdinding.cn/post/linux%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84%E5%A4%87%E5%BF%98/</guid><description>Linux将整个文件系统看做一棵树，这棵树的树根叫做根文件系统，用/表示。
目录 全称 备注 /bin binaries 存放着只曾哥系统必须的二进制或可执行文件 /sbin system binaries 存放只能由root用户运行的系统二进制文件 /lib library 二进制文件的公共库 /usr unix system resources 与根目录结构类似，存放不是操作系统必须的二进制文件或应用程序，面向最终用户，centos7中/bin-&amp;gt;/usr/bin, /sbin-&amp;gt;/usr/sbin /etc editable text config 存放配置文件 /home 存放不同用户的文件、配置和软件 /boot 系统启动所需文件，如linux内核 /dev device 包含设备文件，可以像管理普通文件一样管理硬件或者驱动程序 /opt optional 包含软件或者软件包 /var variable 存放操作系统运行过程中发生变化的文件，如系统日志或缓存文件 /tmp temporary 存放临时文件，系统会定期或目录大小到达一定上线后自动清理 /proc processes 正在运行的内核信息映射，主要包括进程信息、内存资源信息、磁盘分区信息等。（虚拟文件系统，不占内存） /lost+found Lost+Found 这个目录在大多数情况下都是空的。但是如果你正在工作突然停电，或是没有用正常方式关机，在你重新启动机器的时候，这里就存放了一些文件。 /srv service 存放一些对外的服务数据（不是软件，而是数据），如web、ftp、流媒体等 /media linux 系统会自动识别一些设备，例如U盘、光驱等等，当识别后，Linux 会把识别的设备挂载到这个目录下。 /mnt 系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将光驱挂载在 /mnt/ 上，然后进入该目录就可以查看光驱里的内容</description></item><item><title>作为技术人员为什么要写博客</title><link>https://aladdinding.cn/post/%E4%BD%9C%E4%B8%BA%E6%8A%80%E6%9C%AF%E4%BA%BA%E5%91%98%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%86%99%E5%8D%9A%E5%AE%A2/</link><pubDate>Sun, 09 Aug 2020 00:00:00 +0000</pubDate><guid>https://aladdinding.cn/post/%E4%BD%9C%E4%B8%BA%E6%8A%80%E6%9C%AF%E4%BA%BA%E5%91%98%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%86%99%E5%8D%9A%E5%AE%A2/</guid><description>本文只代表个人见解，不代表任立场，如果您认为我的想法是错的那很正常，因为这是我的想法，如果您觉得您的想法和我一样，那我们就是传说中的 &amp;ldquo;激友&amp;rdquo;（对生活冲满激情的朋友）。进入正题。
一、我心中的博客 我所以指的写博客，不单只是写一篇文章出来这一结果。而应该是写的这一过程，写过技术文章的朋友应该跟我一样有这么一个过程。
自己了解学习，文章所涉及到的知识点，及知识点衍生出来的知识点。
对学习的知识点进行验证，以确保理论值与实践值保持一致。
构思文章的大纲，哪些部分需要重点写，需要配合实例代码，图片等信息。
动手写，写完后再次检查校正并排版，然后发表。
针对网友的评论中提出的问题进行回复
我写文章一般都会经历以上 5 上步，最终以上 5 步融合成一个结果那就是 &amp;ldquo;一篇文章&amp;rdquo; 这一过程也是我心中对的 &amp;ldquo;写博客&amp;rdquo; 一词的诠释
二、为什么要写博客 为自己 写博客对自己的提升是很大的，可能写一篇体现不出来，但是只要你坚持写效果就很明显，好处人个认为有以下几点
强化知识点 在写一篇文章前，你必定是要把以文章中心为主的知识点及衍生的知识点都详细了解一篇，在这一过程中必须会涉及到自己以前所了解过的知识。
人的记忆是存在记忆曲线的需要不断的重复记忆才能长久的记住某一事物，而每写一篇文章时都会查阅资料，在这一过程中必然会遇到以前记住了而现在渐渐淡忘的知识点。
当你再次看到时瞬间就会回想起，此时以前的知识点就得到了强化。
提升学习能力 同一样的人，了解同一知识点，用不同的方法，产生的结果必然会不一样。
找到最佳的学习方法，这也是一种能力，这种能力是经过多次实践探索之后总结出来的。
以前我每次需了解某一种技术时都会先百度看各种搜索结果，发现没有想要的之后，再 Google 因为 Google 的结果与百度的会有所不同，Google 结果中国外的文章相对会多一点。
而偶然点了一个链接进入了博客园，发现就是自己想要的东西，而且把概念，代码，及经验都写上去了，看完之后对我帮助很大。
渐渐的我便开始采这种方法了解新知识概念性的直接看百度百科，实质性的直接 上博客园的 找找看 。
群里的朋友还推荐了一种方法，比如我要学 MVC 园子里很多人都写了 关于 MVC 的一系列文章，把那一系列的文章都看一遍，对于 MVC 就基本有了了解了，这便是学习能力的提升, 对于某种技术用最短的时间做到了比较全面的了解。
提升文字组织能力 这个就不用说了，写博客，既然是写，就必然会有大量的文字，而如何组织文字表达出自己想表达的意思，是长期练习的，而写博客正好帮助你提高了你的文字组织能力。
提升逻辑思维能力 不用说，技术性的东西从来就没的单独存在的，都一层层技术相结合，那在了解某种技术时，自己的思维也是要顺着这种关系逐渐深入的。
比如 MVC，你不能只知道 M 是什么 V 是什么 C 是什么就行了吧，你得知道 M V C 这三者关系是怎样的，又是怎样交互，而你了解之后再把它写出来时，需要清晰逻辑。</description></item><item><title>SOCKS 协议交互流程记录</title><link>https://aladdinding.cn/post/socks-%E5%8D%8F%E8%AE%AE%E4%BA%A4%E4%BA%92%E6%B5%81%E7%A8%8B%E8%AE%B0%E5%BD%95/</link><pubDate>Sun, 19 Jul 2020 00:00:00 +0000</pubDate><guid>https://aladdinding.cn/post/socks-%E5%8D%8F%E8%AE%AE%E4%BA%A4%E4%BA%92%E6%B5%81%E7%A8%8B%E8%AE%B0%E5%BD%95/</guid><description>SOCKS 是一种网络传输协议，主要用于客户端与外网服务器之间通讯的中间传递。SOCKS 是 &amp;ldquo;Socket Secure&amp;rdquo; 的缩写。当防火墙后的客户端要访问外部的服务器时，就跟 SOCKS 代理服务器连接。这个代理服务器控制客户端访问外网的资格，允许的话，就将客户端的请求发往外部的服务器。这个协议最初由 David Koblas 开发，而后由 NEC 的 Ying-Da Lee 将其扩展到 SOCKS4。最新协议是 SOCKS5，与前一版本相比，增加支持 UDP（用户数据报协议）、验证，以及 IPv6。根据 OSI 模型，SOCKS 是 会话层 的协议，位于 表示层 与 传输层 之间。SOCKS 协议不提供 加密。
SOCKS5 SOCKS 协议版本认证 创建与 SOCKS5 服务器的 TCP 连接后客户端需要先发送请求来确认协议版本及认证方式（以字节为单位）
client send # +----+----------+----------+ # |VER | NMETHODS | METHODS | # +----+----------+----------+ # | 1 | 1 | 1 to 255 | # +----+----------+----------+ VER：SOCKS5 协议版本 0x05 NMETHODS：METHODS 所占字节长度 METHODS：客户端支持的认证方式列表，每个方法占 1 字节 0x00 不需要认证 0x01 GSSAPI 0x02 用户名、密码认证 0x03 to 0x7F 由 IANA 分配（保留） 0x80 to 0xFE 私人方法保留 0xFF 无可接受的方法 服务器从客户端提供的 METHODS 中选择一个并通过以下消息通知客户端</description></item><item><title>黑苹果一键开启 HiDPI</title><link>https://aladdinding.cn/post/%E9%BB%91%E8%8B%B9%E6%9E%9C%E4%B8%80%E9%94%AE%E5%BC%80%E5%90%AF-hidpi/</link><pubDate>Sat, 11 Jul 2020 00:00:00 +0000</pubDate><guid>https://aladdinding.cn/post/%E9%BB%91%E8%8B%B9%E6%9E%9C%E4%B8%80%E9%94%AE%E5%BC%80%E5%90%AF-hidpi/</guid><description>黑苹果和白苹果最大的区别其实在显示效果上。同样一个网页，白苹果的显示就会细腻很多，而黑苹果颗粒感非常严重，造成上述原因是因为大多数苹果设备的屏幕本身的分辨率很高，如果你的显示器分辨率达到视网膜级别的话，哪怕是黑苹果也是默认开启 HiDPI 的。So 本人的 2k 分辨率显示器就很尴尬了，下面记录一下开启 HiDPI 的过程。
HiDPI 的概念 有关 retina 和 HiDPI 那点事
总之 HiDPI 是苹果一个牛逼的显示技术，通过牺牲一定的分辨率实现更细腻的显示效果，这就是为什么 2K 显示器开启 HiDPI 的效果要比 1080P 好的原因了。
黑苹果开启原生 HiDPI 终端中运行如下命令
sh -c &amp;#34;$(curl -fsSL https://raw.githubusercontent.com/xzhih/one-key-hidpi/master/hidpi.sh)&amp;#34; 如果出现 curl: (7) Failed to connect to raw.githubusercontent.com port 443:xxx，应该是被墙了，可以挂上梯子
export https_proxy=http://127.0.0.1:7890 http_proxy=http://127.0.0.1:7890 all_proxy=socks5://127.0.0.1:7890 终端运行后选择相应分辨率重启即可生效！
HiDPI 开启效果 可以看到 HiDPI 开启后，「显示器选项」里面的缩放显示如图所示。可随意选择缩放模式而且不会高糊，在显示上明显感觉图标颗粒感更小了，显示更加细腻了。</description></item><item><title>ApacheBench HTTP 服务器基准测试工具使用总结</title><link>https://aladdinding.cn/post/apachebench-http-%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/</link><pubDate>Tue, 26 May 2020 00:00:00 +0000</pubDate><guid>https://aladdinding.cn/post/apachebench-http-%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/</guid><description>ApacheBench（ab）是用于对 Apache 超文本传输协议（HTTP）服务器进行基准测试的工具。ab 命令会创建很多的并发访问线程，模拟多个访问者同时对某一 URL 地址进行访问。它的测试目标是基于 URL 的，因此，既可以用来测试 Apache 的负载压力，也可以测试 nginx、lighthttp、tomcat、IIS 等其它 Web 服务器的压力。ab 命令对发出负载的计算机要求很低，既不会占用很高 CPU，也不会占用很多内存，但却会给目标服务器造成巨大的负载，其原理类似 CC 攻击。自己测试使用也须注意，否则一次上太多的负载，可能造成目标服务器因资源耗完，严重时甚至导致死机。
ApacheBench 安装 macOS Mac 下自带 apache，查看版本：
apachectl -v 查看 ab 版本:
ab -V Window Windows 系统 Apache：下载链接
Linux Ubuntu
apt-get install apache2-utils CentOS
yum -y install httpd-tools ApacheBench 使用 Options ab 压力测试工具的用法，查看：
ab -h # 或者 man ab Usage: ab [options] [http[s]://]hostname[:port]/path Options are: -n requests Number of requests to perform # 在测试会话中所执行的请求个数（本次测试总共要访问页面的次数）。默认时，仅执行一个请求。 -c concurrency Number of multiple requests to make at a time # 一次产生的请求个数（并发数）。默认是一次一个。 -t timelimit Seconds to max.</description></item><item><title>The Zen of Python</title><link>https://aladdinding.cn/post/the-zen-of-python/</link><pubDate>Thu, 16 Jan 2020 00:00:00 +0000</pubDate><guid>https://aladdinding.cn/post/the-zen-of-python/</guid><description>原文 Beautiful is better than ugly. Explicit is better than implicit. Simple is better than complex. Complex is better than complicated. Flat is better than nested. Sparse is better than dense. Readability counts. Special cases aren&amp;rsquo;t special enough to break the rules. Although practicality beats purity. Errors should never pass silently. Unless explicitly silenced. In the face of ambiguity, refuse the temptation to guess. There should be one&amp;ndash; and preferably only one &amp;ndash;obvious way to do it.</description></item><item><title>MacOS 软件包的管理器 Homebrew</title><link>https://aladdinding.cn/post/macos-%E8%BD%AF%E4%BB%B6%E5%8C%85%E7%9A%84%E7%AE%A1%E7%90%86%E5%99%A8-homebrew/</link><pubDate>Sun, 05 Jan 2020 00:00:00 +0000</pubDate><guid>https://aladdinding.cn/post/macos-%E8%BD%AF%E4%BB%B6%E5%8C%85%E7%9A%84%E7%AE%A1%E7%90%86%E5%99%A8-homebrew/</guid><description>Homebrew 简介 Homebrew 是一款 MacOS 平台下的软件包管理工具，拥有安装、卸载、更新、查看、搜索等很多实用的功能。简单的一条指令，就可以实现包管理，而不用你关心各种依赖和文件路径的情况，十分方便快捷。
Homebrew 的几个核心概念 在正式介绍 Homebrew 的使用之前，我先为你介绍一下 Homebrew 中的一些核心的概念，了解这些概念，就可以帮助你更好的去使用 Homebrew。
词汇 含义 formula (e) 安装包的描述文件，formulae 为复数 cellar 安装好后所在的目录 keg 具体某个包所在的目录，keg 是 cellar 的子目录 bottle 预先编译好的包，不需要现场下载编译源码，速度会快很多；官方库中的包大多都是通过 bottle 方式安装 tap 下载源，可以类比于 Linux 下的包管理器 repository cask 安装 macOS native 应用的扩展，你也可以理解为有图形化界面的应用。 bundle 描述 Homebrew 依赖的扩展 Homebrew 安装 将以下命令粘贴至终端，回车运行</description></item><item><title>日语五十音笨拙记忆</title><link>https://aladdinding.cn/post/%E6%97%A5%E8%AF%AD%E4%BA%94%E5%8D%81%E9%9F%B3%E7%AC%A8%E6%8B%99%E8%AE%B0%E5%BF%86/</link><pubDate>Sun, 05 Jan 2020 00:00:00 +0000</pubDate><guid>https://aladdinding.cn/post/%E6%97%A5%E8%AF%AD%E4%BA%94%E5%8D%81%E9%9F%B3%E7%AC%A8%E6%8B%99%E8%AE%B0%E5%BF%86/</guid><description>这几天整理了大学期间的书籍，发现了当时选修日语课时自己总结打印出来的的日语五十音巧记，现在看到还有点好笑，不过当时确实帮助自己应付过了期末考试。直到现在两年过去了，自己还是可以背出日语五十音前面几十个，这里就记录一下吧，万一以后有用呢。。。
あ行 清音 あア &amp;ldquo;女&amp;rdquo; 孩子胖 &amp;ldquo;了&amp;rdquo; 一圈, 惨叫了一声 &amp;ldquo;啊 (a)&amp;rdquo; いイ 平假名い和片假名イ拼在一起就会组成一个汉字 &amp;ldquo;以 (i)&amp;quot;，读音也是以 うウ 平假名う很像字母 W 横过来,&amp;ldquo;屋 (u)&amp;rdquo;, 片假名ウ像“家” 字的宝盖头, 有家有房 &amp;ldquo;屋&amp;rdquo; えエ &amp;ldquo;元&amp;rdquo; 朝的 &amp;ldquo;工&amp;rdquo; 人很悲 &amp;ldquo;哀 (e)&amp;rdquo; おオ 有学 “术” 的“才”子都很 &amp;ldquo;傲(o)&amp;rdquo; 气 か行 清音 浊音 かカ 因为被 &amp;ldquo;卡 (ka)&amp;rdquo; 住了，所以要多用 &amp;ldquo;一点&amp;rdquo;&amp;rdquo; 力 &amp;quot; ga( が ガ) きキ 长得像琵琶, 琵琶调音 key(ki) gi( ぎ ギ) くク 小时候 &amp;ldquo;小于&amp;rdquo; 别人, 长大后终于 &amp;ldquo;大于&amp;rdquo; 别人, 感动的要 “哭(ku)” 了 gu( ぐ グ) けケ &amp;ldquo;开 (ke)&amp;rdquo; 了一 &amp;ldquo;个&amp;rdquo; 豆 &amp;ldquo;汁&amp;rdquo; 店 ge( げ ゲ) こコ &amp;ldquo;扣 (ko)&amp;rdquo; 了“两条鱼” 放在鱼篓里 go( ご ゴ) さ行 清音 浊音 さサ 一个人弯着腿跪在 &amp;ldquo;艹&amp;rdquo; 上面, 是不是很 &amp;ldquo;傻 (sa)&amp;rdquo; za( ざ ザ) しシ 用 “吸管” 喝水,&amp;ldquo;吸(shi)&amp;rdquo; 出来“三点水 ji( じ ジ) すス 一个人上吊 &amp;ldquo;又&amp;rdquo;&amp;quot; 苏 (su)&amp;quot; 醒了 zu( ず ズ) せセ 世界被 &amp;ldquo;塞 (se)&amp;rdquo; 得满满的 ze( ぜ ゼ) そソ 一位艺人比起了 V 字 &amp;ldquo;手 (so)&amp;rdquo; zo( ぞ ゾ) た行 清音 浊音 たタ &amp;ldquo;他 (ta)&amp;rdquo; 在半夜 &amp;ldquo;十二&amp;rdquo; 点的 &amp;ldquo;夕&amp;rdquo; 阳下 da( だ ダ) ちチ &amp;ldquo;吃 (chi)&amp;ldquo;5 千个包子 ji( ぢ ヂ) つツ 好 &amp;ldquo;粗 (tsu)&amp;rdquo; 的一根绳子打了三个结 zu( づ ヅ) てテ 路人 &amp;ldquo;乙&amp;rdquo; 撞到了 &amp;ldquo;行&amp;rdquo; 人老 &amp;ldquo;太太 (te)&amp;rdquo; de( で デ) とト &amp;ldquo;丫&amp;rdquo; 头 &amp;ldquo;拖 (to)&amp;rdquo; 着一个萝 &amp;ldquo;卜&amp;rdquo; do( ど ド) な行 清音 なナ 把 &amp;ldquo;十三&amp;rdquo; 算成了 &amp;ldquo;十&amp;rdquo; 也太木 &amp;ldquo;讷 (na)&amp;rdquo; 了 にニ &amp;ldquo;你 (ni)&amp;rdquo; 是 &amp;ldquo;仁&amp;rdquo; 者 &amp;ldquo;二&amp;rdquo; 心 ぬヌ &amp;ldquo;奴 (nu)&amp;rdquo; 隶制度 &amp;ldquo;又&amp;rdquo; 出现了 ねネ 有了 &amp;ldquo;权&amp;rdquo; 利的奶 (n) 奶是 &amp;ldquo;福&amp;rdquo; 气 のノ &amp;ldquo;NO(no)&amp;ldquo;&amp;ldquo;0&amp;quot;和&amp;quot;1&amp;rdquo; は行 清音 浊音 半浊音 はハ &amp;ldquo;哈 (ha)&amp;rdquo; 八巴狗打 &amp;ldquo;仗&amp;rdquo; ba( ば バ) pa( ぱ パ) ひヒ &amp;ldquo;黑 (hi)&amp;rdquo; 色的 &amp;ldquo;U&amp;rdquo; 型 &amp;ldquo;匕&amp;rdquo; 首 bi( び ビ) pi( ぴ ピ) ふフ &amp;ldquo;小&amp;rdquo;&amp;rdquo; 夫 (fu)&amp;ldquo;子玩&amp;rdquo; 飞刀 &amp;quot; bu( ぶ ブ) pu( ぷ プ) へヘ 太 &amp;ldquo;嗨 (he)&amp;rdquo; 了两个眼睛都笑弯了 be( べ ベ) pe( ぺ ペ) ほホ 对着 &amp;ldquo;木&amp;rdquo; 头 &amp;ldquo;&amp;lsquo;吼 (ho)&amp;rdquo; 了 &amp;ldquo;一天&amp;rdquo; bo( ぼ ボ) po( ぽ ポ) ま行 清音 まマ &amp;ldquo;天&amp;rdquo; 天玩 &amp;ldquo;飞刀&amp;rdquo;” 吗 (ma)&amp;rdquo; みミ &amp;ldquo;三&amp;rdquo; 个 &amp;ldquo;H&amp;rdquo;&amp;rdquo; 眯 (mi)&amp;rdquo; 着眼 むム &amp;ldquo;跪在&amp;rdquo; 木 (mu)&amp;ldquo;头上上吊&amp;rdquo; 么 &amp;quot; めメ 一个 &amp;ldquo;女&amp;rdquo; 的被 × 后被 “灭 (me)&amp;quot; 了 もモ &amp;ldquo;七&amp;rdquo; 个 &amp;ldquo;毛&amp;rdquo; 子有阴 &amp;ldquo;谋 (mo)&amp;rdquo; や行 清音 やヤ 两个 &amp;ldquo;牙 (ya)&amp;rdquo;&amp;quot; 也 &amp;quot; 坏了 ゆユ &amp;ldquo;有 (yu)&amp;rdquo;&amp;quot; 一串糖葫芦 &amp;ldquo;用&amp;rdquo; 长篓子 &amp;quot; 装起来 よヨ &amp;ldquo;哟 (yo)&amp;rdquo; &amp;ldquo;支&amp;rdquo; 付宝 &amp;ldquo;扫&amp;rdquo; 码 ら行 清音 らラ &amp;ldquo;今&amp;rdquo; 天 &amp;ldquo;5&amp;rdquo; 个人 &amp;ldquo;拉 (ra)&amp;rdquo; 肚子 りリ 两个像 &amp;ldquo;立 (ri)&amp;rdquo; 刀旁 &amp;ldquo;刂&amp;rdquo; るル &amp;ldquo;路 (ru)&amp;rdquo; 上遇到 &amp;ldquo;儿&amp;rdquo; 子 &amp;ldquo;歹&amp;rdquo; 徒 れレ 有 &amp;ldquo;机&amp;rdquo; 会 &amp;ldquo;来 (re)&amp;rdquo; 要 &amp;ldquo;勾&amp;rdquo; 住 ろロ &amp;ldquo;3&amp;rdquo; 万人 &amp;ldquo;口&amp;rdquo; 好 &amp;ldquo;low(ro)&amp;rdquo; わ行 清音 わワ &amp;ldquo;水箱的底儿没了&amp;rdquo;, 水 &amp;ldquo;哇 (wa)&amp;rdquo; 的全漏光了 をヲ 龙 &amp;ldquo;哦 (o)&amp;rdquo; 拨音 清音 んン &amp;ldquo;摁 (n)'&amp;rdquo; 两下 &amp;ldquo;&amp;ldquo;铃铛&amp;rdquo;</description></item><item><title>SSH 相关的快速配置</title><link>https://aladdinding.cn/post/ssh-%E7%9B%B8%E5%85%B3%E7%9A%84%E5%BF%AB%E9%80%9F%E9%85%8D%E7%BD%AE/</link><pubDate>Wed, 09 Oct 2019 00:00:00 +0000</pubDate><guid>https://aladdinding.cn/post/ssh-%E7%9B%B8%E5%85%B3%E7%9A%84%E5%BF%AB%E9%80%9F%E9%85%8D%E7%BD%AE/</guid><description>SSH 简介 SSH 为 Secure Shell 的缩写，由 IETF 的网络小组（Network Working Group）所制定；SSH 为建立在应用层基础上的安全协议。SSH 是目前较可靠，专为远程登录会话和其他网络服务提供安全性的协议。利用 SSH 协议可以有效防止远程管理过程中的信息泄露问题。SSH 最初是 UNIX 系统上的一个程序，后来又迅速扩展到其他操作平台。SSH 在正确使用时可弥补网络中的漏洞。SSH 客户端适用于多种平台。几乎所有 UNIX 平台—包括 HP-UX、Linux、AIX、Solaris、Digital UNIX、Irix，以及其他平台，都可运行 SSH。SSH 登录提供两种认证方式：口令 (密码) 认证方式和密钥认证方式。其中口令 (密码) 认证方式是我们最常用的一种，这里介绍密钥认证方式登录到 linux/unix 的方法。
SSH 服务器之间免密登陆配置 生成密钥（公钥和私钥） cd $HOME/.ssh ssh-keygen -t rsa # 全部回车默认 参数 -t rsa 表示使用 rsa 算法进行加密，执行后，会在 / home / 当前用户 /.ssh 目录下找到 id_rsa（私钥）和 id_rsa.pub（公钥）
放置公钥到目标服务器中 cat id_rsa.pub 复制 id_rsa.pub 内的公钥，登陆到目标服务器
cd $HOME/.ssh vi authorized_keys 将复制的公钥粘贴到 authorized_keys 中，authorized_keys 存放远程免密登录的公钥，主要通过这个文件记录多台机器的公钥</description></item><item><title>搞清楚字符集和字符编码</title><link>https://aladdinding.cn/post/%E6%90%9E%E6%B8%85%E6%A5%9A%E5%AD%97%E7%AC%A6%E9%9B%86%E5%92%8C%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/</link><pubDate>Wed, 02 Oct 2019 00:00:00 +0000</pubDate><guid>https://aladdinding.cn/post/%E6%90%9E%E6%B8%85%E6%A5%9A%E5%AD%97%E7%AC%A6%E9%9B%86%E5%92%8C%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/</guid><description>前言 目前主流的计算机的确都是以二进制形式存储数据的。如 00100101（其中的 0 是一个 bit，1 也是一个 bit，这 8 个 bit 就是一个 byte）。通常为了更方便表示二进制数据，也可以转换成 16 进制表示出来，0010 0101 就可以用 16 进制的 0x25 来表示（1byte=2 个 16 进制位 = 8bit=8 个二进制位）。一个字节一共可以用来表示 256 种不同的状态（每一个状态对应一个符号，就是 256 个符号，从 00000000 到 11111111）
字符集（character set）：规定了某个字符文字对应的二进制数字存放方式（编码）和某串二进制数值代表了哪个文字（解码）的转换关系。
字符编码（character encoding）：编码字符集和实际存储数值之间的转换关系，也就是字符转换成二进制数据的规则（要和对应关系区分）。
英文编码 ASCII 码 ASCII（美国信息交换标准码）是美国国家标准定制的一套基于拉丁字母的电脑编码系统，可表示数字、字母等字符符号。一个 ASCII 码在计算机中由一个字节存储，因此它最多可表示 256 个符号（一个字节为 8 位，2 的 8 次方等于 256）。实事上，标准的 ASCII 编码时只用到了低 7 位 （最高位统一为 0，或者为奇偶校验位），故 ASCII 码可表示的数据一共只有 128 个（2 的 7 次方）。这 128 个字符中，其中 95 个为可显示字符（可打印字符，比如数字、字母、标点符号），还有 33 个如比如“换行” 之类的控制字符（控制字符主要是用来操控已经处理过的文字）。最后附上了 ASCII 码表：</description></item><item><title>Tmux 的 QuickStart</title><link>https://aladdinding.cn/post/tmux-%E7%9A%84-quickstart/</link><pubDate>Fri, 09 Aug 2019 00:00:00 +0000</pubDate><guid>https://aladdinding.cn/post/tmux-%E7%9A%84-quickstart/</guid><description>Tmux 简介 Tmux 的全称是 Terminal MUtipleXer，及终端复用软件。顾名思义，它的主要功能就是用于在一个终端窗口中运行多个终端会话并且在你关闭终端窗口之后保持进程的运行。
Tmux 安装 # Ubuntu 或 Debian $ sudo apt-get install tmux # CentOS 或 Fedora $ sudo yum install tmux # Mac $ brew install tmux Tmux 概念 Tmux 中有几个重要概念：
会话（session）: 建立一个 tmux 工作区会话，会话可以长期驻留，重新连接服务器不会丢失，我们只需重新 tmux attach 到之前的工作区就可以恢复会话 窗口（window）: 容纳多个窗格 窗格（pane）: 可以在窗口中分成多个窗格 Tmux 基本操作 常用命令 tmux new　创建默认名称的会话 tmux new -s mysession　创建名为 mysession 的会话 tmux ls　显示会话列表 tmux a　连接上一个会话 tmux a -t mysession　连接指定会话 tmux rename -t s1 s2　重命名会话 s1 为 s2 tmux kill-session　关闭上次打开的会话 tmux kill-session -t s1　关闭会话 s1 tmux kill-session -a -t s1　关闭除 s1 外的所有会话 tmux kill-server　关闭所有会话 Tmux 默认的快捷键前缀是 ctrl+b，当然你也可以修改它（后文会提到） 以下所有的操作都是激活控制台之后，即键入 Ctrl+b 前提下才可以使用的命令</description></item><item><title>Vim 操作速查</title><link>https://aladdinding.cn/post/vim-%E6%93%8D%E4%BD%9C%E9%80%9F%E6%9F%A5/</link><pubDate>Fri, 09 Aug 2019 00:00:00 +0000</pubDate><guid>https://aladdinding.cn/post/vim-%E6%93%8D%E4%BD%9C%E9%80%9F%E6%9F%A5/</guid><description>进入 Vim 命令 描述 vim filename 打开或新建文件，并将光标置于第一行首 vim +n filename 打开文件，并将光标置于第 n 行首 vim + flename 打开文件, 并将光标置于最后一 - 行首 vim +/pattern filename 打开文件, 并将光标置于第一一个 与 pattern 匹配的串处 vim -r filename 在上次正用 vim 编辑时发生系统崩溃，恢复 flename vim filename&amp;hellip; filename 打开多个文件, 依次编辑 Vim 配置 命令 描述 all 列出所有选项设置情况 term 设置终端类型 ignorance 在搜索中忽略大小写 list 显示制表位 (Ctrl+I) 和行尾标志( $) number 显示行号 report 显示由面向行的命令修改过的数目 terse 显示简短的警告信息 warn 在转到别的文件时若没保存当前文件则显示 NO write 信息 nomagic 允许 vi 显示其他用户用 write 写到自己终端上的信息 nowrapscan 禁止 vi 在搜索到达文件两端时，又从另 - - 端开始 mesg 允许 vi 显示其他用户用 write 写到自己终端上的信息 :set number/ set nonumber 显示 / 不显示行号 :set ruler /set noruler 显示不显示标尺 :set hlsearch 高亮显示查找到的单词 :sset nohlsearch 关闭高亮显示 :set nu 显示行号 :set tabstop=8 设置 tab 大小，8 为最常用最普遍的设置 :set softabstop=8 4:4 个空格, 8: 正常的制表符，12: 一一个制表符 4 个空格，16: 两个 :set autoindent 自动缩进 :set cindent C 语言格式里面的自动缩进 移动光标 命令 描述 k nk 上向上移动 n 行 j nj 下向下移动 n 行 h nh 左向左移动 n 行 I nl 右向右移动 n 行 Space 光标右移一个字符 Backspace 光标左移一个字符 Enter 光标下移一行 w/W 光标右移一个字至字首 b/B 光标左移一个字至字首 e 或 E 光标右移一个字至字尾 ) 光标移至句尾 ( 光标移至句首 } 光标移至句首 { 光标移至段落结尾 n$ 光标移至第 n 行尾 H 光标移至屏幕顶行 M 光标移至屏幕中间行 L 光标移至屏幕最后行 0 (注意是数字零) 光标移至当前行首 ^ 移动光标到行首第一个非空字符上去 $ 光标移至当前行尾 gg 移到第一行 G 移到最后一行 f 移动光标到当前行的字符 a 上 F 相反 % 移动到与制匹配的括号上去 () ,{},[],&amp;lt;&amp;gt; 等 nG 移动到第 n 行上 G 到最后一行 屏幕滚动 命令 描述 Ctrl+u 向文件首翻半屏 Ctrl+d 向文件尾翻半屏 Ctrl+f 向文件尾翻一屏 Ctrl+ b 向文件首翻一屏 nz 将第 n 行滚至屏幕顶部, 不指定 n 时将当前行滚至屏幕顶部 插入文本类 命令 描述 i 在光标前 I 在当前行首 a 光标后 A 在当前行尾 o 在当前行之下新开一行 O 在当前行之上新开一行 r 替换当前字符 R 替换当前字符及其后的字符, 直至按 ESC 键 s 从当前光标位置处开始, 以输入的文本替代指定数目的字符 S 删除指定数目的行, 并以所输入文本代替之 ncw/nCW 修改指定数目的字 nCC 修改指定数目的行 删除命令 命令 描述 x/X 删除 - 个字符, x 删除光标后的, 而 X 删除光标前的 dw 删除一个单词 (删除光标位置到下一个单词开始的位置) dnw 删除 n 个单词 dne 也可，只是删除到单词尾 do 删至行首 d$ 删至行尾 dd 删除一行 ndd 删除当前行及其后 n-1 行 dnl 向右删除 n 个字母 dnh 向左删除 n 个字母 dnj 向下删除 n 行，当前行 + 其上 n 行 dnk 向上删除 n 行，当期行 + 其下 n 行 cnw[word] 将 n 个 word 改变为 word C$ 改变到行尾 cc 改变整行 shift+j 删除行尾的换行符，下一行接上来了 复制粘贴 命令 描述 p 粘贴用 x 或 d 删除的文本 ynw 复制 n 个单词 yy 复制一行 ynl 复制 n 个字符 y$ 复制当前光标至行尾处 Nay 拷贝 n 行 撤销 命令 描述 u 撤销前一 - 次的操作 shif+u(U) 撤销对该行的所有操作 搜索及替换 命令 描述 /pattern 从光标开始处向文件尾搜索 pattern ?</description></item></channel></rss>