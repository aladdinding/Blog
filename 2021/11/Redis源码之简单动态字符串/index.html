<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Redis源码之简单动态字符串 | 阿拉丁的博客</title><meta name=keywords content="源码阅读,"><meta name=description content="Redis中字符串的实现并没有完全使用C字符串，而是重新定义了简单动态字符串SDS（Simple Dynamic String）用来表示字符串。 sds.h/sdshdr struct sdshdr { unsigned int len; //记录buf数组中已使字节的数量 unsigned int free; // 记录buf数组中未使用字节的数量 char buf[]; //字节数组，用于保存字符串 }; buf数组长度不一定就是字符串"><meta name=author content><link rel=canonical href=https://aladdinding.cn/2021/11/Redis%E6%BA%90%E7%A0%81%E4%B9%8B%E7%AE%80%E5%8D%95%E5%8A%A8%E6%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2/><meta name=google-site-verification content="G-QY1H3LE9QK"><link crossorigin=anonymous href=/assets/css/stylesheet.min.fcb2dfef1f861f508726aa63fad2809727c9d99081a63847ab71ee83ce0d1203.css integrity="sha256-/LLf7x+GH1CHJqpj+tKAlyfJ2ZCBpjhHq3Hug84NEgM=" rel="preload stylesheet" as=style><link rel=icon href=https://img.aladdinding.cn/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://aladdinding.cn/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://aladdinding.cn/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://aladdinding.cn/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://aladdinding.cn/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.85.0"><script async src="https://www.googletagmanager.com/gtag/js?id=G-QY1H3LE9QK"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag('js',new Date),gtag('config','G-QY1H3LE9QK')</script><meta property="og:title" content="Redis源码之简单动态字符串"><meta property="og:description" content="Redis中字符串的实现并没有完全使用C字符串，而是重新定义了简单动态字符串SDS（Simple Dynamic String）用来表示字符串。 sds.h/sdshdr struct sdshdr { unsigned int len; //记录buf数组中已使字节的数量 unsigned int free; // 记录buf数组中未使用字节的数量 char buf[]; //字节数组，用于保存字符串 }; buf数组长度不一定就是字符串"><meta property="og:type" content="article"><meta property="og:url" content="https://aladdinding.cn/2021/11/Redis%E6%BA%90%E7%A0%81%E4%B9%8B%E7%AE%80%E5%8D%95%E5%8A%A8%E6%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-11-05T00:00:00+00:00"><meta property="article:modified_time" content="2021-11-05T00:00:00+00:00"><meta property="og:site_name" content="Aladdin"><meta name=twitter:card content="summary"><meta name=twitter:title content="Redis源码之简单动态字符串"><meta name=twitter:description content="Redis中字符串的实现并没有完全使用C字符串，而是重新定义了简单动态字符串SDS（Simple Dynamic String）用来表示字符串。 sds.h/sdshdr struct sdshdr { unsigned int len; //记录buf数组中已使字节的数量 unsigned int free; // 记录buf数组中未使用字节的数量 char buf[]; //字节数组，用于保存字符串 }; buf数组长度不一定就是字符串"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://aladdinding.cn/posts/"},{"@type":"ListItem","position":2,"name":"Redis源码之简单动态字符串","item":"https://aladdinding.cn/2021/11/Redis%E6%BA%90%E7%A0%81%E4%B9%8B%E7%AE%80%E5%8D%95%E5%8A%A8%E6%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Redis源码之简单动态字符串","name":"Redis源码之简单动态字符串","description":"Redis中字符串的实现并没有完全使用C字符串，而是重新定义了简单动态字符串SDS（Simple Dynamic String）用来表示字符串。 sds.h/sdshdr struct sdshdr { unsigned int len; //记录buf数组中已使字节的数量 unsigned int free; // 记录buf数组中未使用字节的数量 char buf[]; //字节数组，用于保存字符串 }; buf数组长度不一定就是字符串","keywords":["源码阅读",""],"articleBody":"Redis中字符串的实现并没有完全使用C字符串，而是重新定义了简单动态字符串SDS（Simple Dynamic String）用来表示字符串。\nsds.h/sdshdr\nstruct sdshdr { unsigned int len; //记录buf数组中已使字节的数量  unsigned int free; // 记录buf数组中未使用字节的数量  char buf[]; //字节数组，用于保存字符串 }; buf数组长度不一定就是字符串长度+1（\"\\0\"），还有free空间，数组内未使用的字节通过free属性记录。\n相比于C字符串，SDS有以下优势：\n兼容部分C字符串函数 sds.c/sdsnew\n* mystring = sdsnewlen(\"abc\",3); * * You can print the string with printf() as there is an implicit \\0 at the * end of the string. However the string is binary safe and can contain * \\0 characters in the middle, as the length is stored in the sds header. */ sds sdsnewlen(const void *init, size_t initlen) { struct sdshdr *sh; if (init) { sh = zmalloc(sizeof(struct sdshdr)+initlen+1); } else { sh = zcalloc(sizeof(struct sdshdr)+initlen+1); } if (sh == NULL) return NULL; sh-len = initlen; sh-free = 0; if (initlen \u0026\u0026 init) memcpy(sh-buf, init, initlen); sh-buf[initlen] = '\\0'; return (char*)sh-buf; } /* Create a new sds string starting from a null termined C string. */ sds sdsnew(const char *init) { size_t initlen = (init == NULL) ? 0 : strlen(init); return sdsnewlen(init, initlen); 从SDS的创建逻辑中可以看出\n SDS遵循C字符串以空字符（\"\\0\"）结尾。 SDS中的len属性（sds.h/sdslen）同C字符串函数strlen返回结果相同，即不计算尾部空字符。  这样SDS就可以直接重用一部分C字符串函数库里面的函数（如打印，显示类函数，/printf），而字符串的修改操作，则使用SDS自定义优化后的函数。\n常数复杂度获取字符串长度 C获取一个C字符串的长度，程序必须遍历整个字符串，直到遇到代表字符串结尾的空字符串位置，这个操作的复杂度为O(N)。\n但是对于SDS来说，获取字符串长度只需要访问SDS中的len属性。复杂度仅为O(1)，确保了获取字符串长度这样的高频操作不会成为Redis性能瓶颈。\n对于SDS的修改操作，SDS会实时维护len属性，如sds.c/sdscat（追加C字符串到SDS字符串）\n/* Append the specified binary-safe string pointed by 't' of 'len' bytes to the * end of the specified sds string 's'. * * After the call, the passed sds string is no longer valid and all the * references must be substituted with the new pointer returned by the call. */ sds sdscatlen(sds s, const void *t, size_t len) { struct sdshdr *sh; size_t curlen = sdslen(s); s = sdsMakeRoomFor(s,len); if (s == NULL) return NULL; sh = (void*) (s-(sizeof(struct sdshdr))); memcpy(s+curlen, t, len); sh-len = curlen+len; sh-free = sh-free-len; s[curlen+len] = '\\0'; return s; } /* Append the specified sds 't' to the existing sds 's'. * * After the call, the modified sds string is no longer valid and all the * references must be substituted with the new pointer returned by the call. */ sds sdscatsds(sds s, const sds t) { return sdscatlen(s, t, sdslen(t)); } 杜绝缓冲区溢出 C字符串由于不记录自身长度，对其进行修改操作容易造成缓冲区溢出（buffer overflow）。如C字符串拼接函数/strcat，内存中相邻的字符串s1和s2，对s1字符串做拼接操作时，如果没有提前为s1分配足够的空间，则s2保存的内容会被意外修改。\nSDS内部维护了一个free字段，当SDS API需要对其进行修改时，API会调用sdsMakeRoomForDS函数检测当前SDS的free空间是否满足要求，满足直接进行修改；不满足sdsMakeRoomForDS则会将SDS的空间扩展至执行修改所需的大小，避免缓冲区溢出的情况（如上方sds.c/sdscat）。\n减少修改字符串长度时所需内存重分配次数 Redis作为数据库，经常被用于速度要求严苛，数据被频繁修改的场景。SDS实现了空间预分配和惰性空间释放两种优化策略。\nsds.c/sdsMakeRoomFor\n/* Enlarge the free space at the end of the sds string so that the caller * is sure that after calling this function can overwrite up to addlen * bytes after the end of the string, plus one more byte for nul term. * * Note: this does not change the *length* of the sds string as returned * by sdslen(), but only the free buffer space we have. */ sds sdsMakeRoomFor(sds s, size_t addlen) { struct sdshdr *sh, *newsh; size_t free = sdsavail(s); size_t len, newlen; if (free = addlen) return s; len = sdslen(s); sh = (void*) (s-(sizeof(struct sdshdr))); newlen = (len+addlen); if (newlen  SDS_MAX_PREALLOC) newlen *= 2; else newlen += SDS_MAX_PREALLOC; newsh = zrealloc(sh, sizeof(struct sdshdr)+newlen+1); if (newsh == NULL) return NULL; newsh-free = newlen - len; return newsh-buf; } 空间预分配 可以发现，在SDS API进行字符串新增逻辑中会给SDS重新分配free空间。\n 如果SDS的长度（len属性）小于SDS_MAX_PREALLOC（1024KB=1M），则会分配和len属性同样大小的未使用空间给buf，这时SDS的len属性和free属性值相同。 如果SDS长度大于或者等于SDS_MAX_PREALLOC（1024KB=1M），则会直接给free属性分配SDS_MAX_PREALLOC（1024KB=1M）的大小。  通过空间预分配策略，Redis可以减少连续执行字符串增长操作所需的内存重分配次数.\n惰性空间释放 sds.c/sdstrim\n/* Remove the part of the string from left and from right composed just of * contiguous characters found in 'cset', that is a null terminted C string. * * After the call, the modified sds string is no longer valid and all the * references must be substituted with the new pointer returned by the call. * * Example: * * s = sdsnew(\"AA...AA.a.aa.aHelloWorld :::\"); * s = sdstrim(s,\"A. :\"); * printf(\"%s\\n\", s); * * Output will be just \"Hello World\". */ sds sdstrim(sds s, const char *cset) { struct sdshdr *sh = (void*) (s-(sizeof(struct sdshdr))); char *start, *end, *sp, *ep; size_t len; sp = start = s; ep = end = s+sdslen(s)-1; while(sp  end \u0026\u0026 strchr(cset, *sp)) sp++; while(ep  start \u0026\u0026 strchr(cset, *ep)) ep--; len = (sp  ep) ? 0 : ((ep-sp)+1); if (sh-buf != sp) memmove(sh-buf, sp, len); sh-buf[len] = '\\0'; sh-free = sh-free+(sh-len-len); sh-len = len; return s; } 可以发现，在进行字符串剪切操作时，多出的buf空间并不会直接释放，而是存储在free字段中。\n同时为了避免内存泄露，SDS也提供了sds.c/sdsRemoveFreeSpace释放free空间操作，在redis.c/clientsCronResizeQueryBuffer中可以看到，当querybuf大于1024字节，会进行释放操作。\n/* Reallocate the sds string so that it has no free space at the end. The * contained string remains not altered, but next concatenation operations * will require a reallocation. * * After the call, the passed sds string is no longer valid and all the * references must be substituted with the new pointer returned by the call. */ sds sdsRemoveFreeSpace(sds s) { struct sdshdr *sh; sh = (void*) (s-(sizeof(struct sdshdr))); sh = zrealloc(sh, sizeof(struct sdshdr)+sh-len+1); sh-free = 0; return sh-buf; } /* The client query buffer is an sds.c string that can end with a lot of * free space not used, this function reclaims space if needed. * * The function always returns 0 as it never terminates the client. */ int clientsCronResizeQueryBuffer(redisClient *c) { size_t querybuf_size = sdsAllocSize(c-querybuf); time_t idletime = server.unixtime - c-lastinteraction; /* There are two conditions to resize the query buffer: * 1) Query buffer is  BIG_ARG and too big for latest peak. * 2) Client is inactive and the buffer is bigger than 1k. */ if (((querybuf_size  REDIS_MBULK_BIG_ARG) \u0026\u0026 (querybuf_size/(c-querybuf_peak+1))  2) || (querybuf_size  1024 \u0026\u0026 idletime  2)) { /* Only resize the query buffer if it is actually wasting space. */ if (sdsavail(c-querybuf)  1024) { c-querybuf = sdsRemoveFreeSpace(c-querybuf); } } /* Reset the peak again to capture the peak memory usage in the next * cycle. */ c-querybuf_peak = 0; return 0; } 二进制安全 SDS API都会以处理二进制的方式来处理SDS存放在buf数组里的数据（如不以\"\\0\"当作字符串结尾），程序不会对其中的数据做任何限制、过滤、或者假设，数据在写入时是什么样的，他被读取时就是什么样子。因此Redis可以不仅可以保存文本数据，还可以保存图片、音频、视频、压缩文件这样的二进制数据。\nSDS API ","wordCount":"2396","inLanguage":"zh","datePublished":"2021-11-05T00:00:00Z","dateModified":"2021-11-05T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://aladdinding.cn/2021/11/Redis%E6%BA%90%E7%A0%81%E4%B9%8B%E7%AE%80%E5%8D%95%E5%8A%A8%E6%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2/"},"publisher":{"@type":"Organization","name":"阿拉丁的博客","logo":{"@type":"ImageObject","url":"https://img.aladdinding.cn/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script><noscript><style type=text/css>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:#1d1e20;--entry:#2e2e33;--primary:rgba(255, 255, 255, 0.84);--secondary:rgba(255, 255, 255, 0.56);--tertiary:rgba(255, 255, 255, 0.16);--content:rgba(255, 255, 255, 0.74);--hljs-bg:#2e2e33;--code-bg:#37383e;--border:#333}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><header class=header><nav class=nav><div class=logo><a href=https://aladdinding.cn/ accesskey=h title="阿拉丁的博客 (Alt + H)">阿拉丁的博客</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://aladdinding.cn/archives/ title=时间轴><span>时间轴</span></a></li><li><a href=https://aladdinding.cn/categories/ title=分类><span>分类</span></a></li><li><a href=https://aladdinding.cn/tags/ title=标签><span>标签</span></a></li><li><a href=https://aladdinding.cn/search/ title="搜索 (Alt + /)" accesskey=/><span>搜索</span></a></li><li><a href=https://aladdinding.cn/about/ title=关于><span>关于</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://aladdinding.cn/>主页</a>&nbsp;»&nbsp;<a href=https://aladdinding.cn/posts/>Posts</a></div><h1 class=post-title>Redis源码之简单动态字符串</h1><div class=post-meta>November 5, 2021&nbsp;·&nbsp;5 分钟</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><div class=details>目录</div></summary><div class=inner><ul><li><a href=#%e5%85%bc%e5%ae%b9%e9%83%a8%e5%88%86c%e5%ad%97%e7%ac%a6%e4%b8%b2%e5%87%bd%e6%95%b0 aria-label=兼容部分C字符串函数>兼容部分C字符串函数</a></li><li><a href=#%e5%b8%b8%e6%95%b0%e5%a4%8d%e6%9d%82%e5%ba%a6%e8%8e%b7%e5%8f%96%e5%ad%97%e7%ac%a6%e4%b8%b2%e9%95%bf%e5%ba%a6 aria-label=常数复杂度获取字符串长度>常数复杂度获取字符串长度</a></li><li><a href=#%e6%9d%9c%e7%bb%9d%e7%bc%93%e5%86%b2%e5%8c%ba%e6%ba%a2%e5%87%ba aria-label=杜绝缓冲区溢出>杜绝缓冲区溢出</a></li><li><a href=#%e5%87%8f%e5%b0%91%e4%bf%ae%e6%94%b9%e5%ad%97%e7%ac%a6%e4%b8%b2%e9%95%bf%e5%ba%a6%e6%97%b6%e6%89%80%e9%9c%80%e5%86%85%e5%ad%98%e9%87%8d%e5%88%86%e9%85%8d%e6%ac%a1%e6%95%b0 aria-label=减少修改字符串长度时所需内存重分配次数>减少修改字符串长度时所需内存重分配次数</a><ul><li><a href=#%e7%a9%ba%e9%97%b4%e9%a2%84%e5%88%86%e9%85%8d aria-label=空间预分配>空间预分配</a></li><li><a href=#%e6%83%b0%e6%80%a7%e7%a9%ba%e9%97%b4%e9%87%8a%e6%94%be aria-label=惰性空间释放>惰性空间释放</a></li></ul></li><li><a href=#%e4%ba%8c%e8%bf%9b%e5%88%b6%e5%ae%89%e5%85%a8 aria-label=二进制安全>二进制安全</a></li><li><a href=#sds-api aria-label="SDS API">SDS API</a></li></ul></div></details></div><div class=post-content><p>Redis中字符串的实现并没有完全使用C字符串，而是重新定义了简单动态字符串SDS（Simple Dynamic String）用来表示字符串。</p><p>sds.h/sdshdr</p><div class=highlight><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#ff79c6>struct</span> sdshdr {
    <span style=color:#8be9fd>unsigned</span> <span style=color:#8be9fd>int</span> len; <span style=color:#6272a4>//记录buf数组中已使字节的数量
</span><span style=color:#6272a4></span>    <span style=color:#8be9fd>unsigned</span> <span style=color:#8be9fd>int</span> free; <span style=color:#6272a4>// 记录buf数组中未使用字节的数量
</span><span style=color:#6272a4></span>    <span style=color:#8be9fd>char</span> buf[]; <span style=color:#6272a4>//字节数组，用于保存字符串
</span><span style=color:#6272a4></span>};
</code></pre></div><p>buf数组长度不一定就是字符串长度+1（"\0"），还有free空间，数组内未使用的字节通过free属性记录。</p><p>相比于C字符串，SDS有以下优势：</p><h4 id=兼容部分c字符串函数>兼容部分C字符串函数<a hidden class=anchor aria-hidden=true href=#兼容部分c字符串函数>#</a></h4><p>sds.c/sdsnew</p><div class=highlight><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c> <span style=color:#ff79c6>*</span> mystring <span style=color:#ff79c6>=</span> sdsnewlen(<span style=color:#f1fa8c>&#34;abc&#34;</span>,<span style=color:#bd93f9>3</span>);
 <span style=color:#ff79c6>*</span>
 <span style=color:#ff79c6>*</span> You can print the string with <span style=color:#50fa7b>printf</span>() as there is an implicit \<span style=color:#bd93f9>0</span> at the
 <span style=color:#ff79c6>*</span> end of the string. However the string is binary safe and can contain
 <span style=color:#ff79c6>*</span> \<span style=color:#bd93f9>0</span> characters in the middle, as the length is stored in the sds header. */
sds sdsnewlen(<span style=color:#ff79c6>const</span> <span style=color:#8be9fd>void</span> <span style=color:#ff79c6>*</span>init, size_t initlen) {
    <span style=color:#ff79c6>struct</span> sdshdr <span style=color:#ff79c6>*</span>sh;

    <span style=color:#ff79c6>if</span> (init) {
        sh <span style=color:#ff79c6>=</span> zmalloc(<span style=color:#ff79c6>sizeof</span>(<span style=color:#ff79c6>struct</span> sdshdr)<span style=color:#ff79c6>+</span>initlen<span style=color:#ff79c6>+</span><span style=color:#bd93f9>1</span>);
    } <span style=color:#ff79c6>else</span> {
        sh <span style=color:#ff79c6>=</span> zcalloc(<span style=color:#ff79c6>sizeof</span>(<span style=color:#ff79c6>struct</span> sdshdr)<span style=color:#ff79c6>+</span>initlen<span style=color:#ff79c6>+</span><span style=color:#bd93f9>1</span>);
    }
    <span style=color:#ff79c6>if</span> (sh <span style=color:#ff79c6>==</span> <span style=color:#8be9fd;font-style:italic>NULL</span>) <span style=color:#ff79c6>return</span> <span style=color:#8be9fd;font-style:italic>NULL</span>;
    sh<span style=color:#ff79c6>-&gt;</span>len <span style=color:#ff79c6>=</span> initlen;
    sh<span style=color:#ff79c6>-&gt;</span>free <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>0</span>;
    <span style=color:#ff79c6>if</span> (initlen <span style=color:#ff79c6>&amp;&amp;</span> init)
        memcpy(sh<span style=color:#ff79c6>-&gt;</span>buf, init, initlen);
    sh<span style=color:#ff79c6>-&gt;</span>buf[initlen] <span style=color:#ff79c6>=</span> <span style=color:#f1fa8c>&#39;\0&#39;</span>;
    <span style=color:#ff79c6>return</span> (<span style=color:#8be9fd>char</span><span style=color:#ff79c6>*</span>)sh<span style=color:#ff79c6>-&gt;</span>buf;
}

<span style=color:#6272a4>/* Create a new sds string starting from a null termined C string. */</span>
sds <span style=color:#50fa7b>sdsnew</span>(<span style=color:#ff79c6>const</span> <span style=color:#8be9fd>char</span> <span style=color:#ff79c6>*</span>init) {
    size_t initlen <span style=color:#ff79c6>=</span> (init <span style=color:#ff79c6>==</span> <span style=color:#8be9fd;font-style:italic>NULL</span>) <span style=color:#ff79c6>?</span> <span style=color:#bd93f9>0</span> <span style=color:#ff79c6>:</span> strlen(init);
    <span style=color:#ff79c6>return</span> sdsnewlen(init, initlen);
</code></pre></div><p>从SDS的创建逻辑中可以看出</p><ol><li>SDS遵循C字符串以空字符（"\0"）结尾。</li><li>SDS中的len属性（sds.h/sdslen）同C字符串函数strlen返回结果相同，即不计算尾部空字符。</li></ol><p>这样SDS就可以直接重用一部分C字符串函数库里面的函数（如打印，显示类函数，&lt;stdio.h>/printf），而字符串的修改操作，则使用SDS自定义优化后的函数。</p><h4 id=常数复杂度获取字符串长度>常数复杂度获取字符串长度<a hidden class=anchor aria-hidden=true href=#常数复杂度获取字符串长度>#</a></h4><p>C获取一个C字符串的长度，程序必须遍历整个字符串，直到遇到代表字符串结尾的空字符串位置，这个操作的复杂度为O(N)。</p><p>但是对于SDS来说，获取字符串长度只需要访问SDS中的len属性。复杂度仅为O(1)，确保了获取字符串长度这样的高频操作不会成为Redis性能瓶颈。</p><p>对于SDS的修改操作，SDS会实时维护len属性，如sds.c/sdscat（追加C字符串到SDS字符串）</p><div class=highlight><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#6272a4>/* Append the specified binary-safe string pointed by &#39;t&#39; of &#39;len&#39; bytes to the
</span><span style=color:#6272a4> * end of the specified sds string &#39;s&#39;.
</span><span style=color:#6272a4> *
</span><span style=color:#6272a4> * After the call, the passed sds string is no longer valid and all the
</span><span style=color:#6272a4> * references must be substituted with the new pointer returned by the call. */</span>
sds <span style=color:#50fa7b>sdscatlen</span>(sds s, <span style=color:#ff79c6>const</span> <span style=color:#8be9fd>void</span> <span style=color:#ff79c6>*</span>t, size_t len) {
    <span style=color:#ff79c6>struct</span> sdshdr <span style=color:#ff79c6>*</span>sh;
    size_t curlen <span style=color:#ff79c6>=</span> sdslen(s);

    s <span style=color:#ff79c6>=</span> sdsMakeRoomFor(s,len);
    <span style=color:#ff79c6>if</span> (s <span style=color:#ff79c6>==</span> <span style=color:#8be9fd;font-style:italic>NULL</span>) <span style=color:#ff79c6>return</span> <span style=color:#8be9fd;font-style:italic>NULL</span>;
    sh <span style=color:#ff79c6>=</span> (<span style=color:#8be9fd>void</span><span style=color:#ff79c6>*</span>) (s<span style=color:#ff79c6>-</span>(<span style=color:#ff79c6>sizeof</span>(<span style=color:#ff79c6>struct</span> sdshdr)));
    memcpy(s<span style=color:#ff79c6>+</span>curlen, t, len);
    sh<span style=color:#ff79c6>-&gt;</span>len <span style=color:#ff79c6>=</span> curlen<span style=color:#ff79c6>+</span>len;
    sh<span style=color:#ff79c6>-&gt;</span>free <span style=color:#ff79c6>=</span> sh<span style=color:#ff79c6>-&gt;</span>free<span style=color:#ff79c6>-</span>len;
    s[curlen<span style=color:#ff79c6>+</span>len] <span style=color:#ff79c6>=</span> <span style=color:#f1fa8c>&#39;\0&#39;</span>;
    <span style=color:#ff79c6>return</span> s;
}

<span style=color:#6272a4>/* Append the specified sds &#39;t&#39; to the existing sds &#39;s&#39;.
</span><span style=color:#6272a4> *
</span><span style=color:#6272a4> * After the call, the modified sds string is no longer valid and all the
</span><span style=color:#6272a4> * references must be substituted with the new pointer returned by the call. */</span>
sds <span style=color:#50fa7b>sdscatsds</span>(sds s, <span style=color:#ff79c6>const</span> sds t) {
    <span style=color:#ff79c6>return</span> sdscatlen(s, t, sdslen(t));
}
</code></pre></div><h4 id=杜绝缓冲区溢出>杜绝缓冲区溢出<a hidden class=anchor aria-hidden=true href=#杜绝缓冲区溢出>#</a></h4><p>C字符串由于不记录自身长度，对其进行修改操作容易造成缓冲区溢出（buffer overflow）。如C字符串拼接函数&lt;stdio.h>/strcat，内存中相邻的字符串s1和s2，对s1字符串做拼接操作时，如果没有提前为s1分配足够的空间，则s2保存的内容会被意外修改。</p><p>SDS内部维护了一个free字段，当SDS API需要对其进行修改时，API会调用<code>sdsMakeRoomForDS</code>函数检测当前SDS的free空间是否满足要求，满足直接进行修改；不满足<code>sdsMakeRoomForDS</code>则会将SDS的空间扩展至执行修改所需的大小，避免缓冲区溢出的情况（如上方sds.c/sdscat）。</p><h4 id=减少修改字符串长度时所需内存重分配次数>减少修改字符串长度时所需内存重分配次数<a hidden class=anchor aria-hidden=true href=#减少修改字符串长度时所需内存重分配次数>#</a></h4><p>Redis作为数据库，经常被用于速度要求严苛，数据被频繁修改的场景。SDS实现了<strong>空间预分配</strong>和<strong>惰性空间释放</strong>两种优化策略。</p><p>sds.c/sdsMakeRoomFor</p><div class=highlight><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#6272a4>/* Enlarge the free space at the end of the sds string so that the caller
</span><span style=color:#6272a4> * is sure that after calling this function can overwrite up to addlen
</span><span style=color:#6272a4> * bytes after the end of the string, plus one more byte for nul term.
</span><span style=color:#6272a4> *
</span><span style=color:#6272a4> * Note: this does not change the *length* of the sds string as returned
</span><span style=color:#6272a4> * by sdslen(), but only the free buffer space we have. */</span>
sds <span style=color:#50fa7b>sdsMakeRoomFor</span>(sds s, size_t addlen) {
    <span style=color:#ff79c6>struct</span> sdshdr <span style=color:#ff79c6>*</span>sh, <span style=color:#ff79c6>*</span>newsh;
    size_t free <span style=color:#ff79c6>=</span> sdsavail(s);
    size_t len, newlen;

    <span style=color:#ff79c6>if</span> (free <span style=color:#ff79c6>&gt;=</span> addlen) <span style=color:#ff79c6>return</span> s;
    len <span style=color:#ff79c6>=</span> sdslen(s);
    sh <span style=color:#ff79c6>=</span> (<span style=color:#8be9fd>void</span><span style=color:#ff79c6>*</span>) (s<span style=color:#ff79c6>-</span>(<span style=color:#ff79c6>sizeof</span>(<span style=color:#ff79c6>struct</span> sdshdr)));
    newlen <span style=color:#ff79c6>=</span> (len<span style=color:#ff79c6>+</span>addlen);
    <span style=color:#ff79c6>if</span> (newlen <span style=color:#ff79c6>&lt;</span> SDS_MAX_PREALLOC)
        newlen <span style=color:#ff79c6>*=</span> <span style=color:#bd93f9>2</span>;
    <span style=color:#ff79c6>else</span>
        newlen <span style=color:#ff79c6>+=</span> SDS_MAX_PREALLOC;
    newsh <span style=color:#ff79c6>=</span> zrealloc(sh, <span style=color:#ff79c6>sizeof</span>(<span style=color:#ff79c6>struct</span> sdshdr)<span style=color:#ff79c6>+</span>newlen<span style=color:#ff79c6>+</span><span style=color:#bd93f9>1</span>);
    <span style=color:#ff79c6>if</span> (newsh <span style=color:#ff79c6>==</span> <span style=color:#8be9fd;font-style:italic>NULL</span>) <span style=color:#ff79c6>return</span> <span style=color:#8be9fd;font-style:italic>NULL</span>;

    newsh<span style=color:#ff79c6>-&gt;</span>free <span style=color:#ff79c6>=</span> newlen <span style=color:#ff79c6>-</span> len;
    <span style=color:#ff79c6>return</span> newsh<span style=color:#ff79c6>-&gt;</span>buf;
}
</code></pre></div><h5 id=空间预分配>空间预分配<a hidden class=anchor aria-hidden=true href=#空间预分配>#</a></h5><p>可以发现，在SDS API进行字符串新增逻辑中会给SDS重新分配free空间。</p><ol><li>如果SDS的长度（len属性）小于<code>SDS_MAX_PREALLOC（1024KB=1M）</code>，则会分配和len属性同样大小的未使用空间给buf，这时SDS的len属性和free属性值相同。</li><li>如果SDS长度大于或者等于<code>SDS_MAX_PREALLOC（1024KB=1M）</code>，则会直接给free属性分配<code>SDS_MAX_PREALLOC（1024KB=1M）</code>的大小。</li></ol><p>通过空间预分配策略，Redis可以减少连续执行字符串增长操作所需的内存重分配次数.</p><h5 id=惰性空间释放>惰性空间释放<a hidden class=anchor aria-hidden=true href=#惰性空间释放>#</a></h5><p>sds.c/sdstrim</p><div class=highlight><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#6272a4>/* Remove the part of the string from left and from right composed just of
</span><span style=color:#6272a4> * contiguous characters found in &#39;cset&#39;, that is a null terminted C string.
</span><span style=color:#6272a4> *
</span><span style=color:#6272a4> * After the call, the modified sds string is no longer valid and all the
</span><span style=color:#6272a4> * references must be substituted with the new pointer returned by the call.
</span><span style=color:#6272a4> *
</span><span style=color:#6272a4> * Example:
</span><span style=color:#6272a4> *
</span><span style=color:#6272a4> * s = sdsnew(&#34;AA...AA.a.aa.aHelloWorld     :::&#34;);
</span><span style=color:#6272a4> * s = sdstrim(s,&#34;A. :&#34;);
</span><span style=color:#6272a4> * printf(&#34;%s\n&#34;, s);
</span><span style=color:#6272a4> *
</span><span style=color:#6272a4> * Output will be just &#34;Hello World&#34;.
</span><span style=color:#6272a4> */</span>
sds <span style=color:#50fa7b>sdstrim</span>(sds s, <span style=color:#ff79c6>const</span> <span style=color:#8be9fd>char</span> <span style=color:#ff79c6>*</span>cset) {
    <span style=color:#ff79c6>struct</span> sdshdr <span style=color:#ff79c6>*</span>sh <span style=color:#ff79c6>=</span> (<span style=color:#8be9fd>void</span><span style=color:#ff79c6>*</span>) (s<span style=color:#ff79c6>-</span>(<span style=color:#ff79c6>sizeof</span>(<span style=color:#ff79c6>struct</span> sdshdr)));
    <span style=color:#8be9fd>char</span> <span style=color:#ff79c6>*</span>start, <span style=color:#ff79c6>*</span>end, <span style=color:#ff79c6>*</span>sp, <span style=color:#ff79c6>*</span>ep;
    size_t len;

    sp <span style=color:#ff79c6>=</span> start <span style=color:#ff79c6>=</span> s;
    ep <span style=color:#ff79c6>=</span> end <span style=color:#ff79c6>=</span> s<span style=color:#ff79c6>+</span>sdslen(s)<span style=color:#ff79c6>-</span><span style=color:#bd93f9>1</span>;
    <span style=color:#ff79c6>while</span>(sp <span style=color:#ff79c6>&lt;=</span> end <span style=color:#ff79c6>&amp;&amp;</span> strchr(cset, <span style=color:#ff79c6>*</span>sp)) sp<span style=color:#ff79c6>++</span>;
    <span style=color:#ff79c6>while</span>(ep <span style=color:#ff79c6>&gt;</span> start <span style=color:#ff79c6>&amp;&amp;</span> strchr(cset, <span style=color:#ff79c6>*</span>ep)) ep<span style=color:#ff79c6>--</span>;
    len <span style=color:#ff79c6>=</span> (sp <span style=color:#ff79c6>&gt;</span> ep) <span style=color:#ff79c6>?</span> <span style=color:#bd93f9>0</span> <span style=color:#ff79c6>:</span> ((ep<span style=color:#ff79c6>-</span>sp)<span style=color:#ff79c6>+</span><span style=color:#bd93f9>1</span>);
    <span style=color:#ff79c6>if</span> (sh<span style=color:#ff79c6>-&gt;</span>buf <span style=color:#ff79c6>!=</span> sp) memmove(sh<span style=color:#ff79c6>-&gt;</span>buf, sp, len);
    sh<span style=color:#ff79c6>-&gt;</span>buf[len] <span style=color:#ff79c6>=</span> <span style=color:#f1fa8c>&#39;\0&#39;</span>;
    sh<span style=color:#ff79c6>-&gt;</span>free <span style=color:#ff79c6>=</span> sh<span style=color:#ff79c6>-&gt;</span>free<span style=color:#ff79c6>+</span>(sh<span style=color:#ff79c6>-&gt;</span>len<span style=color:#ff79c6>-</span>len);
    sh<span style=color:#ff79c6>-&gt;</span>len <span style=color:#ff79c6>=</span> len;
    <span style=color:#ff79c6>return</span> s;
}
</code></pre></div><p>可以发现，在进行字符串剪切操作时，多出的buf空间并不会直接释放，而是存储在free字段中。</p><p>同时为了避免内存泄露，SDS也提供了sds.c/sdsRemoveFreeSpace释放free空间操作，在redis.c/clientsCronResizeQueryBuffer中可以看到，当querybuf大于1024字节，会进行释放操作。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#6272a4>/* Reallocate the sds string so that it has no free space at the end. The
</span><span style=color:#6272a4> * contained string remains not altered, but next concatenation operations
</span><span style=color:#6272a4> * will require a reallocation.
</span><span style=color:#6272a4> *
</span><span style=color:#6272a4> * After the call, the passed sds string is no longer valid and all the
</span><span style=color:#6272a4> * references must be substituted with the new pointer returned by the call. */</span>
sds <span style=color:#50fa7b>sdsRemoveFreeSpace</span>(sds s) {
    <span style=color:#ff79c6>struct</span> sdshdr <span style=color:#ff79c6>*</span>sh;

    sh <span style=color:#ff79c6>=</span> (<span style=color:#8be9fd>void</span><span style=color:#ff79c6>*</span>) (s<span style=color:#ff79c6>-</span>(<span style=color:#ff79c6>sizeof</span>(<span style=color:#ff79c6>struct</span> sdshdr)));
    sh <span style=color:#ff79c6>=</span> zrealloc(sh, <span style=color:#ff79c6>sizeof</span>(<span style=color:#ff79c6>struct</span> sdshdr)<span style=color:#ff79c6>+</span>sh<span style=color:#ff79c6>-&gt;</span>len<span style=color:#ff79c6>+</span><span style=color:#bd93f9>1</span>);
    sh<span style=color:#ff79c6>-&gt;</span>free <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>0</span>;
    <span style=color:#ff79c6>return</span> sh<span style=color:#ff79c6>-&gt;</span>buf;
}

<span style=color:#6272a4>/* The client query buffer is an sds.c string that can end with a lot of
</span><span style=color:#6272a4> * free space not used, this function reclaims space if needed.
</span><span style=color:#6272a4> *
</span><span style=color:#6272a4> * The function always returns 0 as it never terminates the client. */</span>
<span style=color:#8be9fd>int</span> <span style=color:#50fa7b>clientsCronResizeQueryBuffer</span>(redisClient <span style=color:#ff79c6>*</span>c) {
    size_t querybuf_size <span style=color:#ff79c6>=</span> sdsAllocSize(c<span style=color:#ff79c6>-&gt;</span>querybuf);
    time_t idletime <span style=color:#ff79c6>=</span> server.unixtime <span style=color:#ff79c6>-</span> c<span style=color:#ff79c6>-&gt;</span>lastinteraction;

    <span style=color:#6272a4>/* There are two conditions to resize the query buffer:
</span><span style=color:#6272a4>     * 1) Query buffer is &gt; BIG_ARG and too big for latest peak.
</span><span style=color:#6272a4>     * 2) Client is inactive and the buffer is bigger than 1k. */</span>
    <span style=color:#ff79c6>if</span> (((querybuf_size <span style=color:#ff79c6>&gt;</span> REDIS_MBULK_BIG_ARG) <span style=color:#ff79c6>&amp;&amp;</span>
         (querybuf_size<span style=color:#ff79c6>/</span>(c<span style=color:#ff79c6>-&gt;</span>querybuf_peak<span style=color:#ff79c6>+</span><span style=color:#bd93f9>1</span>)) <span style=color:#ff79c6>&gt;</span> <span style=color:#bd93f9>2</span>) <span style=color:#ff79c6>||</span>
         (querybuf_size <span style=color:#ff79c6>&gt;</span> <span style=color:#bd93f9>1024</span> <span style=color:#ff79c6>&amp;&amp;</span> idletime <span style=color:#ff79c6>&gt;</span> <span style=color:#bd93f9>2</span>))
    {
        <span style=color:#6272a4>/* Only resize the query buffer if it is actually wasting space. */</span>
        <span style=color:#ff79c6>if</span> (sdsavail(c<span style=color:#ff79c6>-&gt;</span>querybuf) <span style=color:#ff79c6>&gt;</span> <span style=color:#bd93f9>1024</span>) {
            c<span style=color:#ff79c6>-&gt;</span>querybuf <span style=color:#ff79c6>=</span> sdsRemoveFreeSpace(c<span style=color:#ff79c6>-&gt;</span>querybuf);
        }
    }
    <span style=color:#6272a4>/* Reset the peak again to capture the peak memory usage in the next
</span><span style=color:#6272a4>     * cycle. */</span>
    c<span style=color:#ff79c6>-&gt;</span>querybuf_peak <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>0</span>;
    <span style=color:#ff79c6>return</span> <span style=color:#bd93f9>0</span>;
}
</code></pre></div><h4 id=二进制安全>二进制安全<a hidden class=anchor aria-hidden=true href=#二进制安全>#</a></h4><p>SDS API都会以处理二进制的方式来处理SDS存放在buf数组里的数据（如不以"\0"当作字符串结尾），程序不会对其中的数据做任何限制、过滤、或者假设，数据在写入时是什么样的，他被读取时就是什么样子。因此Redis可以不仅可以保存文本数据，还可以保存图片、音频、视频、压缩文件这样的二进制数据。</p><h4 id=sds-api>SDS API<a hidden class=anchor aria-hidden=true href=#sds-api>#</a></h4><p><img loading=lazy src=https://img.aladdinding.cn/sdsapi.png alt></p></div><footer class=post-footer><ul class=post-tags><li><a href=https://aladdinding.cn/tags/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/>源码阅读</a></li></ul><nav class=paginav><a class=next href=https://aladdinding.cn/2021/11/%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E9%80%82%E7%94%A8HugoHexo/><span class=title>下一页 »</span><br><span>静态博客部署的最佳实践（适用Hugo、Hexo）</span></a></nav></footer><div class="post bg-white"><script src=https://utteranc.es/client.js repo=aladdinding/aladdinding.github.io issue-term=title theme=github-light crossorigin=anonymous async></script></div></article></main><footer class=footer><span>&copy; 2021 <a href=https://aladdinding.cn/>阿拉丁的博客</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span>
<span><a href=https://beian.miit.gov.cn/ rel="noopener noreferrer" target=_blank>鄂ICP备2021016339号-1</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)"><button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></button></a>
<script>let menu=document.getElementById('menu');menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)},document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script><script>document.querySelectorAll('pre > code').forEach(b=>{const c=b.parentNode.parentNode,a=document.createElement('button');a.classList.add('copy-code'),a.innerText='复制';function d(){a.innerText='已复制！',setTimeout(()=>{a.innerText='复制'},2e3)}a.addEventListener('click',e=>{if('clipboard'in navigator){navigator.clipboard.writeText(b.textContent),d();return}const a=document.createRange();a.selectNodeContents(b);const c=window.getSelection();c.removeAllRanges(),c.addRange(a);try{document.execCommand('copy'),d()}catch(a){}c.removeRange(a)}),c.classList.contains("highlight")?c.appendChild(a):c.parentNode.firstChild==c||(b.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?b.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(a):b.parentNode.appendChild(a))})</script></body></html>