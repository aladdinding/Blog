[{"content":" JIRA是Atlassian公司出品的项目与事务跟踪工具，被广泛应用于缺陷跟踪、客户服务、需求收集、流程审批、任务跟踪、项目跟踪和敏捷管理等工作领域。\nConfluence是一个专业的企业知识管理与协同软件，也可以用于构建企业wiki。使用简单，但它强大的编辑和站点管理特征能够帮助团队成员之间共享信息、文档协作、集体讨论，信息推送\n 数据库设置 首先是不建议将数据库部署在Docker容器，建议使用云数据库或者物理机部署。下文以Mysql5.7为例\nconfluence 文档 Confluence Data Center and Server documentation\nDatabase Configuration\n数据库设置 选择安装的Confluence版本，阅读Database Setup For MySQL后，修改Mysql配置文件\n以Confluence 7.12为例\n[mysqld] ... character-set-server=utf8mb4 collation-server=utf8mb4_bin default-storage-engine=INNODB max_allowed_packet=256M innodb_log_file_size=2GB transaction-isolation=READ-COMMITTED binlog_format=row log-bin-trust-function-creators = 1 // 如果为Mysql5.7，关闭derived_merge能优化仪表板加载缓慢 optimizer_switch = derived_merge=off ... 如果sql_mode = NO_AUTO_VALUE_ON_ZERO，请删除此选项\n创建数据库\u0026amp;用户 Confluence数据库\nCREATE DATABASE \u0026lt;database-name\u0026gt; CHARACTER SET utf8mb4 COLLATE utf8mb4_bin; Confluence数据库用户\nGRANT ALL PRIVILEGES ON \u0026lt;database-name\u0026gt;.* TO \u0026#39;\u0026lt;confluenceuser\u0026gt;\u0026#39;@\u0026#39;localhost\u0026#39; IDENTIFIED BY \u0026#39;\u0026lt;password\u0026gt;\u0026#39;; 如果 Confluence 与数据库不在同一台服务器上运行（或者是Docker用户），请用 Confluence 服务器的主机名或 IP 地址替换 localhost（也可以使用%，表示允许所有host）。\nJira 文档 Jira Software Data Center and Server documentation\nConnecting Jira applications to a database\n数据库设置 选择安装的Jira版本，阅读Connecting Jira applications to MySQL 5.7后，修改Mysql配置文件\n以Jira 8.18为例\n[mysqld] ... character-set-server=utf8mb4 collation-server=utf8mb4_bin default-storage-engine=INNODB innodb_file_format=Barracuda nodb_default_row_format=DYNAMIC innodb_large_prefix=ON innodb_log_file_size=2G ... 如果sql_mode = NO_AUTO_VALUE_ON_ZERO，请删除此选项\n创建数据库\u0026amp;用户 同上Confluence创建数据库\u0026amp;用户，不再赘述\nDocker Compose 文档 atlassian/confluence-server\natlassian/jira-software\natlassian-agent\ndocker-compose.yml 已上传Github：aladdinding/Confluence-and-Jira\nversion: \u0026#39;3\u0026#39; services: confluence: image: \u0026#34;atlassian/confluence-server\u0026#34; volumes: - ./atlassian-agent.jar:/tmp/atlassian-agent.jar - /data/your-confluence-home:/var/atlassian/application-data/confluence environment: JAVA_OPTS: \u0026#34;-javaagent:/tmp/atlassian-agent.jar ${JAVA_OPTS}\u0026#34; ports: - \u0026#34;8090:8090\u0026#34; restart: always jira: image: \u0026#34;atlassian/jira-software\u0026#34; volumes: - ./atlassian-agent.jar:/tmp/atlassian-agent.jar - /data/your-jira-home:/var/atlassian/application-data/jira environment: JAVA_OPTS: \u0026#34;-javaagent:/tmp/atlassian-agent.jar ${JAVA_OPTS}\u0026#34; ports: - \u0026#34;8080:8080\u0026#34; restart: always 初始化 插件破解 配置Confluence与Jira用户数据对接 异常记录 ","permalink":"https://aladdinding.cn/2021/07/Docker%E9%83%A8%E7%BD%B2%E5%B9%B6%E7%A0%B4%E8%A7%A3JiraConfluence%E5%8F%8A%E6%8F%92%E4%BB%B6/","summary":"JIRA是Atlassian公司出品的项目与事务跟踪工具，被广泛应用于缺陷跟踪、客户服务、需求收集、流程审批、任务跟踪、项目跟踪和敏捷管理等工作领域。 Confluence是一个专业的企业知识管理与协同软件，也可以用于构建企业wiki。使用简单，但它强大的编辑和站点管理特征能够帮助","title":"Docker部署并破解Jira、Confluence及插件"},{"content":"时间复杂度 算法的执行时间与算法输入值之间的的关系，即算法的执行效率\n大O表示法  用常数 1 取代运行时间中的所有加法常数。 在修改后的运行次数函数中，只保留最高阶项。 如果最高阶项存在且不是 1，则去除与这个项相乘的常数。得到的结果就是大 O 阶  常见时间复杂度 O(1) 常数阶 def O1(num): i = num j = num*2 return i + j O(logn) 对数阶 def OlogN(num): i = 1 while (i \u0026lt; num): i = i * 2 return i O(n) 线性阶 def ON(num): total = 0 for i in range(num): total += i return total O(nlogn) nlogn阶 def ONlogN(num): total = 0 for i in range(num): j = 1 while (j \u0026lt; num): total += i+j j = j * 2 return total O(n^2) 平方阶 def ON2(num): total = 0 for i in range(num): for j in range(num): total += i+j return total 对比 常用时间复杂度所耗费的时间从小到大依次是：\nO(1) \u0026lt; O(logn) \u0026lt; O(n) \u0026lt; O(nlogn) \u0026lt; O(n^2) \u0026lt; O(n^3) \u0026lt; O(n!) \u0026lt; O(n^n)\n相关文档：Big-O Cheat Sheet\n空间复杂度 算法的存储空间与输入值之间的关系，表示方法同样也为大O表示法\n常见时间复杂度 O(1) 常数阶 def O1(num): total = 0 for i in range(num): total += i return total O(n) 线性阶 def ON(nums) array = [] for num in nums: array.append(num) return array 如何计算  变量：常量时为O(1），数组、列表则可能是O(n)、O(n^2) 递归：递归栈O(n)  最坏情况与平均情况 最坏情况运行时间是一种保证，那就是运行时间不会再长了。在应用中，这是一种最重要的需求，通常，除非特别指定，我们提到的运行时间都是最坏情况的运行时间。平均运行时间是所有情况中最有意义的，因为它是期望的运行时间。一般没有特殊说明的情况下，时间复杂度都是指最坏时间复杂度。\n如何衡量时间/空间复杂度  时间和空间复杂度只能二选一 牺牲时间换空间 牺牲空间换时间 通常是优先选择时间复杂度更好的  ","permalink":"https://aladdinding.cn/2021/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%B6%E9%97%B4%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/","summary":"时间复杂度 算法的执行时间与算法输入值之间的的关系，即算法的执行效率 大O表示法 用常数 1 取代运行时间中的所有加法常数。 在修改后的运行次数函数中，只保留最高阶项。 如果最高阶项存在且不是 1，则去除与这个项相乘的常数。得到的结果就是大 O 阶 常见时间复杂度 O(1) 常数阶 def O1(num): i = num j = num*2 return i + j O(logn) 对数","title":"数据结构与算法之时间、空间复杂度"},{"content":"安装iTerm2 使用iTerm2替代macOS自带终端Terminal\nHome\u0026amp;Download：https://iterm2.com/\n安装iTerm2主题 This is a set of color schemes for iTerm (aka iTerm2).\nGithub：https://github.com/mbadolato/iTerm2-Color-Schemes\nExample:\n Dracula iterm2-material-design  安装/升级zsh # https://github.com/robbyrussell/oh-my-zsh brew install zsh # The installation script should set zsh to your default shell, but if it doesn\u0026#39;t you can do it manually: chsh -s $(which zsh) 安装 oh-my-zsh Oh My Zsh is a delightful, open source, community-driven framework for managing your Zsh configuration.\nHome：https://ohmyz.sh/\nGithub：https://github.com/ohmyzsh/ohmyzsh\n# Install oh-my-zsh $ sh -c \u0026#34;$(curl -fsSL https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh)\u0026#34; 安装 zplug 插件管理器 Github：https://github.com/zplug/zplug\n$ curl -sL --proto-redir -all,https https://raw.githubusercontent.com/zplug/installer/master/installer.zsh | zsh 安装命令行工具 brew install fzf # To install useful key bindings and fuzzy completion: $(brew --prefix)/opt/fzf/install brew install autojump fzf 命令行模糊搜索\nGithub：https://github.com/junegunn/fzf\nautojump 记录常用目录，不需要输入目录详细路径，j加目录名关键字即可\n❯ j github. . ~/aladdinding.github.io main* 修改.zshrc # User configuration # export MANPATH=\u0026#34;/usr/local/man:$MANPATH\u0026#34; # You may need to manually set your language environment # export LANG=en_US.UTF-8 # Preferred editor for local and remote sessions # if [[ -n $SSH_CONNECTION ]]; then # export EDITOR=\u0026#39;vim\u0026#39; # else # export EDITOR=\u0026#39;mvim\u0026#39; # fi # Compilation flags # export ARCHFLAGS=\u0026#34;-arch x86_64\u0026#34; # Set personal aliases, overriding those provided by oh-my-zsh libs, # plugins, and themes. Aliases can be placed here, though oh-my-zsh # users are encouraged to define aliases within the ZSH_CUSTOM folder. # For a full list of active aliases, run `alias`. # # Example aliases # alias zshconfig=\u0026#34;mate ~/.zshrc\u0026#34; # alias ohmyzsh=\u0026#34;mate ~/.oh-my-zsh\u0026#34; # autojump config, brew install autojump [[ -s `brew --prefix`/etc/autojump.sh ]] \u0026amp;\u0026amp; . `brew --prefix`/etc/autojump.sh [ -s \u0026#34;$NVM_DIR/bash_completion\u0026#34; ] \u0026amp;\u0026amp; \\. \u0026#34;$NVM_DIR/bash_completion\u0026#34; # This loads nvm bash_completion # install zplug, plugin manager for zsh, https://github.com/zplug/zplug # curl -sL --proto-redir -all,https https://raw.githubusercontent.com/zplug/installer/master/installer.zsh | zsh # zplug configruation if [[ ! -d \u0026#34;${ZPLUG_HOME}\u0026#34; ]]; then if [[ ! -d ~/.zplug ]]; then git clone https://github.com/zplug/zplug ~/.zplug # If we can\u0026#39;t get zplug, it\u0026#39;ll be a very sobering shell experience. To at # least complete the sourcing of this file, we\u0026#39;ll define an always-false # returning zplug function. if [[ $? != 0 ]]; then function zplug() { return 1 } fi fi export ZPLUG_HOME=~/.zplug fi if [[ -d \u0026#34;${ZPLUG_HOME}\u0026#34; ]]; then source \u0026#34;${ZPLUG_HOME}/init.zsh\u0026#34; fi zplug \u0026#39;plugins/git\u0026#39;, from:oh-my-zsh, if:\u0026#39;which git\u0026#39; zplug \u0026#39;romkatv/powerlevel10k\u0026#39;, use:powerlevel10k.zsh-theme zplug \u0026#34;plugins/vi-mode\u0026#34;, from:oh-my-zsh zplug \u0026#39;zsh-users/zsh-autosuggestions\u0026#39; zplug \u0026#39;zsh-users/zsh-completions\u0026#39;, defer:2 zplug \u0026#39;zsh-users/zsh-history-substring-search\u0026#39; zplug \u0026#39;zsh-users/zsh-syntax-highlighting\u0026#39;, defer:2 if ! zplug check; then zplug install fi zplug load # NOTE: use cc to clear screen. I use tmux ctrl+hjkl switch panel, but ctrl+l conflict with clear-screen #bindkey \u0026#34;cc\u0026#34; clear-screen # customize alias [ -f ~/.alias ] \u0026amp;\u0026amp; source ~/.alias # To customize prompt, run `p10k configure` or edit ~/.p10k.zsh. [[ ! -f ~/.p10k.zsh ]] || source ~/.p10k.zsh # fzf config, must brew install fzf # NOTE: put this line in the end of your zshrc, or it may not work, https://github.com/junegunn/fzf/issues/1304 [ -f ~/.fzf.zsh ] \u0026amp;\u0026amp; source ~/.fzf.zsh 关于字体 在配置powerlevel10k主题时若缺少字体会提示下载，当然你也可以自行安装\n Best option if on macOS and want to use Homebrew.\n All fonts are available via Homebrew Cask Fonts on macOS (OS X)\nbrew tap homebrew/cask-fonts brew install --cask font-hack-nerd-font iTerm2 -\u0026gt; Preferences -\u0026gt; Profiles -\u0026gt; Text -\u0026gt; Non-Ascii-Font -\u0026gt; nerd-font -\u0026gt; restart iTerm2\n","permalink":"https://aladdinding.cn/2021/06/macOS%E7%BB%88%E7%AB%AF%E9%85%8D%E7%BD%AE%E8%AE%B0%E5%BD%95/","summary":"macOS终端环境快速配置","title":"MacOS终端配置记录"},{"content":"2021年5月23日\n起床，瞬间感觉腰疼的不行。\n上午辗转反侧，坐立难安，最后还是顶不住去了医院。\n十几年没去过医院了，印象中的挂号，买病例都没有了。\n取而代之的是全流程手机操作，很快熟悉。\n不过这个医院体验太差\n 没有饮用水提供 拍片子的人经常消失 工作人员玩手机  结果出来了，肾结石（很小，不是很严重，但是疼起来要命）。\n多半原因是自己平时不爱运动，喝水也少。\n最后还因为医院用不了电子社保卡，在医院被任人宰割。\n总之，这次看病算是给自己敲响一个警钟。\n平时一定要多喝水！！！\n多运动！！！\n身体才是革命的本钱！！！！！！\n","permalink":"https://aladdinding.cn/2021/05/%E4%B8%80%E6%AC%A1%E4%BD%8E%E4%BA%8E%E9%A2%84%E6%9C%9F%E7%9A%84%E5%B0%B1%E5%8C%BB%E4%BD%93%E9%AA%8C/","summary":"2021年5月23日 起床，瞬间感觉腰疼的不行。 上午辗转反侧，坐立难安，最后还是顶不住去了医院。 十几年没去过医院了，印象中的挂号，买病例都没有了。 取而代之的是全流程手机操作，很快熟悉。 不过这个医院体验太差 没有饮用水提供 拍片子的人经常消失 工作人员玩手机 结果出来了，肾结石（很小，不是很","title":"一次低于预期的就医体验"},{"content":"说到HTTPS协议，很多人想到的是配置各种复杂的证书。其实不然，可以说大多数代理能够支持https都是通过http协议中的Web隧道（也有叫做HTTP隧道）功能来实现的。\nWeb隧道 Web隧道允许用户通过HTTP连接发送非HTTP流量（例如FTP，Telnet，SMTP），这样就可以在HTTP上携带其他协议数据了。使用Web隧道最常见的原因就是要在HTTP链接中嵌入非HTTP流量。我们知道很多软件都是实现了自己的应用层协议，但是这些软件都支持设置代理，如QQ，微信。\nWeb隧道是用HTTP的CONNECT方法建立起来的。CONNECT方法并不是HTTP/1.1 核心规范的一部分，但却是一种得到广泛应用的扩展。CONNECT方法请求隧道网关创建一条到达任意目的服务器和端口的 TCP 连接，并对客户端和服务器之间的后继数据进行盲转发。下面截取《HTTP权威指南》配图，讲讲CONNECT方法如何建立一条Web隧道。\n 客户端首先发送了一条CONNECT请求给代理服务器。 代理服务器收到了CONNECT请求，解析出报文中客户端希望访问的域名及端口号，然后向目标服务器进行TCP连接。（图中是到打开到主机orders.joes-hardware.com 的标准 SSL 端口 443 的连接） 代理服务器一旦和目标网站建立了TCP连接，就发送一条HTTP 200 Connection Established的响应来通知客户端Web隧道建立成功，可以发送数据了。 此时客户端通过Web隧道发送的所有数据都会被代理服务器直接转发给目标网站。（如果是HTTPS协议则是各种SSL握手信息，加密后的HTTP报文）  客户端只有收到200 Connection Established才会继续发送数据。如果代理服务器和目标网站连接不成功怎么办呢？代理服务器可以自己灵活自定义：连接目标网站失败502 Bad Gateway、代理认证未通过407 Proxy Authentication Required等等。\nCONNECT请求 除了起始行之外，CONNECT 的语法与其他 HTTP 方法类似，只不过是主机名和端口号取代了URI。其中主机和端口都必须指定，不然代理服务器就不清楚与谁建立连接了。\nCONNECT home.netscape.com:443 HTTP/1.0 User-Agent: Mozilla/4.0 CONNECT请求的header通常只会携带建立Web隧道所需要的信息，而不包含需要传输的请求信息。\n常见的CONNECT请求header：\n User-Agent：用户设备 Proxy-Authorization：认证信息 Proxy-Connection：是否支持长连接  CONNECT响应 发送了请求之后，客户端会等待来自网关的响应。和普通 HTTP 报文一样，响应码200 表示成功。按照惯例，响应中的原因短语通常被设置为“Connection Established”。\nHTTP/1.0 200 Connection Established Proxy-Agent: Netscape-Proxy/1.1 与普通 HTTP 响应不同，这个响应并不需要包含 Content-Type 首部。此时连接只是对原始字节进行转接，不再是报文的承载者，所以不需要使用内容类型了。\n不止HTTPS 正因为有了Web隧道，代理服务器不需要其他应用层协议进行额外的编码解析，只要Web隧道建立成功之后即可发送任何非HTTP流量。\nwebsocket 在Python的websocket-client框架中，如果使用http代理，首先会对代理发送CONNECT连接建立Web隧道，然后在传输ws、wss协议数据\ndef _tunnel(sock, host, port, auth): debug(\u0026#34;Connecting proxy...\u0026#34;) connect_header = \u0026#34;CONNECT %s:%dHTTP/1.1\\r\\n\u0026#34; % (host, port) connect_header += \u0026#34;Host: %s:%d\\r\\n\u0026#34; % (host, port) # TODO: support digest auth. if auth and auth[0]: auth_str = auth[0] if auth[1]: auth_str += \u0026#34;:\u0026#34; + auth[1] encoded_str = base64encode(auth_str.encode()).strip().decode().replace(\u0026#39;\\n\u0026#39;, \u0026#39;\u0026#39;) connect_header += \u0026#34;Proxy-Authorization: Basic %s\\r\\n\u0026#34; % encoded_str connect_header += \u0026#34;\\r\\n\u0026#34; dump(\u0026#34;request header\u0026#34;, connect_header) send(sock, connect_header) try: status, resp_headers, status_message = read_headers(sock) except Exception as e: raise WebSocketProxyException(str(e)) if status != 200: raise WebSocketProxyException( \u0026#34;failed CONNECT via proxy status: %r\u0026#34; % status) return sock 非Web隧道 当然，也有的代理服务器能够在不建立Web隧道的情况下，实现了对其他应用层协议的解析，从而实现代理转发的目的。\n例如HTTPS协议，客户端首先和代理服务器进行代理服务器完成SSL握手，代理服务器获取到客户端发送的完整请求（明文），然后在和目标主机进行SSL握手，成功后转发用户的请求。最后还要确定使用的HTTP客户端是否支持连接HTTPS代理，因为绝大多数应用层协议客户端都是通过Web隧道使用代理。\n在Python的HTTP客户端框架urllib3的1.26.0版本中才添加了对HTPPS代理连接的支持。\n Added support for HTTPS proxies contacting HTTPS servers (Pull #1923, Pull #1806)  proxies = { \u0026#39;http\u0026#39;: \u0026#39;http://proxy_ip:port\u0026#39;, # http请求 \u0026#39;https\u0026#39;: \u0026#39;http://proxy_ip:port\u0026#39;, # CONNECT请求 \u0026#39;https\u0026#39;: \u0026#39;https://proxy_ip:port\u0026#39; # 与proxy进行ssl } ","permalink":"https://aladdinding.cn/2021/05/%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%A6%82%E4%BD%95%E6%94%AF%E6%8C%81HTTPS/","summary":"说到HTTPS协议，很多人想到的是配置各种复杂的证书。其实不然，可以说大多数代理能够支持https都是通过http协议中的Web隧道（也有叫做HTTP隧道）功能来实现的。 Web隧道 Web隧道允许用户通过HTTP连接发送非HTTP流量（例如FTP，Telnet，SMTP），这样就可","title":"代理服务器如何支持HTTPS"},{"content":"官方 macOS最新系统：https://www.apple.com.cn/macos\nmacOS支持：https://support.apple.com/zh-cn/macos\n制作macOS 安装器：https://support.apple.com/zh-cn/HT201372\nmacOS使用手册：https://support.apple.com/zh-cn/guide/mac-help/welcome/mac\n序列号查询：https://checkcoverage.apple.com/cn/zh/\n软件下载 MacWk：https://macwk.com/\n马可菠萝：https://www.macbl.com/\n瓜子云盘：https://yun.naodai.org/Software\nappstorrent：https://www.appstorrent.ru/\nXclient：https://xclient.info/\n麦氪搜：https://www.imacso.com/\nGithub：https://github.com/search?q=macos\n兼容检测 Arm芯片兼容：https://isapplesiliconready.com/zh\n","permalink":"https://aladdinding.cn/2021/03/macOS%E7%9B%B8%E5%85%B3%E8%B5%84%E6%BA%90%E5%90%88%E9%9B%86/","summary":"macOS相关资源整理","title":"MacOS相关资源合集"},{"content":"墙的原理 在讨论vpn、Proxy这些之前，有必要先提一下目前主流防火墙的实现原理。GFW实现网络封锁的手段主要有两种：dns劫持和ip封锁（除此之外，还有dns污染和关键词过滤，这里我们不讨论）。\nDns劫持 ip是网络上各主机的“地址”，要想访问“别人家”，当然得要有地址。但ip是一串数字，是给电脑看的，人记起来太麻烦，所以就有了域名（也就是我们常说的网址）和dns（网域名称系统，Domain Name System）。\n域名是一串英文字符串，方便人记忆。dns将域名和ip关联起来，形成映射。用户访问域名所在的目标网站前，将域名发给dns服务器询问这对映射关系，拿到对应的ip后就可以在茫茫网海中找到那个“她”了。而GFW所做的就是站在用户和dns服务器之间，破坏它们的正常通讯，并向用户回传一个假ip。用户拿不到真正的ip，自然也就访问不到本想访问的网站了。\nDns劫持是GFW早期唯一的技术手段，所以那个时候的用户通过修改Hosts文件的方式就可以零成本突破封锁了。\nip封锁 dns劫持之后，GFW引入了ip封锁，直接锁住了访问目标网站的去路，用户发往被封锁ip的任何数据都会被墙截断。\n这个时候，依靠类似于修改Hosts文件这种低成本方法突破封锁就显得有些天方夜谭了。那么，解决办法是什么呢？答案是：在第三方架设翻墙服务器，中转与目标服务器间的来往流量。目前为止，GFW采用的是黑名单模式，像Google、Facebook这种在黑名单上的网站的ip无法访问，而不在黑名单上的第三方不记名ip可以。\n于是，一切就很明朗了，我们目前几乎所有的翻墙手段都是基于上述原理实现的。vpn是，shadowsocks是，还有一些比较冷门的（比如v2ray）同样如此，只不过它们的技术细节不同（这个我们不会深入）。\nVPN VPN，全称“虚拟私人网络（Virtual Private Network）”或者是“虚拟专用网络”，是一种加密通讯技术。vpn是一个统称，它有很多的具体实现，比如PPTP、L2TP/IPSec等。\nvpn最常用的场景就是在外网的小伙伴（如酒店网络，家庭WIFI等等）访问公司内部的网络使用，如果不使用vpn，直接连入公司内网，则数据明文在外网中传输会有被窃听的风险。vpn是一种加密通讯技术，它被设计出来的目的是数据传输安全和网络匿名。\nvpn出现远早于GFW，所以它不是为了翻墙而生的。而既然不是为翻墙而生，那从翻墙的角度上讲，vpn协议就存在诸多问题。使用VPN，不足之处在于数据分流不灵活，会将开启了VPN的设备的所有数据流量全部导向至VPN服务器上；另外如果VPN服务器上有流量监视软件运行，那么用户所传输的数据将有信息安全威胁；进一步来说，由于VPN设计的初衷并不是用于翻墙，因此数据流量的特征非常明显，容易引起审查机构注意，导致被封。\n所以，VPN这种翻墙方式基本已经没落了。但即便如此，vpn作为过去很长一段时间最主流最热门最常用最为人所知的翻墙手段，已然成为翻墙的代名词。即便是vpn已不再常用的今天，当人们谈及翻墙的时候，说得最多的仍是：“你有什么好用的vpn吗？”。\nProxy（代理） Proxy（代理）又分为正向代理和反向代理。\n正向代理 翻墙所用的代理都是正向代理。正向代理主要有HTTP、HTTP over TLS(HTTPS)、Socks、Socks over TLS几种。其中，HTTP和Socks无法用于翻墙，HTTPS和Socks over TLS可以用于翻墙。不过，Socks over TLS几乎没人用，我们这里就不多说了。\nProxy的历史同样早于GFW，它最早被设计出来的目的当然也不是翻墙。正向代理最主要的目的和vpn差不多，都是用于匿名，但HTTP和Socks不能加密，只能匿名，HTTPS既可以匿名，也可以用于加密通信。\n从理论上讲，四种代理协议都可以通过“用户先将数据发给代理服务器，再由代理服务器转发给目的服务器”的方法达到翻墙目的。但由于HTTP和Socks都是明文协议，GFW可以通过检查数据包内的内容得知用户的真实意图，进而拦截数据包。所以，HTTP和Socks一般只用作本地代理。而HTTPS协议是加密通讯，GFW无法得知数据包内的真实内容，类似于关键词过滤的手段无法施展。不仅如此，HTTPS代理的流量特征和我们平时访问网站时所产生的HTTPS流量几乎一模一样，GFW无法分辨，稳定性爆表。理论上讲，HTTPS代理无论是安全性，还是在隐匿性，都要比目前最为流行的shadowsocks好。\n事实上，在所有已知的翻墙协议中，无论是vpn协议，还是代理协议，它应该都是最好的。v2ray的vmess over tls也许能和HTTPS代理媲美。但v2ray存在的时间较短、使用者较少、社区也没有HTTPS代理活跃（从全球范围上看），故而，相比于HTTPS代理，vmess协议潜在的安全漏洞可能要多。\n当然，HTTPS代理也有它的缺点，其中最大的缺点就是配置复杂。即便能用默认参数就用默认参数，用户自己只作最低限度的配置，对新手而言，这也是一个无比痛苦的过程。更别说，想要正常使用HTTPS代理，你还要购买域名和证书这些，非常麻烦。所以，即便是在shadowsocks出现之前，HTTPS代理也没在大陆流行起来。这也是造成v2ray的小众的主要原因之一（另一个是用户没有从shadowsocks迁移到v2ray的动力），它的配置同样相当复杂。除此之外，HTTPS代理只能转发tcp流量，对udp无能为力。 这里推荐刘亚晨先生的一篇文章「各种加密代理协议的简单对比」。\n反向代理 反向代理的作用主要是为服务器做缓存和负载均衡。这里不做过多讨论，感兴趣的朋友可以看这里。顺带一提，shadowsocks里也有负载均衡的概念，但shadowsocks的负载均衡和反向代理的负载均衡不是一个概念。\n反向代理的负载均衡是指：在多个真正的服务器前架设一个代理服务器，用户所有的数据都发给代理服务器，然后代理服务器根据各个真实服务器的状态将数据转发给一个任务较少的服务器处理。这样，服务商既可以架设多个服务器分担任务、减轻压力，用户也只要记一个域名或ip就可以了。\n而shadowsocks的负载均衡是指：每隔一段时间更改一次翻墙服务器，将用户的数据平均发给多个不同的翻墙服务器，以避免发往某一个翻墙服务器的流量过多。\nshadowsocks 最后，就是我们的shadowsocks闪亮登场了。介绍之前，我这里先附上shadowsocks的官网链接。英文比较好的同学建议看看官网上对shadowsocks的介绍。\n在shadowsocks之前，墙内网民主要依靠寻找现成的技术实现翻墙。比如vpn、HTTPS、tor的中继网桥以及之后的meek插件等等，虽然也有自己的技术，比如一种依靠Google隐藏ip实现翻墙的技术（名字忘了）,但毕竟难成大器，再加上GFW逐渐加大对VPN的干扰，人们迫切需要一种简单可靠的技术来抵御GFW的进攻。\n于是，大概是在2013年吧（具体时间我也不太清楚），@clowwindy带着他的shadowsocks横空出世。Shadowsocks同样是一种代理协议，但是作为clowwindy为国人设计的专门用于翻墙的代理协议，相对于vpn，shadowsocks有着极强的隐匿性；相对于HTTP代理，shadowsocks提供了较为完善的加密方案，虽然比不上HTTPS代理和vpn，但使用的也是成熟的工业级的加密算法，普通个人用户完全不用顾虑；相对于HTTPS代理，shadowsocks的安装配置更为简单，中文社区更为活跃，中文文档教程更完善，更符合中国国情。\nShdadowsocks最初的版本是由clowwindy使用Python（一种目前非常热门的脚本编程语言）实现的。所以clowwindy的版本被称为Python版。shadowsocks有点名气之后，不同的开发者使用不同的编程语言为其写了很多分支版本。比如，@cyfdecyf开发维护的Go版本，@madeye开发维护的libev版本（由纯C语言编写，基于libev库开发），由@librehat开发维护的c++版，由@zhou0开发维护的Perl版。这些版本的安装使用指南都可以在shadowsocks的官网上查阅。\n2015年，clowwindy因喝茶事件被迫停止了shadowsocks的维护，并删除了其开源在GitHub上的代码，Python版就此停滞。但其它版本仍处于维护更新中。其中，更新最频繁，新技术跟进最快的是由@madeye维护的libev版本。这里有必要说明下，目前，shadowsocks协议（请区分“shadowsocks协议”和“shadowsocks协议的具体实现”这两者的区别）是由shadowsocks社区内的成员共同维护，协议上任何新改进都是社区成员共同商讨的结果。但对这些变化，不同的版本的shadowsocks跟进速度不同。而跟进速度最快的就是我上面说的libev版。无论是SIP007确认的ADEA Ciphers（一种同时进行认证和加密的算法），还是SIP003引进的simple-obfs（tor开发的一种混淆插件），shadowsocks-libev都是最早引入自己软件的。\nshadowsocks是c/s架构，shadowsocks的客户端则就是百花齐放了，有我们现在用的小飞机（Shadowsocks），ClashX，移动端等等。\n机场 随着GFW的不断升级，其实shadowsocks流量也会被检测出来，导致部署shadowsocks的服务器IP被封禁。其实shadowsocks还只是众多科学上网协议中的一种，其实还有ssr（ShadowsocksR），v2ray（改善了shadowsocks的一些缺点，更难被GFW检测到，不过配置复杂），Trojan（上文提到过，模仿https流量，隐蔽性更强）。\n由于自己购买国外的vps部署的协议随着GFW的不断升级是有可能被识别到导致封IP的，如果vps提供商不支持更换IP，那么你这台vps就浪费了。如果不想被封就需要不断学习新的隐蔽性更好的协议，所以对于个人用户来说，学习成本很高。\n这时候，机场服务就应运而生，只需要少量的付费，通过一条订阅就可以拿到上百条支持各种协议的线路，即使是那个节点被封，那随便切换一条就行。如今对于普通用户来说，机场已经成为了最多的科学上网方式。\n总结  vpn是是一种加密通讯技术，它的核心技术是在加密，防窃听上。由于GFW刚上的时候vpn这项技术成熟，vpn被迫营业，充当起了第一代翻墙手段。 shadowsocks闪亮登场，有着很强的隐蔽性，配置简单 GFW不断升级，更多的隐蔽性强的协议v2ray，Trojan 机场服务，通过订阅拿到上百条线路，并且协议齐全，如果你不太想折腾并且不追求极致，机场服务是个不错的选择。  参考  https://github.com/sxcool1024/freedom https://github.com/shadowsocks  ","permalink":"https://aladdinding.cn/2021/03/%E6%B5%85%E8%B0%88vpnproxyshadowsocks%E6%9C%BA%E5%9C%BA%E4%B9%8B%E9%97%B4%E7%9A%84%E8%81%94%E7%B3%BB%E5%92%8C%E5%8C%BA%E5%88%AB/","summary":"墙的原理 在讨论vpn、Proxy这些之前，有必要先提一下目前主流防火墙的实现原理。GFW实现网络封锁的手段主要有两种：dns劫持和ip封锁（除此之外，还有dns污染和关键词过滤，这里我们不讨论）。 Dns劫持 ip是网络上各主机的“地址”，要想访问“别人家”，当然得要有地址。但ip是","title":"浅谈vpn、proxy、shadowsocks、机场之间的联系和区别"},{"content":"终端快捷键 快捷键应该是每一个需要和终端天天打交道的程序员必备的技能了，如果你还停留在每次前后左右一个字符一个字符移动光标的话，那你需要好好学习下面的终端快捷键，这可以大大提高你的效率\n最常用  tab 命令或路径的补全键  移动光标  Ctrl + a/Home 切换到命令行开始 Ctrl + e/End 切换到命令行末尾 Ctrl + f 光标向右移动一个字符（相当于方向键右键） Ctrl + b 光标向右移动一个字符（相当于方向键左键）  剪切、粘贴、清除  Ctrl + l 清除屏幕内容，效果等同于clear命令 Ctrl + u 清除剪切光标之前的内容 Ctrl + k 剪切清除光标之后的内容 Ctrl + y 粘贴刚才所删除的字符 Ctrl + w 剪切光标所在处之前的一个词（以空格、标点等为分隔符） Ctrl + h 删除光标所在处的前一个字符（相当于退格键） Ctrl + t 颠倒光标所在处及其之前的字符位置，并将光标移动到下一个字符 Alt + t 交换当前与以前单词的位置 Alt + d 剪切光标之后的词  控制快捷键  Ctrl + c 终止命令 Ctrl + s 锁住终端 Ctrl + q 解锁终端 Ctrl + z 转入后台运行,但在当前用户退出后就会终止 Ctrl + d 退出 shell，logout Ctrl +（x u） 按住 Ctrl 的同时再先后按 x 和 u，撤销刚才的操作  重复执行命令、查找历史命令  Ctrl + o 重复执行命令 Ctrl + r 在历史命令中查找 （这个非常好用，输入关键字就调出以前的命令了） history 显示你所有执行过的编号+历史命令。这个可以配合!n（n是编号）来执行某某历史命令 !! 重复执行最后一条命令(有四种方法)  使用上方向键，并回车执行。 按 !! 并回车执行。 输入 !-1 并回车执行。 按 Ctrl+P 并回车执行。   !$ 显示系统最近的一条参数（最后这个比较有用，比如我先用 cat /etc/hosts，然后我想用 vim 编辑。 一般的做法是先用↑ 显示最后一条命令，然后用 Home 移动到命令最前，删除 cat，然后再输入 vim 命 令。其实完全可以用 vim !$来代替） cd - 回到前一个工作路径  推荐文档 熟练使用命令行是一种常常被忽视，或被认为难以掌握的技能，但实际上，它会提高你作为工程师的灵活性以及生产力。本文是一份我在 Linux 上工作时，发现的一些命令行使用技巧的摘要。有些技巧非常基础，而另一些则相当复杂，甚至晦涩难懂。这篇文章并不长，但当你能够熟练掌握这里列出的所有技巧时，你就学会了很多关于命令行的东西了。\n《命令行的艺术》\n","permalink":"https://aladdinding.cn/2020/08/Linux%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%BF%AB%E6%8D%B7%E9%94%AE/","summary":"终端快捷键 快捷键应该是每一个需要和终端天天打交道的程序员必备的技能了，如果你还停留在每次前后左右一个字符一个字符移动光标的话，那你需要好好学习下面的终端快捷键，这可以大大提高你的效率 最常用 tab 命令或路径的补全键 移动光标 Ctrl + a/Home 切换到命令行开始 Ctrl + e/End 切换到命令行末尾 Ctrl + f 光标向右移动一","title":"Linux命令行快捷键"},{"content":"本文只代表个人见解，不代表任立场，如果您认为我的想法是错的那很正常，因为这是我的想法，如果您觉得您的想法和我一样，那我们就是传说中的 \u0026ldquo;激友\u0026rdquo;（对生活冲满激情的朋友）。进入正题。\n一、我心中的博客 我所以指的写博客，不单只是写一篇文章出来这一结果。而应该是写的这一过程，写过技术文章的朋友应该跟我一样有这么一个过程。\n  自己了解学习，文章所涉及到的知识点，及知识点衍生出来的知识点。\n  对学习的知识点进行验证，以确保理论值与实践值保持一致。\n  构思文章的大纲，哪些部分需要重点写，需要配合实例代码，图片等信息。\n  动手写，写完后再次检查校正并排版，然后发表。\n  针对网友的评论中提出的问题进行回复\n  我写文章一般都会经历以上5上步，最终以上5步融合成一个结果那就是\u0026quot;一篇文章\u0026quot; 这一过程也是我心中对的\u0026quot;写博客\u0026quot;一词的诠释\n二、为什么要写博客 为自己 写博客对自己的提升是很大的，可能写一篇体现不出来，但是只要你坚持写效果就很明显，好处人个认为有以下几点\n强化知识点 在写一篇文章前，你必定是要把以文章中心为主的知识点及衍生的知识点都详细了解一篇，在这一过程中必须会涉及到自己以前所了解过的知识。\n人的记忆是存在记忆曲线的需要不断的重复记忆才能长久的记住某一事物，而每写一篇文章时都会查阅资料，在这一过程中必然会遇到以前记住了而现在渐渐淡忘的知识点。\n当你再次看到时瞬间就会回想起，此时以前的知识点就得到了强化。\n提升学习能力 同一样的人，了解同一知识点，用不同的方法，产生的结果必然会不一样。\n找到最佳的学习方法，这也是一种能力，这种能力是经过多次实践探索之后总结出来的。\n以前我每次需了解某一种技术时都会先百度看各种搜索结果，发现没有想要的之后，再Google因为Google的结果与百度的会有所不同，Google结果中国外的文章相对会多一点。\n而偶然点了一个链接进入了博客园，发现就是自己想要的东西，而且把概念，代码，及经验都写上去了，看完之后对我帮助很大。\n渐渐的我便开始采这种方法了解新知识概念性的直接看百度百科，实质性的直接 上博客园的 找找看 。\n群里的朋友还推荐了一种方法，比如我要学MVC 园子里很多人都写了 关于MVC的一系列文章，把那一系列的文章都看一遍，对于MVC就基本有了了解了，这便是学习能力的提升,对于某种技术用最短的时间做到了比较全面的了解。\n提升文字组织能力 这个就不用说了，写博客，既然是写，就必然会有大量的文字，而如何组织文字表达出自己想表达的意思，是长期练习的，而写博客正好帮助你提高了你的文字组织能力。\n提升逻辑思维能力 不用说，技术性的东西从来就没的单独存在的，都一层层技术相结合，那在了解某种技术时，自己的思维也是要顺着这种关系逐渐深入的。\n比如MVC，你不能只知道 M是什么V是什么 C是什么就行了吧，你得知道 M V C 这三者关系是怎样的，又是怎样交互，而你了解之后再把它写出来时，需要清晰逻辑。\n为他人 有意的 园子里有很多人都写过关于 MVC 框架 WCF 等等系列文章，目的就在于帮助新人快速上手，这个我深有体会，当初我开始学习MVC时就是看的T2噬菌体的MVC系列文章，整篇看完后再配合自己动手对于MVC就有了基本的了解了，在次感谢园子里无私献的大牛们。而以上行为就是有意的帮助。\n无意的 很多时候在开发项目的过程中，遇到了技术问题，花了时间解决后，有人会写博客记录，并附上解决方法旨在当再次遇到问题时直接看下文章就知道如何处理了。\n而碰巧的是，这种问题不止他一个人遇到了，很多人在开发时也遇到了这个问题。\n在网上找答案时，就找到了这篇文章，并根据文章提供的解决方法，顺利的解决了问题，这种帮助就是无意的帮助。\n三、一定要写博客吗 答案肯定是否定的，中国几百万的程序员，如果都写博客，那程序员的春天就来了，但是事实并非如此。\n而我所讲的 写博客 的产物并不只是一篇文章，更多的是，对自己能力的提升，自己对知识点的总结。\n而发表在博客上只是为了公开，还有很多人喜欢记录在云笔记里面。还有工作很忙，没有空闲时间写出来，因为写技术性的文章，花的时间是很长的。写过的朋友都知道。\n四、博客会给你带来哪些收获 古人云：一份耕耘，一份收获\n以下这些是帮助他人而得到的一些认可，并非主观上去追求的\nMVP：微软每年都颁发MVP给那些经常与其他专业人士分享知识和专业技能，受人尊敬、信任，而且平易近人的专家。而这个称号则是对你写的博客质量的肯定。\n知名度:文章写得好的人，技术水平肯定也很好，知道的人多了，知名度就有了，比如园子里排名前10的大家都知道，都看过他们的文章。\n尊敬：对于技术界的大神，都是受人敬仰的，在园子里或者工作中也是一样的，在心里对大神们都是默默的佩服！至少我是这样啦，哈哈~也是我学习的榜样！\n五、总结 我所认的写博客是对自己所了解知识的强化，分享，自身能力的提升。当然 写 博客只是一种方法而已，只要能达到提升自我的效果什么方法都是可以的。\n之前有看过一则新闻：即便没有读者，你也要写博客 ，文章也讲解了很多写博客的好处。\n而我写博客是希望，能提升自己的综合能力，并把自己的知识与经验分享给大家，如果有幸我的分享帮助了一些人，那将使我更加欣慰。\n最后附上一句名言：有些事情你现在不去做，可能以后都不会有机会了！\n 转载自：https://mp.weixin.qq.com/s/gBx0SapuMyOY9Gu6gCoaag\n原作者：Zery\n ","permalink":"https://aladdinding.cn/2020/08/%E4%BD%9C%E4%B8%BA%E6%8A%80%E6%9C%AF%E4%BA%BA%E5%91%98%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%86%99%E5%8D%9A%E5%AE%A2/","summary":"本文只代表个人见解，不代表任立场，如果您认为我的想法是错的那很正常，因为这是我的想法，如果您觉得您的想法和我一样，那我们就是传说中的 \u0026ldquo;激友\u0026rdquo;（对生活冲满激情的朋友）。进入正题。 一、我心中的博客 我所以指的写博客，不单只是写一篇文章出来这一结果。而应该是写的这","title":"作为技术人员为什么要写博客"},{"content":" SOCKS是一种网络传输协议，主要用于客户端与外网服务器之间通讯的中间传递。SOCKS是\u0026quot;Socket Secure\u0026quot;的缩写。当防火墙后的客户端要访问外部的服务器时，就跟SOCKS代理服务器连接。这个代理服务器控制客户端访问外网的资格，允许的话，就将客户端的请求发往外部的服务器。这个协议最初由David Koblas开发，而后由NEC的Ying-Da Lee将其扩展到SOCKS4。最新协议是SOCKS5，与前一版本相比，增加支持UDP、验证，以及IPv6。根据OSI模型，SOCKS是会话层的协议，位于表示层与传输层之间。SOCKS协定不提供加密。\n SOCKS5 SOCKS协议版本认证 创建与SOCKS5服务器的TCP连接后客户端需要先发送请求来确认协议版本及认证方式（以字节为单位）\nclient send # +----+----------+----------+ # |VER | NMETHODS | METHODS | # +----+----------+----------+ # | 1 | 1 | 1 to 255 | # +----+----------+----------+  VER：SOCKS5协议版本 0x05 NMETHODS：METHODS所占字节长度 METHODS：客户端支持的认证方式列表，每个方法占1字节  0x00 不需要认证 0x01 GSSAPI 0x02 用户名、密码认证 0x03 to 0x7F 由IANA分配（保留） 0x80 to 0xFE 私人方法保留 0xFF 无可接受的方法    服务器从客户端提供的METHODS中选择一个并通过以下消息通知客户端\nserver reply # +----+--------+ # |VER | METHOD | # +----+--------+ # | 1 | 1 | # +----+--------+   VER：协议版本 0x05\n  METHOD：服务端选中的方法。如果返回0xFF表示没有一个认证方法被选中，客户端需要关闭连接。\n  SOCKS用户名密码认证 如果SOCKS协议版本认证中服务端返回的METHOD 是0x02，即需要用户名密码认证，则客户端会发送用户名密码认证信息。如果返回的METHOD是0x00，即不需要认证，直接跳转下一步发送SOCKS请求信息。\nclient send # +----+------+----------+------+----------+ # |VER | ULEN | UNAME | PLEN | PASSWD | # +----+------+----------+------+----------+ # | 1 | 1 | 1 to 255 | 1 | 1 to 255 | # +----+------+----------+------+----------+  VER：认证协议版本 0x01 ULEN：用户名长度 UNAME： 用户名 PLEN：密码长度 PASSWD：密码  server reply # +----+--------+ # |VER | STATUS | # +----+--------+ # | 1 | 1 | # +----+--------+  VER：认证协议版本 0x01 STATUS：认证状态  0x00 成功 0x01 失败    发送SOCKS请求信息 认证结束后客户端就可以发送请求信息。如果认证方法有特殊封装要求，请求必须按照方法所定义的方式进行封装。\nclient send # +----+-----+-------+------+----------+----------+ # |VER | CMD | RSV | ATYP | DST.ADDR | DST.PORT | # +----+-----+-------+------+----------+----------+ # | 1 | 1 | X'00' | 1 | Variable | 2 | # +----+-----+-------+------+----------+----------+  VER：SOCKS5协议版本 0x05 CMD：SOCK命令码  0x01 CONNECT请求 0x02 BIND请求 0x03 UDP转发   RSV：0x00 保留 ATYP：DST.ADDR类型  0x01 IPv4地址，DST.ADDR部分4字节长度 0x03 域名，DST.ADDR部分第一个字节为域名长度，DST.ADDR剩余的内容为域名，没有\\0结尾。 0x04 IPv6地址，16个字节长度。   DST.ADDR：目的地址 DST.PORT：网络字节序表示的目的端口  server reply # +----+-----+-------+------+----------+----------+ # |VER | REP | RSV | ATYP | BND.ADDR | BND.PORT | # +----+-----+-------+------+----------+----------+ # | 1 | 1 | X'00' | 1 | Variable | 2 | # +----+-----+-------+------+----------+----------+  VER：SOCKS5协议版本 0x05 REP：应答字段  0x00 成功 0x01常规SOCKS服务器连接失败 0x02 现有规则不允许连接 0x03 网络不可达 0x04 主机不可达 0x05 连接被拒 0x06 TTL超时 0x07 不支持的命令 0x08 不支持的地址类型 0x09 to 0xFF 未定义   RSV：0x00 保留 ATYP：BND.ADDR类型  0x01 IPv4地址，DST.ADDR部分4字节长度 0x03 域名，DST.ADDR部分第一个字节为域名长度，DST.ADDR剩余的内容为域名，没有\\0结尾。 0x04 IPv6地址，16个字节长度。   BND.ADDR：服务器绑定的地址 BND.PORT：网络字节序表示的服务器绑定的端口  当服务端返回REP应答字段为0x00，即成功时，客户端和服务端之间进行数据透传，完成SOCKS5代理。\nSOCKS4 SOCKS 4只支持TCP转发\n发送SOCKS请求信息 client send # +----+------+----------+--------+----------+----------+ # |VN | CD | DSTPORT | DSTIP | USERID | NULL | # +----+------+----------+--------+----------+----------+ # | 1 | 1 | 2 | 4 | variable | 1 | # +----+------+----------+--------+----------+----------+  VN：SOCKS4协议版本 0x04 CD：SOCK命令码  0x01 CONNECT请求 0x02 BIND请求   DSTPORT：目的主机的端口 DSTIP：目的主机的IP地址 USERID：用户USERID NULL：0x00  server reply # +-------+-------+----------+-----------+ # | VN | CD | DSTPORT | DSTIP | # +-------+-------+----------+-----------+ # | 1 | 1 | 2 | 4 | # +-------+-------+----------+-----------+  VN：回复代码的版本，应为0x00(注意不是0x04) CD：SOCK命令码  90(0x5a) 请求得到允许； 91(0x5b) 请求被拒绝或失败； 92(0x5c) 由于SOCKS服务器无法连接到客户端的identd（一个验证身份的进程），请求被拒绝； 93(0x5d) 由于客户端程序与identd报告的用户身份不同，连接被拒绝。   DSTPORT：目的主机的端口（和请求包中相同） DSTIP：目的主机的IP地址（和请求包中相同）  当服务端返回CD字段为90(0x5a)，即允许时，客户端和服务端之间进行数据透传，完成SOCKS4代理。\nSOCKS4a SOCKS4a协议是SOCKS4的一个补丁版，可以在SOCKS4a代理服务器上完成DNS解析\n发送SOCKS请求信息 client send # +----+------+----------+--------+----------+----------+------------+----------+ # |VN | CD | DSTPORT | DSTIP | USERID | NULL | HOSTNAME | NULL | # +----+------+----------+--------+----------+----------+------------+----------+ # | 1 | 1 | 2 | 4 | variable | 1 | variable | 1 | # +----+------+----------+--------+----------+----------+------------+----------+  DSTIP：0.0.0.x，其中x是非零，一般都为1。（原文：such an address is inadmissible as a destination IP address and thus should never occur if the client can resolve the domain name） HOSTNAME：域名  其余字段和SOCKS4相同\nserver reply SOCKS4a代理首先把HOSTNAME如：www.example.com 解析成对应的主机IP地址，并且和IP地址连接上，再向客户端发送和SOCKS4一样的响应。当服务端返回CD字段为90(0x5a)，即允许时，客户端和服务端之间进行数据透传，完成SOCKS4a代理。\nSOCKS4，SOCKS4a和SOCKS5的区别 比如浏览器使用SOCKS4代理访问www.baidu.com，浏览器先用本地的DNS解析把www.baidu.com转换成对应的IP地址，然后向SOCKS4服务器发送报文。如果此时我们的电脑受限本地完成不了DNS解析，那怎么办呢？SOCKS4a就是解决这样的问题的，客户端可以把域名发送到SOCKS4a服务器上完成DNS解析，发送的DSTIP则为0.0.0.1这样的假IP，然后就是和SOCKS4一样进行数据转发。SOCKS5代理和SOCKS4 SOCKS4a比，多了一个验证功能和udp代理的功能。\nSOCKS协议RFC  SOCKS4.protocol.txt and SOCKS4A.protocol.txt for SOCKS 4 and the SOCKS 4A extension, respectively. SOCKS5_rfc1928.txt and SOCKS5_rfc1929.txt for SOCKS 5, and SOCKS 5 Username/Password authentication.  ","permalink":"https://aladdinding.cn/2020/07/SOCKS%E5%8D%8F%E8%AE%AE%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/","summary":"SOCKS是一种网络传输协议，主要用于客户端与外网服务器之间通讯的中间传递。SOCKS是\u0026quot;Socket Secure\u0026quot;的缩写。当防火墙后的客户端要访问外部的服务器时，就跟SOCKS代理服务器连接。这个代理服务器控制客户端访问外网的资格，允许的话，就将客户端的请求","title":"SOCKS协议开发记录"},{"content":"黑苹果和白苹果最大的区别其实在显示效果上。同样一个网页，白苹果的显示就会细腻很多，而黑苹果颗粒感非常严重，造成上述原因是因为大多数苹果设备的屏幕本身的分辨率很高，如果你的显示器分辨率达到视网膜级别的话，哪怕是黑苹果也是默认开启 HiDPI 的。So 本人的2k分辨率显示器就很尴尬了，下面记录一下开启HiDPI的过程。\nHiDPI的概念 有关retina和HiDPI那点事\n总之 HiDPI 是苹果一个牛逼的显示技术，通过牺牲一定的分辨率实现更细腻的显示效果，这就是为什么 2K 显示器开启 HiDPI 的效果要比 1080P 好的原因了。\n黑苹果开启原生HiDPI 终端中运行如下命令\nsh -c \u0026#34;$(curl -fsSL https://raw.githubusercontent.com/xzhih/one-key-hidpi/master/hidpi.sh)\u0026#34; 如果出现curl: (7) Failed to connect to raw.githubusercontent.com port 443:xxx，应该是被墙了，可以挂上梯子\nexport https_proxy=http://127.0.0.1:7890 http_proxy=http://127.0.0.1:7890 all_proxy=socks5://127.0.0.1:7890 终端运行后选择相应分辨率重启即可生效！\nHiDPI开启效果 可以看到 HiDPI 开启后，「显示器选项」里面的缩放显示如图所示。可随意选择缩放模式而且不会高糊，在显示上明显感觉图标颗粒感更小了，显示更加细腻了。\n","permalink":"https://aladdinding.cn/2020/07/%E9%BB%91%E8%8B%B9%E6%9E%9C%E4%B8%80%E9%94%AE%E5%BC%80%E5%90%AFHiDPI/","summary":"黑苹果和白苹果最大的区别其实在显示效果上。同样一个网页，白苹果的显示就会细腻很多，而黑苹果颗粒感非常严重，造成上述原因是因为大多数苹果设备的屏幕本身的分辨率很高，如果你的显示器分辨率达到视网膜级别的话，哪怕是黑苹果也是默认开启 HiDPI 的。So 本人的2k分辨率显示器就很尴尬了，下面记录一","title":"黑苹果一键开启HiDPI"},{"content":" ApacheBench（ab）是用于对Apache超文本传输协议（HTTP）服务器进行基准测试的工具。ab命令会创建很多的并发访问线程，模拟多个访问者同时对某一URL地址进行访问。它的测试目标是基于URL的，因此，既可以用来测试Apache的负载压力，也可以测试nginx、lighthttp、tomcat、IIS等其它Web服务器的压力。ab命令对发出负载的计算机要求很低，既不会占用很高CPU，也不会占用很多内存，但却会给目标服务器造成巨大的负载，其原理类似CC攻击。自己测试使用也须注意，否则一次上太多的负载，可能造成目标服务器因资源耗完，严重时甚至导致死机。\n ApacheBench安装 macOS Mac下自带apache，查看版本：\napachectl -v 查看ab版本:\nab -V Window Windows系统Apache：下载链接\nLinux Ubuntu\napt-get install apache2-utils CentOS\nyum -y install httpd-tools ApacheBench使用 Options ab压力测试工具的用法，查看：\nab -h # 或者 man ab Usage: ab [options] [http[s]://]hostname[:port]/path Options are: -n requests Number of requests to perform # 在测试会话中所执行的请求个数（本次测试总共要访问页面的次数）。默认时，仅执行一个请求。 -c concurrency Number of multiple requests to make at a time # 一次产生的请求个数（并发数）。默认是一次一个。 -t timelimit Seconds to max. to spend on benchmarking This implies -n 50000 # 测试所进行的最大秒数。其内部隐含值是-n 50000。它可以使对服务器的测试限制在一个固定的总时间以内。默认时，没有时间限制。 -s timeout Seconds to max. wait for each response Default is 30 seconds # 套接字超时之前要等待的最大秒数。默认值为30秒。在2.4.4及更高版本中可用。  -b windowsize Size of TCP send/receive buffer, in bytes # TCP发送/接收缓冲区的大小，以字节为单位。 -B address Address to bind to when making outgoing connections # 建立传出连接时要绑定的地址。 -p postfile File containing data to POST. Remember also to set -T # 包含要发布的数据的文件。记住也要设置-T。 -u putfile File containing data to PUT. Remember also to set -T # 包含数据到PUT的文件。记住也要设置-T。 -T content-type Content-type header to use for POST/PUT data, eg. \u0026#39;application/x-www-form-urlencoded\u0026#39; Default is \u0026#39;text/plain\u0026#39; # 用于POST / PUT数据的内容类型标头，例如 application/x-www-form-urlencoded。默认值为text/plain。 -v verbosity How much troubleshooting info to print # 设置详细级别 4上方将在标题上显示信息，3上方将显示响应代码（404、200等），2上方将显示警告和信息。 -w Print out results in HTML tables # 在HTML表格中打印出结果。默认表是两列宽，带有白色背景。 -i Use HEAD instead of GET # 做HEAD请求，而不是GET。 -x attributes String to insert as table attributes # 用作的属性的字符串\u0026lt;table\u0026gt;。插入属性。\u0026lt;table here \u0026gt; -y attributes String to insert as tr attributes # 用作的属性的字符串\u0026lt;tr\u0026gt;。 -z attributes String to insert as td or th attributes # 用作的属性的字符串\u0026lt;td\u0026gt;。 -C attribute Add cookie, eg. \u0026#39;Apache=1234\u0026#39;. (repeatable) # cookie-name=value 对请求附加一个Cookie:行。 其典型形式是name=value的一个参数对。此参数可以重复，用逗号分割。 -H attribute Add Arbitrary header line, eg. \u0026#39;Accept-Encoding: gzip\u0026#39; Inserted after all normal header lines. (repeatable) # 将额外的标头添加到请求。该参数是典型地在一个有效报头线的形式，含有一个冒号分隔的字段值对（即，\u0026#34;Accept-Encoding: zip/zop;8bit\u0026#34;）。 -A attribute Add Basic WWW Authentication, the attributes are a colon separated username and password. # 向服务器提供BASIC身份验证凭据。用户名和密码用单个:分隔，并通过编码为base64的网络发送。无论服务器是否需要该字符串，都将发送该字符串（即，已发送所需的401身份验证）。 -P attribute Add Basic Proxy Authentication, the attributes are a colon separated username and password. # 在代理途中提供BASIC身份验证凭据。用户名和密码用单个:分隔，并通过编码为base64的网络发送。不管代理是否需要它都将发送该字符串（即，已发送所需的407代理身份验证）。 -X proxy:port Proxyserver and port number to use # 使用代理服务器处理请求。 -V Print version number and exit # 显示版本号并退出。 -k Use HTTP KeepAlive feature # 启用HTTP KeepAlive功能，即在一个HTTP会话中执行多个请求。默认为no KeepAlive。 -d Do not show percentiles served table. # 不要显示“ XX [ms]表中的投放百分比”。（旧版支持）。 -S Do not show confidence estimators and warnings. # 当平均值和中位数相距标准偏差的一倍或两倍以上时，请勿显示中位数和标准偏差值，也不会显示警告/错误消息。并默认为最小值/平均值/最大值。（旧版支持）。 -q Do not show progress when doing more than 150 requests # 当处理150个以上的请求时，每10％或100个左右的请求ab输出进度计数stderr。该 -q标志将禁止显示这些消息。 -l Accept variable document length (use this for dynamic pages) # 如果响应的长度不是恒定的，请不要报告错误。这对于动态页面很有用。在2.4.7及更高版本中可用。 -g filename Output collected data to gnuplot format file. # 将所有测量值写为“ gnuplot”或TSV（制表符单独值）文件。此文件可以轻松导入到Gnuplot，IDL，Mathematica，Igor甚至Excel等软件包中。标签位于文件的第一行。 -e filename Output CSV file with percentages served # 编写一个逗号分隔值（CSV）文件，其中包含为每个百分比（从1％到100％）提供该百分比请求所花费的时间（以毫秒为单位）。通常，它比“ gnuplot”文件有用。因为结果已经“装箱”了。 -r Don not exit on socket receive errors. # 套接字接收错误时不退出 -m method Method name # 请求的自定义HTTP方法。在2.4.10及更高版本中可用。 -h Display usage information (this message) # 显示使用情况信息。 -I Disable TLS Server Name Indication (SNI) extension # 禁用TLS服务器名称指示(SNI)扩展 -Z ciphersuite Specify SSL/TLS cipher suite (See openssl ciphers) # 指定SSL / TLS密码套件（请参阅openssl密码） -f protocol Specify SSL/TLS protocol (SSL2, TLS1, TLS1.1, TLS1.2 or ALL) # 指定SSL / TLS协议（SSL2，SSL3，TLS1，TLS1.1，TLS1.2或ALL）。TLS1.1和TLS1.2支持在2.4.4及更高版本中提供。 -E certfile Specify optional client certificate chain and private key # 指定可选的客户端证书链和私钥 Output 执行命令\nab -n 1000 -c 200 http://pts.aliyun.com/lite/index.htm/ 获取结果分析\n# apache版本信息 This is ApacheBench, Version 2.3 \u0026lt;$Revision: 1843412 $\u0026gt; Copyright 1996 Adam Twiss, Zeus Technology Ltd, http://www.zeustech.net/ Licensed to The Apache Software Foundation, http://www.apache.org/ Benchmarking pts.aliyun.com (be patient) Completed 100 requests Completed 200 requests Completed 300 requests Completed 400 requests Completed 500 requests Completed 600 requests Completed 700 requests Completed 800 requests Completed 900 requests Completed 1000 requests Finished 1000 requests # 请求返回header类型 Server Software: Tengine/Aserver # 请求ip或者域名 Server Hostname: pts.aliyun.com # 请求端口，当前请求为https所以端口为443，请求https端口80 Server Port: 80 # 从命令行字符串解析请求URI。 Document Path: /lite/index.htm/ # 这是第一个成功返回的文档的大小（以字节为单位）。如果在测试过程中文档长度发生变化，则将响应视为错误。 Document Length: 357 bytes # 测试期间使用的并发客户端数 Concurrency Level: 200 从建立连接到最后接受完成总时间 Time taken for tests: 1.280 seconds # 完成请求数 Complete requests: 1000 # 失败请求数 Failed requests: 0 # 不在200系列响应代码中的响应数。如果所有响应均为200，则不会打印此字段。 Non-2xx responses: 1000 # 从服务器接收的字节总数 Total transferred: 642000 bytes # HTML接收字节数，减去了Total transferred中HTTP响应数据中的头信息的长度 HTML transferred: 357000 bytes # 吞吐率：每秒请求数（总请求数/总时间，相当于LR中的每秒事务数TPS） Requests per second: 781.47 [#/sec] (mean) # 用户平均请求等待时间 Time per request: 255.928 [ms] (mean) # 服务器处理每个请求平均响应时间，mean表示为平均值 Time per request: 1.280 [ms] (mean, across all concurrent requests) # 由公式计算得出的传输速率 totalread / 1024 / timetaken Transfer rate: 489.95 [Kbytes/sec] received # 连接消耗时间分解 Connection Times (ms) min mean[+/-sd] median max 最小值 平均值 标准差 中间值 最大值 Connect: 22 30 4.0 30 38 Processing: 22 95 164.5 34 1200 Waiting: 22 83 154.3 33 1200 Total: 46 125 163.4 66 1227 # 按完成请求的百分比，得出完成请求中花费时间最长的那一个请求的时间，也就是这些请求完成时间的最大值（毫秒） Percentage of the requests served within a certain time (ms) # 50%请求完成时间的最大值是66毫秒 50% 66 66% 69 75% 71 80% 80 90% 317 # 90%请求完成时间的最大值是148毫秒 95% 536 98% 744 99% 825 # // 100%请求完成时间的最大值是1227毫秒（最长请求） 100% 1227 (longest request) 性能指标 1、吞吐率（Requests per second） 服务器并发处理能力的量化描述，单位是reqs/s，指的是在某个并发用户数下单位时间内处理的请求数。某个并发用户数下单位时间内能处理的最大请求数，称之为最大吞吐率。 记住：吞吐率是基于并发用户数的。这句话代表了两个含义： a、吞吐率和并发用户数相关； b、不同的并发用户数下，吞吐率一般是不同的。 计算公式：总请求数/处理完成这些请求数所花费的时间，即： Request per second=Complete requests/Time taken for tests 必须要说明的是，这个数值表示当前机器的整体性能，值越大越好。\n2、并发连接数（The number of concurrent connections） 并发连接数指的是某个时刻服务器所接受的请求数目，简单的讲，就是一个会话。\n3、并发用户数（Concurrency Level） 要注意区分这个概念和并发连接数之间的区别，一个用户可能同时会产生多个会话，也即连接数。在HTTP/1.1下，IE7支持两个并发连接，IE8支持6个并发连接，FireFox3支持4个并发连接，所以相应的，我们的并发用户数就得除以这个基数。\n4、用户平均请求等待时间（Time per request） 计算公式：处理完成所有请求数所花费的时间/（总请求数/并发用户数），即：Time per request=Time taken for tests/（Complete requests/Concurrency Level）\n5、服务器平均请求等待时间（Time per request:across all concurrent requests） 计算公式：处理完成所有请求数所花费的时间/总请求数，即： Time taken for/testsComplete requests 可以看到，它是吞吐率的倒数。同时，它也等于用户平均请求等待时间/并发用户数，即： Time per request/Concurrency Level\n","permalink":"https://aladdinding.cn/2020/05/ApacheBench-HTTP%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/","summary":"ApacheBench（ab）是用于对Apache超文本传输协议（HTTP）服务器进行基准测试的工具。ab命令会创建很多的并发访问线程，模拟多个访问者同时对某一URL地址进行访问。它的测试目标是基于URL的，因此，既可以用来测试Apache的负载压力，也可以测试nginx、lig","title":"ApacheBench HTTP服务器基准测试工具使用总结"},{"content":" 北京时间 2019年10 月 8 日凌晨，苹果推送了 macOS Catalina 正式版更新。新版 macOS 将 iTunes 拆分为三个独立应用、推出了支持 iPad 作为第二屏幕的 「随航」，macOS 版「屏幕使用时间」等多项新功能。\n 说在前面 作为一个Hackintosh用户，Hackintosh的稳定性依然是最重要的。macOS Mojave 10.14.6作为macOS 10.14的最后一个大版本，凭借其稳定性、硬件兼容性等依旧是目前Hackintosh主推的版本。\n忽略macOS Catalina 10.15更新通知 隐藏/关闭更新通知依次打开 启动台-其他-终端，输入以下神秘代码，Enter后输入用户密码即可。\nsudo softwareupdate --ignore \u0026#34;macOS Catalina\u0026#34; 将来要是想开了，又想更新了，再次输入以下神秘代码即可。\nsudo softwareupdate --reset-ignored 屏蔽升级Catalina软件更新小红点 如果在此之前已经点击了软件更新出现了小红点，对于强迫症用户十分不友好。\n打开 启动台-其他-终端-输入\ndefaults write com.apple.systempreferences AttentionPrefBundleIDs 0 然后继续输入\nkillall Dock 烦人的小红点就消失了！！！\n关于Big Sur 此方法在macOS 10.16 Big Sur已经不适用，暂时没有找到合适的方法\n","permalink":"https://aladdinding.cn/2020/04/macOS%E5%B1%8F%E8%94%BD%E7%B3%BB%E7%BB%9F%E6%9B%B4%E6%96%B0%E9%80%9A%E7%9F%A5/","summary":"北京时间 2019年10 月 8 日凌晨，苹果推送了 macOS Catalina 正式版更新。新版 macOS 将 iTunes 拆分为三个独立应用、推出了支持 iPad 作为第二屏幕的 「随航」，macOS 版「屏幕使用时间」等多项新功能。 说在前面 作为一个Hackintosh用户，Hackintosh的稳定性依然是最重要的。macOS Mojave 10.14.6","title":"MacOS屏蔽系统更新通知"},{"content":"从我毕业进入公司起，前辈就一直在提及一点：编程不仅仅是知识和技能，更重要的是去领会编程领域的文化。刚进入公司的我似乎并没有马上接受这一点，认为这可能只是所谓的“玄学”罢了，所以也就是当作任务记下了个一点，并没有很好的理会。直到我工作了一年后，疫情期间读完王哥发来的一篇《如何成为一名黑客》，似乎逐渐理解了王哥在这一年中对我的指导，并且解答了我初入编程行业的疑惑。\n文章的标题是如何成为一名黑客，这里的黑客并不是我们所认为的在网络中来无影去无踪的“黑客”，能让更多人理解的应该是极客。在我看来，这篇文章讲述的是你如何成为一名优秀并且受人尊敬的编程人士。\n基本的态度  这个世界充满了令人着迷的问题等着我们去解决  你要从解决问题，磨练技术，以及锻炼智力中得到基本的享受以及动力。的确，回想这一年的工作时光，另我开心的事情莫过于解决了棘手问题，学习了一门新的语言，自己完成的功能第二天就上线，得到了客户的认可等等。   一个问题不应该被解决两次  不应该把宝贵的时间浪费在发明轮子上。初入公司我想着把很多python2的代码重构成python3，现在想想确实浪费时间，应该着重于解决新的问题而不是在旧问题上浪费时间。   无聊和乏味的工作是罪恶的  重复性劳动浪费我们解决新问题的时间，而解决新问题才是最大的价值所在。提取公共函数，将日常的工作变成自动化等等。   崇尚自由  其实这一点并不是很理解。。产品经理提出无理的需求？？？ 2020/09/10更新：这个上升到政治层面就比较好理解了，从美国打压WeChat和Tik Tok可以看出   态度不能代替能力  只具备这些态度并不能使你成为一名黑客，也不能使你成为一个运动健将和摇滚明星。成为一名黑客需要智力、实践、奉献精神、以及辛苦的工作。    基本的技能  学习如何编程（这里包括以下内容有几句话写的很好，我想全搬运过来）  有一个大体的规律，就是如果你过于偏重使用一种语言，这种语言一方面会成为你得心应手的工具，另一方面也会阻碍你的学习。有这个问题的不只是编程语言，类似 RubyOnRails、CakePHP、以及 Django 的 web 应用框架也有这个问题，它们只会让你肤浅地懂得一些东西，当你碰到难以解决的问题或者需要调试时，你就可能不知所措了。 单单学习编程语言并不会让你达到黑客的程度，甚至连程序员的程度都难企及——你需要脱离某种编程语言的素服，学习通过编程解决问题的思路。要成为一个真正的黑客，你需要达到几天就能学会一门编程语言的水平，你可以将文档里的信息和你已经掌握的知识结合起来，很快就学会一门编程语言。这意味着你需要先学会机种思路截然不同的语言才行。 编程是一个复杂的技能，我无法给你完整的指南来教会你如何编程，不过我可以告诉你，书本和课程也无法教会你如何编程——很多黑客，或者也许几乎所有的黑客，都是靠自学的。你从书本上学到语言的特点——只是一些皮毛，但要使书面知识成为自身技能，你只能通过实践和虚心向他人学习。因此你要做的就是 (a) 读代码，(b) 写代码。 学习编程就象学习自然语言写作一样。最好的做法是读一些大师的名著，试着自己写点东西，再读些，再写点，再读些，再写点……如此往复，直到你的文章具备范文的力量和感觉为止。   学会使用开源的Unix系统  Unix 还是 Internet 的操作系统。你可以学会上网却不知道 Unix，但你不了解 Unix 就无法成为一名 Internet 黑客。因此，今天的黑客文化在很大程度上是以 Unix 为核心的。（这点并不总是真的，一些很早的黑客对此一直很不满，但 Unix 和 Internet 之间的联系已是如此之强，就连 Microsoft 这样强力的公司也对此也无可奈何。）   学会使用万维网以及编写HTML  学会使用Google，Stack Overflow，Github等等   学习英语，如果你的水平不够的话  Linus Torvalds 是芬兰人，但他的代码注解是用英语写的（很明显他从没想过其他的可能性）。他流利的英语。是他能够管理全球范围的 Linux 开发人员社区的重要因素。 这是一个值得学习的例子。 就算你的母语是英语，这也无法保证你的语言技能足够达到黑客的标准。如果你的写作文字不通、语法混乱、错字连篇，包括我在内的大部分的黑客都会忽略你的存在。虽然写作马虎不一定意味着思考也马虎，但我们发现两者的关联性还是挺强的——马虎的头脑对我们来说毫无价值，如果你写作能力不够，就好好学习写作吧。（划重点，终于知道王哥为什么每次都会特别强调然后纠正我的错别字了）    提高自己在编程圈中的地位 以下就是以后的人生所追求的吧，自己离这些还很遥远。。。\n  撰写开源软件\n 黑客领域里最受尊敬的偶像，是那些写了大型的、好用的、用途广泛的软件，并把它们发布出来，使得每人都在使用他软件的人。    帮助测试并调试开源软件\n 如果你是个新手，试着找一个你感兴趣的正在开发中的程序，做一个好的 beta 测试员。你会自然地从帮着测试，进步到帮着抓 bug，到最后帮着改程序。你会从中学到很多，而且善因种善果，以后别人也会很乐意帮助你。    发布有用的信息\n 另一件好事是收集整理有用有趣的信息，做成网页或类似 FAQ 的文档，并且让大家都能看到。技术性 FAQ 的维护者会受到和开源代码的作者一样多的尊敬。（比如Github上面很多awesome language和国内很多大佬的博客，录制的教程等等）    帮助维护基础设施的运转\n  黑客文化（还有互联网工程方面的发展）是靠志愿者推动的。要使Internet能正常工作，就要有大量枯燥的工作不得不去完成——管理邮件列表和新闻组，维护大型软件库，开发 RFC 和其它技术标准等等。\n做这类事情的人会得到很多尊敬，因为每人都知道这些事情费时颇多，而又不象编程那样有趣。做这些事情需要奉献精神。\n    为黑客文化本身服务\n 黑客文化没有领袖，这点是确认无疑的。但黑客圈里确实有些文化英雄、部落长者、史学家、还有发言人。如果你在这圈里呆足够长时间，你也许也能成为其中之一。 记住：黑客们不相信他们的部落长者的自夸，因此过分追求这种名誉是危险的。与其奋力追求，不如先摆正自己的位置，等它自己落到你的手中——那时则要做到谦虚和优雅。    常读常新，每隔一段时间读一遍都会有新的收获。最后附上这篇文档。\n如何成为一名黑客\n","permalink":"https://aladdinding.cn/2020/04/%E8%AF%BB%E5%A6%82%E4%BD%95%E6%88%90%E4%B8%BA%E4%B8%80%E5%90%8D%E9%BB%91%E5%AE%A2%E6%9C%89%E6%84%9F/","summary":"从我毕业进入公司起，前辈就一直在提及一点：编程不仅仅是知识和技能，更重要的是去领会编程领域的文化。刚进入公司的我似乎并没有马上接受这一点，认为这可能只是所谓的“玄学”罢了，所以也就是当作任务记下了个一点，并没有很好的理会。直到我工作了一年后，疫情期间读完王哥发来的一篇《如何成为一","title":"读《如何成为一名黑客》有感"},{"content":"原文  Beautiful is better than ugly. Explicit is better than implicit. Simple is better than complex. Complex is better than complicated. Flat is better than nested. Sparse is better than dense. Readability counts. Special cases aren\u0026rsquo;t special enough to break the rules. Although practicality beats purity. Errors should never pass silently. Unless explicitly silenced. In the face of ambiguity, refuse the temptation to guess. There should be one\u0026ndash; and preferably only one \u0026ndash;obvious way to do it. Although that way may not be obvious at first unless you\u0026rsquo;re Dutch. Now is better than never. Although never is often better than right now. If the implementation is hard to explain, it\u0026rsquo;s a bad idea. If the implementation is easy to explain, it may be a good idea. Namespaces are one honking great idea \u0026ndash; let\u0026rsquo;s do more of those!\n 解读 The Zen of Python是Python语言的指导原则，遵循这些基本原则，你就可以像个Pythonista一样编程。具体内容你可以在Python命令行输import this看到：\n  Beautiful is better than ugly.\n# 优美胜于丑陋（Python以编写优美的代码为目标）\n  Explicit is better than implicit.\n# 明了胜于晦涩（优美的代码应当是明了的，命名规范，风格相似）\n  Simple is better than complex.\n# 简洁胜于复杂（优美的代码应当是简洁的，不要有复杂的内部实现）\n  Complex is better than complicated.\n# 复杂胜于凌乱（如果复杂不可避免，那代码间也不能有难懂的关系，要保持接口简洁）\n  Flat is better than nested.\n# 扁平胜于嵌套（优美的代码应当是扁平的，不能有太多的嵌套）\n  Sparse is better than dense.\n# 间隔胜于紧凑（优美的代码有适当的间隔，不要奢望一行代码解决问题）\n  Readability counts.\n# 可读性很重要（优美的代码是可读的）\n  Special cases aren\u0026rsquo;t special enough to break the rules. Although practicality beats purity.\n# 即便假借特例的实用性之名，也不可违背这些规则（这些规则至高无上）\n  Errors should never pass silently. Unless explicitly silenced.\n# 不要包容所有错误，除非你确定需要这样做（精准地捕获异常，不写except:pass风格的代码）\n  In the face of ambiguity, refuse the temptation to guess.\n# 当存在多种可能，不要尝试去猜测\n  There should be one\u0026ndash; and preferably only one \u0026ndash;obvious way to do it.\n# 而是尽量找一种，最好是唯一一种明显的解决方案（如果不确定，就用穷举法）\n  Although that way may not be obvious at first unless you\u0026rsquo;re Dutch.\n# 虽然这并不容易，因为你不是 Python 之父（这里的Dutch是指Guido）\n  Now is better than never. Although never is often better than right now.\n# 做也许好过不做，但不假思索就动手还不如不做（动手之前要细思量）\n  If the implementation is hard to explain, it\u0026rsquo;s a bad idea.\n# 如果你无法向人描述你的方案，那肯定不是一个好方案\n  If the implementation is easy to explain, it may be a good idea.\n# 如果你能向人简洁描述你的方案，那也许是一个好方案（方案测评标准）\n  Namespaces are one honking great idea \u0026ndash; let\u0026rsquo;s do more of those!\n# 命名空间是一种绝妙的理念，我们应当多加利用（倡导与号召）\n  这首特别的“诗”开始作为一个笑话，但它确实包含了很多关于Python背后的哲学真理。Python之禅已经正式成文PEP 20，具体内容见：PEP 20\n","permalink":"https://aladdinding.cn/2020/01/The-Zen-of-Python/","summary":"The Zen of Python是Python语言的指导原则，遵循这些基本原则，你就可以像个Pythonista一样编程。","title":"The Zen of Python"},{"content":"Homebrew简介  Homebrew是一款MacOS平台下的软件包管理工具，拥有安装、卸载、更新、查看、搜索等很多实用的功能。简单的一条指令，就可以实现包管理，而不用你关心各种依赖和文件路径的情况，十分方便快捷。\n Homebrew 的几个核心概念 在正式介绍 Homebrew 的使用之前，我先为你介绍一下 Homebrew 中的一些核心的概念，了解这些概念，就可以帮助你更好的去使用 Homebrew。\n   词汇 含义     formula (e) 安装包的描述文件，formulae 为复数   cellar 安装好后所在的目录   keg 具体某个包所在的目录，keg 是 cellar 的子目录   bottle 预先编译好的包，不需要现场下载编译源码，速度会快很多；官方库中的包大多都是通过 bottle 方式安装   tap 下载源，可以类比于 Linux 下的包管理器 repository   cask 安装 macOS native 应用的扩展，你也可以理解为有图形化界面的应用。   bundle 描述 Homebrew 依赖的扩展    Homebrew安装 将以下命令粘贴至终端，回车运行\n/bin/bash -c \u0026#34;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install.sh)\u0026#34; 如果出现curl: (7) Failed to connect to raw.githubusercontent.com port 443:xxx，应该是被墙了，挂上梯子即可\nexport https_proxy=http://127.0.0.1:7890 http_proxy=http://127.0.0.1:7890 all_proxy=socks5://127.0.0.1:7890 Homebrew更换国内源 替换默认源 # 步骤一：替换brew.git cd \u0026#34;$(brew --repo)\u0026#34; git remote set-url origin https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/brew.git # 步骤二：替换homebrew-core.git cd \u0026#34;$(brew --repo)/Library/Taps/homebrew/homebrew-core\u0026#34; git remote set-url origin https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/homebrew-core.git #步骤三 brew update 替换Homebrew Bottles源  Homebrew是OS X系统的一款开源的包管理器。出于节省时间的考虑，Homebrew默认从Homebrew Bottles源中下载二进制代码包安装。Homebrew Bottles是Homebrew提供的二进制代码包，目前镜像站收录了以下仓库：\n  homebrew/homebrew-core homebrew/homebrew-dupes homebrew/homebrew-games homebrew/homebrew-gui homebrew/homebrew-python homebrew/homebrew-php homebrew/homebrew-science homebrew/homebrew-versions homebrew/homebrew-x11  # 根据自己使用的shell echo \u0026#39;export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.tuna.tsinghua.edu.cn/homebrew-bottles\u0026#39; \u0026gt;\u0026gt; ~/.bash_profile # 使配置生效 source ~/.bash_profile 复原默认源 # 步骤一 cd \u0026#34;$(brew --repo)\u0026#34; git remote set-url origin https://github.com/Homebrew/brew.git # 步骤二 cd \u0026#34;$(brew --repo)/Library/Taps/homebrew/homebrew-core\u0026#34; git remote set-url origin https://github.com/Homebrew/homebrew-core # 步骤三 brew update Homebrew常用命令 安装卸载软件  brew --version或者brew -v 显示brew版本信息 brew install 安装指定软件 brew unistall 卸载指定软件 brew list 显示所有的已安装的软件 brew search text 搜索本地远程仓库的软件，已安装会显示绿色的勾 brew search /text/ 使用正则表达式搜软件  升级软件相关  brew update 自动升级homebrew（从github下载最新版本） brew outdated 检测已经过时的软件 brew upgrade 升级所有已过时的软件，即列出的以过时软件 brew upgrade升级指定的软件 brew pin 禁止指定软件升级 brew unpin 解锁禁止升级 brew upgrade --all 升级所有的软件包，包括未清理干净的旧版本的包  清理相关  brew cleanup -n 列出需要清理的内容 brew cleanup 清理指定的软件过时包 brew cleanup 清理所有的过时软件 brew unistall 卸载指定软件 brew unistall --force 彻底卸载指定软件，包括旧版本  服务相关   brew services start mysql 启动Mysql\n  brew services stop mysql 停止Mysql\n  brew services restart mysql 重启Mysql\n  brew services list 查看启动列表\n  ","permalink":"https://aladdinding.cn/2020/01/macOS%E8%BD%AF%E4%BB%B6%E5%8C%85%E7%9A%84%E7%AE%A1%E7%90%86%E5%99%A8Homebrew/","summary":"Homebrew简介 Homebrew是一款MacOS平台下的软件包管理工具，拥有安装、卸载、更新、查看、搜索等很多实用的功能。简单的一条指令，就可以实现包管理，而不用你关心各种依赖和文件路径的情况，十分方便快捷。 Homebrew 的几个核心概念 在正式介绍 Homebrew 的使用之前，我先为你介绍一下 Homebrew 中的一些核","title":"MacOS软件包的管理器Homebrew"},{"content":"这几天整理了大学期间的书籍，发现了当时选修日语课时自己总结打印出来的的日语五十音巧记，现在看到还有点好笑，不过当时确实帮助自己应付过了期末考试。直到现在两年过去了，自己还是可以背出日语五十音前面几十个，这里就记录一下吧，万一以后有用呢。。。\nあ行     清音     あア \u0026ldquo;女\u0026quot;孩子胖\u0026quot;了\u0026quot;一圈,惨叫了一声\u0026quot;啊(a)\u0026rdquo;   いイ 平假名い和片假名イ拼在一起就会组成一个汉字\u0026quot;以(i)\u0026quot;，读音也是以   うウ 平假名う很像字母W横过来,\u0026ldquo;屋(u)\u0026quot;,片假名ウ像“家”字的宝盖头,有家有房\u0026quot;屋\u0026rdquo;   えエ \u0026ldquo;元\u0026quot;朝的\u0026quot;工\u0026quot;人很悲\u0026quot;哀(e)\u0026rdquo;   おオ 有学“术”的“才”子都很\u0026quot;傲(o)\u0026ldquo;气    か行     清音 浊音     かカ 因为被\u0026quot;卡(ka)\u0026ldquo;住了，所以要多用\u0026quot;一点\u0026quot;\u0026ldquo;力\u0026rdquo; ga(が ガ)   きキ 长得像琵琶,琵琶调音key(ki) gi(ぎ ギ)   くク 小时候\u0026quot;小于\u0026quot;别人,长大后终于\u0026quot;大于\u0026quot;别人,感动的要“哭(ku)”了 gu(ぐ グ)   けケ \u0026ldquo;开(ke)\u0026ldquo;了一\u0026quot;个\u0026quot;豆\u0026quot;汁\u0026quot;店 ge(げ ゲ)   こコ \u0026ldquo;扣(ko)\u0026ldquo;了“两条鱼”放在鱼篓里 go(ご ゴ)    さ行     清音 浊音     さサ 一个人弯着腿跪在\u0026quot;艹\u0026quot;上面,是不是很\u0026quot;傻(sa)\u0026rdquo; za(ざ ザ)   しシ 用“吸管”喝水,\u0026ldquo;吸(shi)\u0026ldquo;出来“三点水 ji(じ ジ)   すス 一个人上吊\u0026quot;又\u0026quot;\u0026ldquo;苏(su)\u0026ldquo;醒了 zu(ず ズ)   せセ 世界被\u0026quot;塞(se)\u0026ldquo;得满满的 ze(ぜ ゼ)   そソ 一位艺人比起了V字\u0026quot;手(so)\u0026rdquo; zo(ぞ ゾ)    た行     清音 浊音     たタ \u0026ldquo;他(ta)\u0026ldquo;在半夜\u0026quot;十二\u0026quot;点的\u0026quot;夕\u0026quot;阳下 da(だ ダ)   ちチ \u0026ldquo;吃(chi)\u0026ldquo;5千个包子 ji(ぢ ヂ)   つツ 好\u0026quot;粗(tsu)\u0026ldquo;的一根绳子打了三个结 zu(づ ヅ)   てテ 路人\u0026quot;乙\u0026quot;撞到了\u0026quot;行\u0026quot;人老\u0026quot;太太(te)\u0026rdquo; de(で デ)   とト \u0026ldquo;丫\u0026quot;头\u0026quot;拖(to)\u0026ldquo;着一个萝\u0026quot;卜\u0026rdquo; do(ど ド)    な行     清音     なナ 把\u0026quot;十三\u0026quot;算成了\u0026quot;十\u0026quot;也太木\u0026quot;讷(na)\u0026ldquo;了   にニ \u0026ldquo;你(ni)\u0026ldquo;是\u0026quot;仁\u0026quot;者\u0026quot;二\u0026quot;心   ぬヌ \u0026ldquo;奴(nu)\u0026ldquo;隶制度\u0026quot;又\u0026quot;出现了   ねネ 有了\u0026quot;权\u0026quot;利的奶(n)奶是\u0026quot;福\u0026quot;气   のノ \u0026ldquo;NO(no)\u0026ldquo;\u0026ldquo;0\u0026quot;和\u0026quot;1\u0026rdquo;    は行     清音 浊音 半浊音     はハ \u0026ldquo;哈(ha)\u0026ldquo;八巴狗打\u0026quot;仗\u0026rdquo; ba(ば バ) pa(ぱ パ)   ひヒ \u0026ldquo;黑(hi)\u0026ldquo;色的\u0026quot;U\u0026quot;型\u0026quot;匕\u0026quot;首 bi(び ビ) pi(ぴ ピ)   ふフ \u0026ldquo;小\u0026quot;\u0026ldquo;夫(fu)\u0026ldquo;子玩\u0026quot;飞刀\u0026rdquo; bu(ぶ ブ) pu(ぷ プ)   へヘ 太\u0026quot;嗨(he)\u0026ldquo;了两个眼睛都笑弯了 be(べ ベ) pe(ぺ ペ)   ほホ 对着\u0026quot;木\u0026quot;头\u0026rdquo;\u0026lsquo;吼(ho)\u0026ldquo;了\u0026quot;一天\u0026rdquo; bo(ぼ ボ) po(ぽ ポ)    ま行     清音     まマ \u0026ldquo;天\u0026quot;天玩\u0026quot;飞刀\u0026rdquo;”吗(ma)\u0026rdquo;   みミ \u0026ldquo;三\u0026quot;个\u0026quot;H\u0026quot;\u0026ldquo;眯(mi)\u0026ldquo;着眼   むム \u0026ldquo;跪在\u0026quot;木(mu)\u0026ldquo;头上上吊\u0026quot;么\u0026rdquo;   めメ 一个\u0026quot;女\u0026quot;的被×后被“灭(me)\u0026ldquo;了   もモ \u0026ldquo;七\u0026quot;个\u0026quot;毛\u0026quot;子有阴\u0026quot;谋(mo)\u0026rdquo;    や行     清音     やヤ 两个\u0026quot;牙(ya)\u0026ldquo;\u0026ldquo;也\u0026quot;坏了   ゆユ \u0026ldquo;有(yu)\u0026ldquo;\u0026ldquo;一串糖葫芦\u0026quot;用\u0026quot;长篓子\u0026quot;装起来   よヨ \u0026ldquo;哟(yo)\u0026rdquo; \u0026ldquo;支\u0026quot;付宝\u0026quot;扫\u0026quot;码    ら行     清音     らラ \u0026ldquo;今\u0026quot;天\u0026quot;5\u0026quot;个人\u0026quot;拉(ra)\u0026ldquo;肚子   りリ 两个像\u0026quot;立(ri)\u0026ldquo;刀旁\u0026quot;刂\u0026rdquo;   るル \u0026ldquo;路(ru)\u0026ldquo;上遇到\u0026quot;儿\u0026quot;子\u0026quot;歹\u0026quot;徒   れレ 有\u0026quot;机\u0026quot;会\u0026quot;来(re)\u0026ldquo;要\u0026quot;勾\u0026quot;住   ろロ \u0026ldquo;3\u0026quot;万人\u0026quot;口\u0026quot;好\u0026quot;low(ro)\u0026rdquo;    わ行     清音     わワ \u0026ldquo;水箱的底儿没了\u0026rdquo;,水\u0026quot;哇(wa)\u0026ldquo;的全漏光了   をヲ 龙\u0026quot;哦(o)\u0026rdquo;    拨音     清音     んン \u0026ldquo;摁(n)'\u0026ldquo;两下\u0026quot;\u0026ldquo;铃铛\u0026rdquo;    ","permalink":"https://aladdinding.cn/2020/01/%E6%97%A5%E8%AF%AD%E4%BA%94%E5%8D%81%E9%9F%B3%E7%AC%A8%E6%8B%99%E8%AE%B0%E5%BF%86/","summary":"这几天整理了大学期间的书籍，发现了当时选修日语课时自己总结打印出来的的日语五十音巧记，现在看到还有点好笑，不过当时确实帮助自己应付过了期末考试。直到现在两年过去了，自己还是可以背出日语五十音前面几十个，这里就记录一下吧，万一以后有用呢。。。 あ行 清音 あア \u0026ldquo;女\u0026quot;","title":"日语五十音笨拙记忆"},{"content":"SSH简介  SSH 为 Secure Shell 的缩写，由 IETF 的网络小组（Network Working Group）所制定；SSH 为建立在应用层基础上的安全协议。SSH 是目前较可靠，专为远程登录会话和其他网络服务提供安全性的协议。利用 SSH 协议可以有效防止远程管理过程中的信息泄露问题。SSH最初是UNIX系统上的一个程序，后来又迅速扩展到其他操作平台。SSH在正确使用时可弥补网络中的漏洞。SSH客户端适用于多种平台。几乎所有UNIX平台—包括HP-UX、Linux、AIX、Solaris、Digital UNIX、Irix，以及其他平台，都可运行SSH。SSH 登录提供两种认证方式：口令(密码)认证方式和密钥认证方式。其中口令(密码)认证方式是我们最常用的一种，这里介绍密钥认证方式登录到linux/unix的方法。\n SSH服务器之间免密登陆配置 生成密钥（公钥和私钥） cd $HOME/.ssh ssh-keygen -t rsa # 全部回车默认 参数 -t rsa 表示使用 rsa 算法进行加密，执行后，会在/home/当前用户/.ssh目录下找到 id_rsa（私钥）和id_rsa.pub（公钥）\n放置公钥到目标服务器中 cat id_rsa.pub 复制id_rsa.pub内的公钥，登陆到目标服务器\ncd $HOME/.ssh vi authorized_keys 将复制的公钥粘贴到authorized_keys中，authorized_keys存放远程免密登录的公钥，主要通过这个文件记录多台机器的公钥\n 以上的步骤就已经完成了SSH服务器之间的免密登陆。不过有的场景是一台跳板机和多台服务器完成了SSH免密传输，此时想换一台电脑管理这些服务器，可以将之前的跳板机私钥拷贝到新电脑中。\nssh-add ~/.ssh/id_rsa # id_rsa为之前跳板机的私钥 如果出现提示Could not open a connection to your authentication agent.,运行如下命令\nssh-agent bash GitHub的免密传输 SSH的免密传输  登陆到Github中，进入个人设置 提交服务器SSH公钥 选择SSH and GPG keys，粘贴你的服务器公钥  切换项目的传输方式 # （以HTTPS切换成SSH为例） git remote remove origin git remote add origin git@github.com:Username/Your_Repo_Name.git # 重新设置track branch git branch --set-upstream-to=origin/master master HTTPS的免密传输 新建文件 vi $HOME/.git-credentials 添加以下内容 # （GitHub为github.com，码云为gitee.com） https://{username}:{password}@github.com 添加git配置 git config --global credential.helper store 查看是否添加成功 # 查看$HOME/.gitconfig文件，会发现出现一下内容 [credential] helper = store 这样设置存在一定风险，因为密码是明文存放在这个文件里的，比较容易泄露\n","permalink":"https://aladdinding.cn/2019/10/SSH%E7%9B%B8%E5%85%B3%E7%9A%84%E5%BF%AB%E9%80%9F%E9%85%8D%E7%BD%AE/","summary":"SSH简介 SSH 为 Secure Shell 的缩写，由 IETF 的网络小组（Network Working Group）所制定；SSH 为建立在应用层基础上的安全协议。SSH 是目前较可靠，专为远程登录会话和其他网络服务提供安全性的协议。利用 SSH 协议可以有效防止远程管理过程中的信息泄露问题。SSH最初是UNIX系统上的一个程序，后来又","title":"SSH相关的快速配置"},{"content":"Tmux简介  Tmux 的全称是 Terminal MUtipleXer，及终端复用软件。顾名思义，它的主要功能就是用于在一个终端窗口中运行多个终端会话并且在你关闭终端窗口之后保持进程的运行。\n Tmux安装 # Ubuntu 或 Debian $ sudo apt-get install tmux # CentOS 或 Fedora $ sudo yum install tmux # Mac $ brew install tmux Tmux概念 Tmux 中有几个重要概念：\n 会话（session）: 建立一个 tmux 工作区会话，会话可以长期驻留，重新连接服务器不会丢失，我们只需重新 tmux attach 到之前的工作区就可以恢复会话 窗口（window）: 容纳多个窗格 窗格（pane）: 可以在窗口中分成多个窗格   Tmux基本操作 常用命令  tmux new　创建默认名称的会话 tmux new -s mysession　创建名为mysession的会话 tmux ls　显示会话列表 tmux a　连接上一个会话 tmux a -t mysession　连接指定会话 tmux rename -t s1 s2　重命名会话s1为s2 tmux kill-session　关闭上次打开的会话 tmux kill-session -t s1　关闭会话s1 tmux kill-session -a -t s1　关闭除s1外的所有会话 tmux kill-server　关闭所有会话  Tmux 默认的快捷键前缀是 ctrl+b，当然你也可以修改它（后文会提到） 以下所有的操作都是激活控制台之后，即键入Ctrl+b前提下才可以使用的命令\n会话操作（session）  ?　列出所有快捷键；按q返回 d　脱离当前会话,可暂时返回Shell界面，输入tmux attach能够重新进入之前会话 s　选择并切换会话；在同时开启了多个会话时使用 D　选择要脱离的会话；在同时开启了多个会话时使用 :　进入命令行模式；此时可输入支持的命令，例如kill-server所有tmux会话 [　复制模式，光标移动到复制内容位置，空格键开始，方向键选择复制，回车确认，q/Esc退出 ]　进入粘贴模式，粘贴之前复制的内容，按q/Esc退出 ~　列出提示信息缓存；其中包含了之前tmux返回的各种提示信息 t　显示当前的时间 Ctrl+z　挂起当前会话  窗口操作（window）  c　创建新窗口 \u0026amp;　关闭当前窗口 数字键　切换到指定窗口 p　切换至上一窗口 n　切换至下一窗口 l　前后窗口间互相切换 w　通过窗口列表切换窗口 ,　重命名当前窗口，便于识别 .　修改当前窗口编号，相当于重新排序 f　在所有窗口中查找关键词，便于窗口多了切换  面板操作（pane）  “　将当前面板上下分屏 %　将当前面板左右分屏 x　关闭当前分屏 !　将当前面板置于新窗口,即新建一个窗口,其中仅包含当前面板 Ctrl+方向键　以1个单元格为单位移动边缘以调整当前面板大小 Alt+方向键　以5个单元格为单位移动边缘以调整当前面板大小 空格键　可以在默认面板布局中切换，试试就知道了 q　显示面板编号 o　选择当前窗口中下一个面板 方向键　移动光标选择对应面板 {　向前置换当前面板 }　向后置换当前面板 Alt+o　逆时针旋转当前窗口的面板 Ctrl+o　顺时针旋转当前窗口的面板 z　tmux 1.8新特性，最大化当前所在面板  Tmux便捷配置 新增Tmux的配置文件 #新建Tmux配置文件 vi $HOME/.tmux.conf 修改Tmux 快捷键前缀为 ctrl+s，便于操作\n#设置前缀 set -g prefix ^s #解除Ctrl+b 与前缀的对应关系 unbind ^b # split window unbind \u0026#39;\u0026#34;\u0026#39; # vertical split (prefix -) bind - splitw -v unbind % bind | splitw -h # horizontal split (prefix |) #将r 设置为加载配置文件，并显示\u0026#34;reloaded!\u0026#34;信息 bind r source-file ~/.tmux.conf \\; display \u0026#34;Reloaded!\u0026#34; #up bind k select-pane -U #down bind j select-pane -D #left bind h select-pane -L #right bind l select-pane -R #kill pane bind q killp setw -g mode-keys vi 设置alias快捷键 alias ta=\u0026#39;tmux a -t \u0026#39; alias tf=\u0026#39;tail -f\u0026#39; alias tls=\u0026#39;tmux ls\u0026#39; alias tnew=\u0026#39;tmux new -s \u0026#39; Oh my tmux 🇫🇷 Oh my tmux! My self-contained, pretty \u0026amp; versatile tmux configuration made with ❤️\nhttps://github.com/gpakosz/.tmux\n更好看、强悍的tmux配置，有时间可以研究\n使用Tips 跳转Tmux窗口号为两位数的窗口 通常使用Prefix + 数字键可以跳转到指定窗口，但是窗口号如果是10，当你按下1的时候就已经跳转到1号窗口了，可以先使用Prefix + ,，然后输入index\n","permalink":"https://aladdinding.cn/2019/08/Tmux%E7%9A%84QuickStart/","summary":"Tmux简介 Tmux 的全称是 Terminal MUtipleXer，及终端复用软件。顾名思义，它的主要功能就是用于在一个终端窗口中运行多个终端会话并且在你关闭终端窗口之后保持进程的运行。 Tmux安装 # Ubuntu 或 Debian $ sudo apt-get install tmux # CentOS 或 Fedora $ sudo yum install tmux # Mac $ brew install tmux Tmux概念 Tmux 中有几个重要概念： 会话（session）:","title":"Tmux的QuickStart"},{"content":"进入Vim    命令 描述     vim filename 打开或新建文件，并将光标置于第一行首   vim +n filename 打开文件，并将光标置于第n行首   vim + flename 打开文件,并将光标置于最后一-行首   vim +/pattern filename 打开文件,并将光标置于第一一个 与pattern匹配的串处   vim -r filename 在上次正用vim编辑时发生系统崩溃，恢复 flename   vim filename\u0026hellip; filename 打开多个文件,依次编辑    Vim配置    命令 描述     all 列出所有选项设置情况   term 设置终端类型   ignorance 在搜索中忽略大小写   list 显示制表位(Ctrl+I)和行尾标志( $)   number 显示行号   report 显示由面向行的命令修改过的数目   terse 显示简短的警告信息   warn 在转到别的文件时若没保存当前文件则显示NO write信息   nomagic 允许vi显示其他用户用write写到自己终端上的信息   nowrapscan 禁止vi在搜索到达文件两端时，又从另- -端开始   mesg 允许vi显示其他用户用write写到自己终端上的信息   :set number/ set nonumber 显示/不显示行号   :set ruler /set noruler 显示不显示标尺   :set hlsearch 高亮显示查找到的单词   :sset nohlsearch 关闭高亮显示   :set nu 显示行号   :set tabstop=8 设置tab大小，8为最常用最普遍的设置   :set softabstop=8 4:4个空格,8:正常的制表符，12:一一个制表符4个空格，16:两个   :set autoindent 自动缩进   :set cindent C语言格式里面的自动缩进    移动光标    命令 描述     k nk 上向上移动n行   j nj 下向下移动n行   h nh 左向左移动n行   I nl 右向右移动n行   Space 光标右移一个字符   Backspace 光标左移一个字符   Enter 光标下移一行   w/W 光标右移一个字至字首   b/B 光标左移一个字至字首   e或E 光标右移一个字至字尾   ) 光标移至句尾   ( 光标移至句首   } 光标移至句首   { 光标移至段落结尾   n$ 光标移至第n行尾   H 光标移至屏幕顶行   M 光标移至屏幕中间行   L 光标移至屏幕最后行   0 (注意是数字零)光标移至当前行首   ^ 移动光标到行首第一个非空字符上去   $ 光标移至当前行尾   gg 移到第一行   G 移到最后一行   f 移动光标到当前行的字符a上   F 相反   % 移动到与制匹配的括号上去( ) ,{},[],\u0026lt;\u0026gt;等   nG 移动到第n行上   G 到最后一行    屏幕滚动    命令 描述     Ctrl+u 向文件首翻半屏   Ctrl+d 向文件尾翻半屏   Ctrl+f 向文件尾翻一屏   Ctrl+ b 向文件首翻一屏   nz 将第n行滚至屏幕顶部,不指定n时将当前行滚至屏幕顶部    插入文本类    命令 描述     i 在光标前   I 在当前行首   a 光标后   A 在当前行尾   o 在当前行之下新开一行   O 在当前行之上新开一行   r 替换当前字符   R 替换当前字符及其后的字符,直至按ESC键   s 从当前光标位置处开始,以输入的文本替代指定数目的字符   S 删除指定数目的行,并以所输入文本代替之   ncw/nCW 修改指定数目的字   nCC 修改指定数目的行    删除命令    命令 描述     x/X 删除-个字符, x删除光标后的,而X删除光标前的   dw 删除一个单词(删除光标位置到下一个单词开始的位置)   dnw 删除n个单词   dne 也可，只是删除到单词尾   do 删至行首   d$ 删至行尾   dd 删除一行   ndd 删除当前行及其后n-1行   dnl 向右删除n个字母   dnh 向左删除n个字母   dnj 向下删除n行，当前行+其上n行   dnk 向上删除n行，当期行+其下n行   cnw[word] 将n个word改变为word   C$ 改变到行尾   cc 改变整行   shift+j 删除行尾的换行符，下一行接上来了    复制粘贴    命令 描述     p 粘贴用x或d删除的文本   ynw 复制n个单词   yy 复制一行   ynl 复制n个字符   y$ 复制当前光标至行尾处   Nay 拷贝n行    撤销    命令 描述     u 撤销前一-次的操作   shif+u(U) 撤销对该行的所有操作    搜索及替换    命令 描述     /pattern 从光标开始处向文件尾搜索pattern   ?pattern 从光标开始处向文件首搜索pattern   n 在同- -方向重复上- -次搜索命令   N 在反方向上重复上一-次搜索命令   cw newword 替换为newword   n 继续查找   . 执行替换   :s/p1/p2/g 将当前行中所有p1均用p2替代，g表示执行用c表示需要确认   :n1,n2 s/p1/p2/g 将第n1至n2行中所有p1均用p2替代   :g/p1/s//p2/g 将文件中所有p1均用p2替换   :1,$ s/string1/string2/g 在全 文中将string1替换为string2    书签    命令 描述     m[a-z] 在文中做标记,标记号可为a-z的26个字母   `a 移动到标记a处    visual模式    命令 描述     v 进入visual模式   V 进入行的visual模式   ctrl+v 进如块操作模式用o和O改变选择的边的大小   在所有行插入相同的内容如include\u0026lt; 将光标移到开始插入的位置，按CTRL+V进入VISUAL模式 ,\n选择好模块后按I（shift+i），后插入要插入的文本，按[ESC]完成    行方式命令    命令 描述     :n1,n2 co n3 将n1行到n2行之间的内容拷贝到第n3行下   :n1,n2 m n3 将n1行到n2行之间的内容移至到第n3行下   :n1,n2 d 将n1行到n2行之间的内容删除   :n1 ,n2 w!command 将文件中n1行至n2行的内容作为command的输入并执行之    若不指定n1，n2，则表示将整个文件内容作为command的输入\n宏    命令 描述     q[a-z] 开始记录但前开始的操作为宏 ,名称可为[a-z] , 然后用q终止录制宏   reg 显示当前定义的所有的宏,用@[a-z]来在当前光标处执行宏[a-z]    窗口操作    命令 描述     :split 分割一个窗口   :split file.c 为另一个文件file c分隔窗口   :nsplit file.c 为另一个文件file c分隔窗口,并指定其行数   ctrl+w 在窗口中切换   :close 关闭当前窗口    文件及其他    命令 描述     :q 退出vi   :q! 不保存文件并退出vi   :e filename 打开文件filename进行编辑   e! 放弃修改文件内容,重新载入该文件编辑   :w 保存当前文件   :wq 存盘退出   :ZZ 保存当前文档并退出Vim   :!command 执行shell命令command   :rlcommand 将命令command的输出结果放到当前行   :n1 ,n2 write temp.c    :read file.c 将文件file.c的内容插入到当前光标所在的下面    ","permalink":"https://aladdinding.cn/2019/08/Vim%E6%93%8D%E4%BD%9C%E9%80%9F%E6%9F%A5/","summary":"进入Vim 命令 描述 vim filename 打开或新建文件，并将光标置于第一行首 vim +n filename 打开文件，并将光标置于第n行首 vim + flename 打开文件,并将光标置于最后一-行首 vim +/pattern filename 打开文件,并将光标置于第一一个 与pattern匹配的串处 vim -r filename 在上次正用vim编辑时发生系统崩溃，恢复 flename vim filename\u0026hellip; filename 打开多个文件,依次编辑 Vim配","title":"Vim操作速查"}]