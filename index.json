[{"content":" SOCKS是一种网络传输协议，主要用于客户端与外网服务器之间通讯的中间传递。SOCKS是\u0026quot;Socket Secure\u0026quot;的缩写。当防火墙后的客户端要访问外部的服务器时，就跟SOCKS代理服务器连接。这个代理服务器控制客户端访问外网的资格，允许的话，就将客户端的请求发往外部的服务器。这个协议最初由David Koblas开发，而后由NEC的Ying-Da Lee将其扩展到SOCKS4。最新协议是SOCKS5，与前一版本相比，增加支持UDP、验证，以及IPv6。根据OSI模型，SOCKS是会话层的协议，位于表示层与传输层之间。SOCKS协定不提供加密。\n SOCKS5 SOCKS协议版本认证 创建与SOCKS5服务器的TCP连接后客户端需要先发送请求来确认协议版本及认证方式（以字节为单位）\nclient send # +----+----------+----------+ # |VER | NMETHODS | METHODS | # +----+----------+----------+ # | 1 | 1 | 1 to 255 | # +----+----------+----------+  VER：SOCKS5协议版本 0x05 NMETHODS：METHODS所占字节长度 METHODS：客户端支持的认证方式列表，每个方法占1字节  0x00 不需要认证 0x01 GSSAPI 0x02 用户名、密码认证 0x03 to 0x7F 由IANA分配（保留） 0x80 to 0xFE 私人方法保留 0xFF 无可接受的方法    服务器从客户端提供的METHODS中选择一个并通过以下消息通知客户端\nserver reply # +----+--------+ # |VER | METHOD | # +----+--------+ # | 1 | 1 | # +----+--------+   VER：协议版本 0x05\n  METHOD：服务端选中的方法。如果返回0xFF表示没有一个认证方法被选中，客户端需要关闭连接。\n  SOCKS用户名密码认证 如果SOCKS协议版本认证中服务端返回的METHOD 是0x02，即需要用户名密码认证，则客户端会发送用户名密码认证信息。如果返回的METHOD是0x00，即不需要认证，直接跳转下一步发送SOCKS请求信息。\nclient send # +----+------+----------+------+----------+ # |VER | ULEN | UNAME | PLEN | PASSWD | # +----+------+----------+------+----------+ # | 1 | 1 | 1 to 255 | 1 | 1 to 255 | # +----+------+----------+------+----------+  VER：认证协议版本 0x01 ULEN：用户名长度 UNAME： 用户名 PLEN：密码长度 PASSWD：密码  server reply # +----+--------+ # |VER | STATUS | # +----+--------+ # | 1 | 1 | # +----+--------+  VER：认证协议版本 0x01 STATUS：认证状态  0x00 成功 0x01 失败    发送SOCKS请求信息 认证结束后客户端就可以发送请求信息。如果认证方法有特殊封装要求，请求必须按照方法所定义的方式进行封装。\nclient send # +----+-----+-------+------+----------+----------+ # |VER | CMD | RSV | ATYP | DST.ADDR | DST.PORT | # +----+-----+-------+------+----------+----------+ # | 1 | 1 | X'00' | 1 | Variable | 2 | # +----+-----+-------+------+----------+----------+  VER：SOCKS5协议版本 0x05 CMD：SOCK命令码  0x01 CONNECT请求 0x02 BIND请求 0x03 UDP转发   RSV：0x00 保留 ATYP：DST.ADDR类型  0x01 IPv4地址，DST.ADDR部分4字节长度 0x03 域名，DST.ADDR部分第一个字节为域名长度，DST.ADDR剩余的内容为域名，没有\\0结尾。 0x04 IPv6地址，16个字节长度。   DST.ADDR：目的地址 DST.PORT：网络字节序表示的目的端口  server reply # +----+-----+-------+------+----------+----------+ # |VER | REP | RSV | ATYP | BND.ADDR | BND.PORT | # +----+-----+-------+------+----------+----------+ # | 1 | 1 | X'00' | 1 | Variable | 2 | # +----+-----+-------+------+----------+----------+  VER：SOCKS5协议版本 0x05 REP：应答字段  0x00 成功 0x01常规SOCKS服务器连接失败 0x02 现有规则不允许连接 0x03 网络不可达 0x04 主机不可达 0x05 连接被拒 0x06 TTL超时 0x07 不支持的命令 0x08 不支持的地址类型 0x09 to 0xFF 未定义   RSV：0x00 保留 ATYP：BND.ADDR类型  0x01 IPv4地址，DST.ADDR部分4字节长度 0x03 域名，DST.ADDR部分第一个字节为域名长度，DST.ADDR剩余的内容为域名，没有\\0结尾。 0x04 IPv6地址，16个字节长度。   BND.ADDR：服务器绑定的地址 BND.PORT：网络字节序表示的服务器绑定的端口  当服务端返回REP应答字段为0x00，即成功时，客户端和服务端之间进行数据透传，完成SOCKS5代理。\nSOCKS4 SOCKS 4只支持TCP转发\n发送SOCKS请求信息 client send # +----+------+----------+--------+----------+----------+ # |VN | CD | DSTPORT | DSTIP | USERID | NULL | # +----+------+----------+--------+----------+----------+ # | 1 | 1 | 2 | 4 | variable | 1 | # +----+------+----------+--------+----------+----------+  VN：SOCKS4协议版本 0x04 CD：SOCK命令码  0x01 CONNECT请求 0x02 BIND请求   DSTPORT：目的主机的端口 DSTIP：目的主机的IP地址 USERID：用户USERID NULL：0x00  server reply # +-------+-------+----------+-----------+ # | VN | CD | DSTPORT | DSTIP | # +-------+-------+----------+-----------+ # | 1 | 1 | 2 | 4 | # +-------+-------+----------+-----------+  VN：回复代码的版本，应为0x00(注意不是0x04) CD：SOCK命令码  90(0x5a) 请求得到允许； 91(0x5b) 请求被拒绝或失败； 92(0x5c) 由于SOCKS服务器无法连接到客户端的identd（一个验证身份的进程），请求被拒绝； 93(0x5d) 由于客户端程序与identd报告的用户身份不同，连接被拒绝。   DSTPORT：目的主机的端口（和请求包中相同） DSTIP：目的主机的IP地址（和请求包中相同）  当服务端返回CD字段为90(0x5a)，即允许时，客户端和服务端之间进行数据透传，完成SOCKS4代理。\nSOCKS4a SOCKS4a协议是SOCKS4的一个补丁版，可以在SOCKS4a代理服务器上完成DNS解析\n发送SOCKS请求信息 client send # +----+------+----------+--------+----------+----------+------------+----------+ # |VN | CD | DSTPORT | DSTIP | USERID | NULL | HOSTNAME | NULL | # +----+------+----------+--------+----------+----------+------------+----------+ # | 1 | 1 | 2 | 4 | variable | 1 | variable | 1 | # +----+------+----------+--------+----------+----------+------------+----------+  DSTIP：0.0.0.x，其中x是非零，一般都为1。（原文：such an address is inadmissible as a destination IP address and thus should never occur if the client can resolve the domain name） HOSTNAME：域名  其余字段和SOCKS4相同\nserver reply SOCKS4a代理首先把HOSTNAME如：www.example.com 解析成对应的主机IP地址，并且和IP地址连接上，再向客户端发送和SOCKS4一样的响应。当服务端返回CD字段为90(0x5a)，即允许时，客户端和服务端之间进行数据透传，完成SOCKS4a代理。\nSOCKS4，SOCKS4a和SOCKS5的区别 比如浏览器使用SOCKS4代理访问www.baidu.com，浏览器先用本地的DNS解析把www.baidu.com转换成对应的IP地址，然后向SOCKS4服务器发送报文。如果此时我们的电脑受限本地完成不了DNS解析，那怎么办呢？SOCKS4a就是解决这样的问题的，客户端可以把域名发送到SOCKS4a服务器上完成DNS解析，发送的DSTIP则为0.0.0.1这样的假IP，然后就是和SOCKS4一样进行数据转发。SOCKS5代理和SOCKS4 SOCKS4a比，多了一个验证功能和udp代理的功能。\nSOCKS协议RFC  SOCKS4.protocol.txt and SOCKS4A.protocol.txt for SOCKS 4 and the SOCKS 4A extension, respectively. SOCKS5_rfc1928.txt and SOCKS5_rfc1929.txt for SOCKS 5, and SOCKS 5 Username/Password authentication.  ","permalink":"https://aladdinding.cn/2020/07/SOCKS%E5%8D%8F%E8%AE%AE%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/","summary":"SOCKS是一种网络传输协议，主要用于客户端与外网服务器之间通讯的中间传递。SOCKS是\u0026quot;Socket Secure\u0026quot;的缩写。当防火墙后的客户端要访问外部的服务器时，就跟SOCKS代理服务器连接。这个代理服务器控制客户端访问外网的资格，允许的话，就将客户端的请求","title":"SOCKS协议开发记录"},{"content":" ApacheBench（ab）是用于对Apache超文本传输协议（HTTP）服务器进行基准测试的工具。ab命令会创建很多的并发访问线程，模拟多个访问者同时对某一URL地址进行访问。它的测试目标是基于URL的，因此，既可以用来测试Apache的负载压力，也可以测试nginx、lighthttp、tomcat、IIS等其它Web服务器的压力。ab命令对发出负载的计算机要求很低，既不会占用很高CPU，也不会占用很多内存，但却会给目标服务器造成巨大的负载，其原理类似CC攻击。自己测试使用也须注意，否则一次上太多的负载，可能造成目标服务器因资源耗完，严重时甚至导致死机。\n ApacheBench安装 macOS Mac下自带apache，查看版本：\napachectl -v 查看ab版本:\nab -V Window Windows系统Apache：下载链接\nLinux Ubuntu\napt-get install apache2-utils CentOS\nyum -y install httpd-tools ApacheBench使用 Options ab压力测试工具的用法，查看：\nab -h # 或者 man ab Usage: ab [options] [http[s]://]hostname[:port]/path Options are: -n requests Number of requests to perform # 在测试会话中所执行的请求个数（本次测试总共要访问页面的次数）。默认时，仅执行一个请求。 -c concurrency Number of multiple requests to make at a time # 一次产生的请求个数（并发数）。默认是一次一个。 -t timelimit Seconds to max. to spend on benchmarking This implies -n 50000 # 测试所进行的最大秒数。其内部隐含值是-n 50000。它可以使对服务器的测试限制在一个固定的总时间以内。默认时，没有时间限制。 -s timeout Seconds to max. wait for each response Default is 30 seconds # 套接字超时之前要等待的最大秒数。默认值为30秒。在2.4.4及更高版本中可用。  -b windowsize Size of TCP send/receive buffer, in bytes # TCP发送/接收缓冲区的大小，以字节为单位。 -B address Address to bind to when making outgoing connections # 建立传出连接时要绑定的地址。 -p postfile File containing data to POST. Remember also to set -T # 包含要发布的数据的文件。记住也要设置-T。 -u putfile File containing data to PUT. Remember also to set -T # 包含数据到PUT的文件。记住也要设置-T。 -T content-type Content-type header to use for POST/PUT data, eg. \u0026#39;application/x-www-form-urlencoded\u0026#39; Default is \u0026#39;text/plain\u0026#39; # 用于POST / PUT数据的内容类型标头，例如 application/x-www-form-urlencoded。默认值为text/plain。 -v verbosity How much troubleshooting info to print # 设置详细级别 4上方将在标题上显示信息，3上方将显示响应代码（404、200等），2上方将显示警告和信息。 -w Print out results in HTML tables # 在HTML表格中打印出结果。默认表是两列宽，带有白色背景。 -i Use HEAD instead of GET # 做HEAD请求，而不是GET。 -x attributes String to insert as table attributes # 用作的属性的字符串\u0026lt;table\u0026gt;。插入属性。\u0026lt;table here \u0026gt; -y attributes String to insert as tr attributes # 用作的属性的字符串\u0026lt;tr\u0026gt;。 -z attributes String to insert as td or th attributes # 用作的属性的字符串\u0026lt;td\u0026gt;。 -C attribute Add cookie, eg. \u0026#39;Apache=1234\u0026#39;. (repeatable) # cookie-name=value 对请求附加一个Cookie:行。 其典型形式是name=value的一个参数对。此参数可以重复，用逗号分割。 -H attribute Add Arbitrary header line, eg. \u0026#39;Accept-Encoding: gzip\u0026#39; Inserted after all normal header lines. (repeatable) # 将额外的标头添加到请求。该参数是典型地在一个有效报头线的形式，含有一个冒号分隔的字段值对（即，\u0026#34;Accept-Encoding: zip/zop;8bit\u0026#34;）。 -A attribute Add Basic WWW Authentication, the attributes are a colon separated username and password. # 向服务器提供BASIC身份验证凭据。用户名和密码用单个:分隔，并通过编码为base64的网络发送。无论服务器是否需要该字符串，都将发送该字符串（即，已发送所需的401身份验证）。 -P attribute Add Basic Proxy Authentication, the attributes are a colon separated username and password. # 在代理途中提供BASIC身份验证凭据。用户名和密码用单个:分隔，并通过编码为base64的网络发送。不管代理是否需要它都将发送该字符串（即，已发送所需的407代理身份验证）。 -X proxy:port Proxyserver and port number to use # 使用代理服务器处理请求。 -V Print version number and exit # 显示版本号并退出。 -k Use HTTP KeepAlive feature # 启用HTTP KeepAlive功能，即在一个HTTP会话中执行多个请求。默认为no KeepAlive。 -d Do not show percentiles served table. # 不要显示“ XX [ms]表中的投放百分比”。（旧版支持）。 -S Do not show confidence estimators and warnings. # 当平均值和中位数相距标准偏差的一倍或两倍以上时，请勿显示中位数和标准偏差值，也不会显示警告/错误消息。并默认为最小值/平均值/最大值。（旧版支持）。 -q Do not show progress when doing more than 150 requests # 当处理150个以上的请求时，每10％或100个左右的请求ab输出进度计数stderr。该 -q标志将禁止显示这些消息。 -l Accept variable document length (use this for dynamic pages) # 如果响应的长度不是恒定的，请不要报告错误。这对于动态页面很有用。在2.4.7及更高版本中可用。 -g filename Output collected data to gnuplot format file. # 将所有测量值写为“ gnuplot”或TSV（制表符单独值）文件。此文件可以轻松导入到Gnuplot，IDL，Mathematica，Igor甚至Excel等软件包中。标签位于文件的第一行。 -e filename Output CSV file with percentages served # 编写一个逗号分隔值（CSV）文件，其中包含为每个百分比（从1％到100％）提供该百分比请求所花费的时间（以毫秒为单位）。通常，它比“ gnuplot”文件有用。因为结果已经“装箱”了。 -r Don not exit on socket receive errors. # 套接字接收错误时不退出 -m method Method name # 请求的自定义HTTP方法。在2.4.10及更高版本中可用。 -h Display usage information (this message) # 显示使用情况信息。 -I Disable TLS Server Name Indication (SNI) extension # 禁用TLS服务器名称指示(SNI)扩展 -Z ciphersuite Specify SSL/TLS cipher suite (See openssl ciphers) # 指定SSL / TLS密码套件（请参阅openssl密码） -f protocol Specify SSL/TLS protocol (SSL2, TLS1, TLS1.1, TLS1.2 or ALL) # 指定SSL / TLS协议（SSL2，SSL3，TLS1，TLS1.1，TLS1.2或ALL）。TLS1.1和TLS1.2支持在2.4.4及更高版本中提供。 -E certfile Specify optional client certificate chain and private key # 指定可选的客户端证书链和私钥 Output 执行命令\nab -n 1000 -c 200 http://pts.aliyun.com/lite/index.htm/ 获取结果分析\n# apache版本信息 This is ApacheBench, Version 2.3 \u0026lt;$Revision: 1843412 $\u0026gt; Copyright 1996 Adam Twiss, Zeus Technology Ltd, http://www.zeustech.net/ Licensed to The Apache Software Foundation, http://www.apache.org/ Benchmarking pts.aliyun.com (be patient) Completed 100 requests Completed 200 requests Completed 300 requests Completed 400 requests Completed 500 requests Completed 600 requests Completed 700 requests Completed 800 requests Completed 900 requests Completed 1000 requests Finished 1000 requests # 请求返回header类型 Server Software: Tengine/Aserver # 请求ip或者域名 Server Hostname: pts.aliyun.com # 请求端口，当前请求为https所以端口为443，请求https端口80 Server Port: 80 # 从命令行字符串解析请求URI。 Document Path: /lite/index.htm/ # 这是第一个成功返回的文档的大小（以字节为单位）。如果在测试过程中文档长度发生变化，则将响应视为错误。 Document Length: 357 bytes # 测试期间使用的并发客户端数 Concurrency Level: 200 从建立连接到最后接受完成总时间 Time taken for tests: 1.280 seconds # 完成请求数 Complete requests: 1000 # 失败请求数 Failed requests: 0 # 不在200系列响应代码中的响应数。如果所有响应均为200，则不会打印此字段。 Non-2xx responses: 1000 # 从服务器接收的字节总数 Total transferred: 642000 bytes # HTML接收字节数，减去了Total transferred中HTTP响应数据中的头信息的长度 HTML transferred: 357000 bytes # 吞吐率：每秒请求数（总请求数/总时间，相当于LR中的每秒事务数TPS） Requests per second: 781.47 [#/sec] (mean) # 用户平均请求等待时间 Time per request: 255.928 [ms] (mean) # 服务器处理每个请求平均响应时间，mean表示为平均值 Time per request: 1.280 [ms] (mean, across all concurrent requests) # 由公式计算得出的传输速率 totalread / 1024 / timetaken Transfer rate: 489.95 [Kbytes/sec] received # 连接消耗时间分解 Connection Times (ms) min mean[+/-sd] median max 最小值 平均值 标准差 中间值 最大值 Connect: 22 30 4.0 30 38 Processing: 22 95 164.5 34 1200 Waiting: 22 83 154.3 33 1200 Total: 46 125 163.4 66 1227 # 按完成请求的百分比，得出完成请求中花费时间最长的那一个请求的时间，也就是这些请求完成时间的最大值（毫秒） Percentage of the requests served within a certain time (ms) # 50%请求完成时间的最大值是66毫秒 50% 66 66% 69 75% 71 80% 80 90% 317 # 90%请求完成时间的最大值是148毫秒 95% 536 98% 744 99% 825 # // 100%请求完成时间的最大值是1227毫秒（最长请求） 100% 1227 (longest request) 性能指标 1、吞吐率（Requests per second） 服务器并发处理能力的量化描述，单位是reqs/s，指的是在某个并发用户数下单位时间内处理的请求数。某个并发用户数下单位时间内能处理的最大请求数，称之为最大吞吐率。 记住：吞吐率是基于并发用户数的。这句话代表了两个含义： a、吞吐率和并发用户数相关； b、不同的并发用户数下，吞吐率一般是不同的。 计算公式：总请求数/处理完成这些请求数所花费的时间，即： Request per second=Complete requests/Time taken for tests 必须要说明的是，这个数值表示当前机器的整体性能，值越大越好。\n2、并发连接数（The number of concurrent connections） 并发连接数指的是某个时刻服务器所接受的请求数目，简单的讲，就是一个会话。\n3、并发用户数（Concurrency Level） 要注意区分这个概念和并发连接数之间的区别，一个用户可能同时会产生多个会话，也即连接数。在HTTP/1.1下，IE7支持两个并发连接，IE8支持6个并发连接，FireFox3支持4个并发连接，所以相应的，我们的并发用户数就得除以这个基数。\n4、用户平均请求等待时间（Time per request） 计算公式：处理完成所有请求数所花费的时间/（总请求数/并发用户数），即：Time per request=Time taken for tests/（Complete requests/Concurrency Level）\n5、服务器平均请求等待时间（Time per request:across all concurrent requests） 计算公式：处理完成所有请求数所花费的时间/总请求数，即： Time taken for/testsComplete requests 可以看到，它是吞吐率的倒数。同时，它也等于用户平均请求等待时间/并发用户数，即： Time per request/Concurrency Level\n","permalink":"https://aladdinding.cn/2020/05/ApacheBench-HTTP%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/","summary":"ApacheBench（ab）是用于对Apache超文本传输协议（HTTP）服务器进行基准测试的工具。ab命令会创建很多的并发访问线程，模拟多个访问者同时对某一URL地址进行访问。它的测试目标是基于URL的，因此，既可以用来测试Apache的负载压力，也可以测试nginx、lig","title":"ApacheBench HTTP服务器基准测试工具使用总结"},{"content":"从我毕业进入公司起，王哥（技术leader）就一直在提及一点：编程不仅仅是知识和技能，更重要的是去领会编程领域的文化。刚进入公司的我似乎并没有马上接受这一点，认为这可能只是所谓的“玄学”罢了，所以也就是当作任务记下了个一点，并没有很好的理会。直到我工作了一年后，疫情期间读完王哥发来的一篇《如何成为一名黑客》，似乎逐渐理解了王哥在这一年中对我的指导，并且解答了我初入编程行业的疑惑。\n文章的标题是如何成为一名黑客，这里的黑客并不是我们所认为的在网络中来无影去无踪的“黑客”，能让更多人理解的应该是极客。在我看来，这篇文章讲述的是你如何成为一名优秀并且受人尊敬的编程人士。\n基本的态度  这个世界充满了令人着迷的问题等着我们去解决  你要从解决问题，磨练技术，以及锻炼智力中得到基本的享受以及动力。的确，回想这一年的工作时光，另我开心的事情莫过于解决了棘手问题，学习了一门新的语言，自己完成的功能第二天就上线，得到了客户的认可等等。   一个问题不应该被解决两次  不应该把宝贵的时间浪费在发明轮子上。初入公司我想着把很多python2的代码重构成python3，现在想想确实浪费时间，应该着重于解决新的问题而不是在旧问题上浪费时间。   无聊和乏味的工作是罪恶的  重复性劳动浪费我们解决新问题的时间，而解决新问题才是最大的价值所在。提取公共函数，将日常的工作变成自动化等等。   崇尚自由  其实这一点并不是很理解。。产品经理提出无理的需求？？？ 2020/09/10更新：这个上升到政治层面就比较好理解了，从美国打压WeChat和Tik Tok可以看出   态度不能代替能力  只具备这些态度并不能使你成为一名黑客，也不能使你成为一个运动健将和摇滚明星。成为一名黑客需要智力、实践、奉献精神、以及辛苦的工作。    基本的技能  学习如何编程（这里包括以下内容有几句话写的很好，我想全搬运过来）  有一个大体的规律，就是如果你过于偏重使用一种语言，这种语言一方面会成为你得心应手的工具，另一方面也会阻碍你的学习。有这个问题的不只是编程语言，类似 RubyOnRails、CakePHP、以及 Django 的 web 应用框架也有这个问题，它们只会让你肤浅地懂得一些东西，当你碰到难以解决的问题或者需要调试时，你就可能不知所措了。 单单学习编程语言并不会让你达到黑客的程度，甚至连程序员的程度都难企及——你需要脱离某种编程语言的素服，学习通过编程解决问题的思路。要成为一个真正的黑客，你需要达到几天就能学会一门编程语言的水平，你可以将文档里的信息和你已经掌握的知识结合起来，很快就学会一门编程语言。这意味着你需要先学会机种思路截然不同的语言才行。 编程是一个复杂的技能，我无法给你完整的指南来教会你如何编程，不过我可以告诉你，书本和课程也无法教会你如何编程——很多黑客，或者也许几乎所有的黑客，都是靠自学的。你从书本上学到语言的特点——只是一些皮毛，但要使书面知识成为自身技能，你只能通过实践和虚心向他人学习。因此你要做的就是 (a) 读代码，(b) 写代码。 学习编程就象学习自然语言写作一样。最好的做法是读一些大师的名著，试着自己写点东西，再读些，再写点，再读些，再写点……如此往复，直到你的文章具备范文的力量和感觉为止。   学会使用开源的Unix系统  Unix 还是 Internet 的操作系统。你可以学会上网却不知道 Unix，但你不了解 Unix 就无法成为一名 Internet 黑客。因此，今天的黑客文化在很大程度上是以 Unix 为核心的。（这点并不总是真的，一些很早的黑客对此一直很不满，但 Unix 和 Internet 之间的联系已是如此之强，就连 Microsoft 这样强力的公司也对此也无可奈何。）   学会使用万维网以及编写HTML  学会使用Google，Stack Overflow，Github等等   学习英语，如果你的水平不够的话  Linus Torvalds 是芬兰人，但他的代码注解是用英语写的（很明显他从没想过其他的可能性）。他流利的英语。是他能够管理全球范围的 Linux 开发人员社区的重要因素。 这是一个值得学习的例子。 就算你的母语是英语，这也无法保证你的语言技能足够达到黑客的标准。如果你的写作文字不通、语法混乱、错字连篇，包括我在内的大部分的黑客都会忽略你的存在。虽然写作马虎不一定意味着思考也马虎，但我们发现两者的关联性还是挺强的——马虎的头脑对我们来说毫无价值，如果你写作能力不够，就好好学习写作吧。（划重点，终于知道王哥为什么每次都会特别强调然后纠正我的错别字了）    提高自己在编程圈中的地位 以下就是以后的人生所追求的吧，自己离这些还很遥远。。。\n  撰写开源软件\n 黑客领域里最受尊敬的偶像，是那些写了大型的、好用的、用途广泛的软件，并把它们发布出来，使得每人都在使用他软件的人。    帮助测试并调试开源软件\n 如果你是个新手，试着找一个你感兴趣的正在开发中的程序，做一个好的 beta 测试员。你会自然地从帮着测试，进步到帮着抓 bug，到最后帮着改程序。你会从中学到很多，而且善因种善果，以后别人也会很乐意帮助你。    发布有用的信息\n 另一件好事是收集整理有用有趣的信息，做成网页或类似 FAQ 的文档，并且让大家都能看到。技术性 FAQ 的维护者会受到和开源代码的作者一样多的尊敬。（比如Github上面很多awesome language和国内很多大佬的博客，录制的教程等等）    帮助维护基础设施的运转\n  黑客文化（还有互联网工程方面的发展）是靠志愿者推动的。要使Internet能正常工作，就要有大量枯燥的工作不得不去完成——管理邮件列表和新闻组，维护大型软件库，开发 RFC 和其它技术标准等等。\n做这类事情的人会得到很多尊敬，因为每人都知道这些事情费时颇多，而又不象编程那样有趣。做这些事情需要奉献精神。\n    为黑客文化本身服务\n 黑客文化没有领袖，这点是确认无疑的。但黑客圈里确实有些文化英雄、部落长者、史学家、还有发言人。如果你在这圈里呆足够长时间，你也许也能成为其中之一。 记住：黑客们不相信他们的部落长者的自夸，因此过分追求这种名誉是危险的。与其奋力追求，不如先摆正自己的位置，等它自己落到你的手中——那时则要做到谦虚和优雅。    常读常新，每隔一段时间读一遍都会有新的收获。最后附上这篇文档。\n如何成为一名黑客\n","permalink":"https://aladdinding.cn/2020/04/%E8%AF%BB%E5%A6%82%E4%BD%95%E6%88%90%E4%B8%BA%E4%B8%80%E5%90%8D%E9%BB%91%E5%AE%A2%E6%9C%89%E6%84%9F/","summary":"从我毕业进入公司起，王哥（技术leader）就一直在提及一点：编程不仅仅是知识和技能，更重要的是去领会编程领域的文化。刚进入公司的我似乎并没有马上接受这一点，认为这可能只是所谓的“玄学”罢了，所以也就是当作任务记下了个一点，并没有很好的理会。直到我工作了一年后，疫情期间读完王哥发","title":"读《如何成为一名黑客》有感"},{"content":"原文  Beautiful is better than ugly. Explicit is better than implicit. Simple is better than complex. Complex is better than complicated. Flat is better than nested. Sparse is better than dense. Readability counts. Special cases aren\u0026rsquo;t special enough to break the rules. Although practicality beats purity. Errors should never pass silently. Unless explicitly silenced. In the face of ambiguity, refuse the temptation to guess. There should be one\u0026ndash; and preferably only one \u0026ndash;obvious way to do it. Although that way may not be obvious at first unless you\u0026rsquo;re Dutch. Now is better than never. Although never is often better than right now. If the implementation is hard to explain, it\u0026rsquo;s a bad idea. If the implementation is easy to explain, it may be a good idea. Namespaces are one honking great idea \u0026ndash; let\u0026rsquo;s do more of those!\n 解读 The Zen of Python是Python语言的指导原则，遵循这些基本原则，你就可以像个Pythonista一样编程。具体内容你可以在Python命令行输import this看到：\n  Beautiful is better than ugly.\n# 优美胜于丑陋（Python以编写优美的代码为目标）\n  Explicit is better than implicit.\n# 明了胜于晦涩（优美的代码应当是明了的，命名规范，风格相似）\n  Simple is better than complex.\n# 简洁胜于复杂（优美的代码应当是简洁的，不要有复杂的内部实现）\n  Complex is better than complicated.\n# 复杂胜于凌乱（如果复杂不可避免，那代码间也不能有难懂的关系，要保持接口简洁）\n  Flat is better than nested.\n# 扁平胜于嵌套（优美的代码应当是扁平的，不能有太多的嵌套）\n  Sparse is better than dense.\n# 间隔胜于紧凑（优美的代码有适当的间隔，不要奢望一行代码解决问题）\n  Readability counts.\n# 可读性很重要（优美的代码是可读的）\n  Special cases aren\u0026rsquo;t special enough to break the rules. Although practicality beats purity.\n# 即便假借特例的实用性之名，也不可违背这些规则（这些规则至高无上）\n  Errors should never pass silently. Unless explicitly silenced.\n# 不要包容所有错误，除非你确定需要这样做（精准地捕获异常，不写except:pass风格的代码）\n  In the face of ambiguity, refuse the temptation to guess.\n# 当存在多种可能，不要尝试去猜测\n  There should be one\u0026ndash; and preferably only one \u0026ndash;obvious way to do it.\n# 而是尽量找一种，最好是唯一一种明显的解决方案（如果不确定，就用穷举法）\n  Although that way may not be obvious at first unless you\u0026rsquo;re Dutch.\n# 虽然这并不容易，因为你不是 Python 之父（这里的Dutch是指Guido）\n  Now is better than never. Although never is often better than right now.\n# 做也许好过不做，但不假思索就动手还不如不做（动手之前要细思量）\n  If the implementation is hard to explain, it\u0026rsquo;s a bad idea.\n# 如果你无法向人描述你的方案，那肯定不是一个好方案\n  If the implementation is easy to explain, it may be a good idea.\n# 如果你能向人简洁描述你的方案，那也许是一个好方案（方案测评标准）\n  Namespaces are one honking great idea \u0026ndash; let\u0026rsquo;s do more of those!\n# 命名空间是一种绝妙的理念，我们应当多加利用（倡导与号召）\n  这首特别的“诗”开始作为一个笑话，但它确实包含了很多关于Python背后的哲学真理。Python之禅已经正式成文PEP 20，具体内容见：PEP 20\n","permalink":"https://aladdinding.cn/2020/01/The-Zen-of-Python/","summary":"The Zen of Python是Python语言的指导原则，遵循这些基本原则，你就可以像个Pythonista一样编程。","title":"The Zen of Python"}]