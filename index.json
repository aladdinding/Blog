[{"categories":["协议"],"content":"现象 这段时间通过上服务器观察日志，发现部分语言的 HTTP 客户端在进行代理认证的时候会发送两次 HTTP 请求 第一次请求不会携带任何认证信息 第二次请求才会携带上 Proxy-Authorization 的 Header 涉及到的 HTTP 客户端还是很多的，例如： Java 的 httpclient、jsoup C# 的 HTTP 客户端 Chrome 使用 SwitchyOmega 插件 ","date":"2022-11-18","objectID":"/%E4%B8%BA%E4%BB%80%E4%B9%88proxy%E8%AE%A4%E8%AF%81%E8%A6%81%E5%8F%91%E4%B8%A4%E6%AC%A1%E8%AF%B7%E6%B1%82/:1:0","tags":["http"],"title":"为什么 Proxy 认证要发两次请求","uri":"/%E4%B8%BA%E4%BB%80%E4%B9%88proxy%E8%AE%A4%E8%AF%81%E8%A6%81%E5%8F%91%E4%B8%A4%E6%AC%A1%E8%AF%B7%E6%B1%82/"},{"categories":["协议"],"content":"原因 Go 的 net 包和 Python 的 Request 就没有这个问题，虽然在用户侧发送两次请求是无感知的，但是一个请求发送两次，相应耗时还是会增加的 由于对 Java 等不太熟悉，就不直接看源码了，google 找了下问题原因： rfc2616：Proxy-Authenticate HttpClient 4.2.2 and Proxy with username/password 直接破案了，因为 HTTP 协议中的 Proxy-Authenticate Header，当请求中没有 Proxy-Authorization 时，它需要伴随着 407 (Proxy Authentication Required) 一并返回给客户端，告诉客户端使用那种认证方式 最常见的就是 Basic 认证（用户名: 密码计算 base64）： func BasicAuth(username, password string) string { auth := username + \":\" + password return base64.StdEncoding.EncodeToString([]byte(auth)) } 除了 Basic，还有如下认证方案 ： HTTP/Authentication Basic (查看 RFC 7617 ，base64 编码凭证。详情请参阅下文.), Bearer (查看 RFC 6750 ，bearer 令牌通过 OAuth 2.0 保护资源), Digest (查看 RFC 7616 ，只有 md5 散列 在 Firefox 中支持，查看 bug 472823 用于 SHA 加密支持), HOBA (查看 RFC 7486 （草案），HTTP Origin-Bound 认证，基于数字签名), Mutual (查看 draft-ietf-httpauth-mutual ), AWS4-HMAC-SHA256 (查看 AWS docs ) 后来进行测试，当 Proxy 返回 407 不带 Proxy-Authenticate: Basic，这种发送两次的 HTTP 客户端就不会在发送第二次请求了（当然用户收到的请求状态码也是 407）… 回到最初的问题，发送两次的原因就是 第一次要拿到 Proxy-Authenticate，Proxy 是通过什么方式认证的，如 Basic 通过返回的认证方式使用对应的算法对认证信息进行编码 ","date":"2022-11-18","objectID":"/%E4%B8%BA%E4%BB%80%E4%B9%88proxy%E8%AE%A4%E8%AF%81%E8%A6%81%E5%8F%91%E4%B8%A4%E6%AC%A1%E8%AF%B7%E6%B1%82/:2:0","tags":["http"],"title":"为什么 Proxy 认证要发两次请求","uri":"/%E4%B8%BA%E4%BB%80%E4%B9%88proxy%E8%AE%A4%E8%AF%81%E8%A6%81%E5%8F%91%E4%B8%A4%E6%AC%A1%E8%AF%B7%E6%B1%82/"},{"categories":["协议"],"content":"改进 发送两次的 HTTP 客户端更多的考虑到通用性，用户可以在不知道 Proxy 使用什么认证方式的情况下正常使用 开发者在实际项目使用中，考虑到性能因素，在知道认证方式的情况下： 不使用 HTTP 框架提供的认证写法，直接把 Proxy-Authorization 添加到 Header 中 使用白名单 IP 认证 对于那些每次发送两次的 HTTP 框架也有优化方向 能自主选择认证方式，像 Go、Python 这类的认证方式默认就是 Basic 对于地址相同的 Proxy，第一次拿到认证方式后进行缓存，后续就不必在每次请求发送两次 ","date":"2022-11-18","objectID":"/%E4%B8%BA%E4%BB%80%E4%B9%88proxy%E8%AE%A4%E8%AF%81%E8%A6%81%E5%8F%91%E4%B8%A4%E6%AC%A1%E8%AF%B7%E6%B1%82/:3:0","tags":["http"],"title":"为什么 Proxy 认证要发两次请求","uri":"/%E4%B8%BA%E4%BB%80%E4%B9%88proxy%E8%AE%A4%E8%AF%81%E8%A6%81%E5%8F%91%E4%B8%A4%E6%AC%A1%E8%AF%B7%E6%B1%82/"},{"categories":["系统设计"],"content":" 单例模式 是保证一个类仅有一个实例，并提供一个访问它的全局访问点。 简单工厂模式 通过专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。 工厂方法模式 定义一个创建产品对象的工厂接口，将实际创建工作推迟到子类中。 抽象工厂模式 提供一个创建一系列相关或者相互依赖的接口，而无需指定它们具体的类。 原型模式 用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。 建造者模式 将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。 简单工厂模式：一个工厂负责创建所有产品（多个类共用一个Create函数） 违反“开闭原则”，添加新产品需要修改工厂逻辑，工厂越来越复杂 工厂方法模式：一个工厂创建一个产品（每个类都有一个Create函数） 系统的可扩展性也就变得非常好，无需修改接口和原类 增加系统中类的个数，复杂度和理解度增加（一个具体产品就需要对应一个具体工厂） 抽象方法模式：一个工厂创建一系列（一个产品族）的产品（一个产品族一个Create） 增加新的产品族很方便，无须修改已有系统，符合“开闭原则” 增加新的产品等级结构麻烦，需要对原有系统进行较大的修改，违背了“开闭原则” 相当于在工厂方法模式的基础下进行了折中 对于产品族来说遵循了开闭原则 对于产品等级结构来说没有遵循开闭原则 如果产品结构等级稳定，那么就相当于完全遵循开闭原则 ","date":"2022-10-24","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/:0:0","tags":["设计模式"],"title":"设计模式之创建型模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"},{"categories":["系统设计"],"content":" 面向对象设计原则为支持可维护性复用而诞生，这些原则蕴含在很多设计模式中，它们是从许多设计方案中总结出的指导性原则。 单一职责原则 类的职责单一，对外只提供一种功能，而引起类变化的原因都应该只有一个。 一个类对外只提供一种功能。 开闭原则 类的改动是通过增加代码进行的，而不是修改源代码。 增加功能时去增加代码而不是修改代码。 里氏替换替换原则 任何抽象类（interface接口）出现的地方都可以用他的实现类进行替换，实际就是虚拟机制，语言级别实现面向对象功能。 依赖倒置原则 依赖于抽象(接口)，不要依赖具体的实现(类)，也就是针对接口编程。 模块与模块依赖抽象而不是具体实现。 接口隔离原则 不应该强迫用户的程序依赖他们不需要的接口方法。一个接口应该只提供一种对外功能，不应该把所有操作都封装到一个接口中去。 合成复用原则 如果使用继承，会导致父类的任何变换都可能影响到子类的行为。如果使用对象组合，就降低了这种依赖关系。对于继承和组合，优先使用组合。 通过组合来实现父类方法。 迪米特法则 一个对象应当对其他对象尽可能少的了解，从而降低各个对象之间的耦合，提高系统的可维护性。例如在一个程序中，各个模块之间相互调用时，通常会提供一个统一的接口来实现。这样其他模块不需要了解另外一个模块的内部实现细节，这样当一个模块内部的实现发生改变时，不会影响其他模块的使用。 依赖第三方来实现解耦。 以上面向对象设计原则对于写代码有什么指导思想呢，我想大致可以分为两点： 对象的职责设置的尽可能单一，后续有需求的更改不需要修改之前的代码。不推荐使用继承（父类发生更改非常容易影响子类），而是多用组合（如Python中常用的mixin，通过组合不同的mixin获得不同的功能）。 在进行系统设计时要考虑三个层次：抽象层、实现层、业务逻辑层。在写业务逻辑层的时候，依赖的是抽象层提供的接口，这样即使是具体实现层的代码改动，或者是需要另一种实现方式，在业务逻辑层也不需要改动。 ","date":"2022-10-07","objectID":"/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/:0:0","tags":["设计模式"],"title":"面向对象设计原则","uri":"/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"},{"categories":["协议"],"content":"场景 在之前的 gRPC 系统中加了个 redis 缓存临时缓冲要上报的数据，对于数据反复序列化肯定是有性能损耗的 而且 gRPC 提供的接口似乎没有可以直接发送已经序列化好的数据，似乎只能从生成的 gRPC 代码下手 ","date":"2022-09-01","objectID":"/grpc%E5%8F%91%E9%80%81%E5%B7%B2%E7%BB%8F%E5%BA%8F%E5%88%97%E5%8C%96%E5%A5%BD%E7%9A%84%E6%95%B0%E6%8D%AE/:1:0","tags":["Python"],"title":"GRPC发送已经序列化好的数据","uri":"/grpc%E5%8F%91%E9%80%81%E5%B7%B2%E7%BB%8F%E5%BA%8F%E5%88%97%E5%8C%96%E5%A5%BD%E7%9A%84%E6%95%B0%E6%8D%AE/"},{"categories":["协议"],"content":"实现 以 Python 代码举例： 发现在 xxx_pb2_grpc.py 文件中无论是 Stub 还是 Master 的消息参数中有下面两项，使用默认值 None 的话就可以直接传递序列化好的字节了 request_deserializer：An optional :term:deserializer for request deserialization response_serializer：An optional :term:serializer for response serialization 为了不直接修改 xxx_pb2_grpc.py，于是继承 Stub 重写 __init__ 好了 class WithoutSerializerStub(xxx_pb2_grpc.Stub): \"\"\"Missing associated documentation comment in .proto file.\"\"\" def __init__(self, channel): \"\"\"Constructor. Args: channel: A grpc.Channel. \"\"\" self.msg = channel.stream_unary( '/server/msg', request_serializer=None, response_deserializer=None, ) 成功搞定！ ","date":"2022-09-01","objectID":"/grpc%E5%8F%91%E9%80%81%E5%B7%B2%E7%BB%8F%E5%BA%8F%E5%88%97%E5%8C%96%E5%A5%BD%E7%9A%84%E6%95%B0%E6%8D%AE/:2:0","tags":["Python"],"title":"GRPC发送已经序列化好的数据","uri":"/grpc%E5%8F%91%E9%80%81%E5%B7%B2%E7%BB%8F%E5%BA%8F%E5%88%97%E5%8C%96%E5%A5%BD%E7%9A%84%E6%95%B0%E6%8D%AE/"},{"categories":["协议"],"content":"PS 后来尝试继承 Stub 后新增一个 without_serializer 的 msg，后发现运行时报错找不到这个属性 先记录一下，以后在找原因 ","date":"2022-09-01","objectID":"/grpc%E5%8F%91%E9%80%81%E5%B7%B2%E7%BB%8F%E5%BA%8F%E5%88%97%E5%8C%96%E5%A5%BD%E7%9A%84%E6%95%B0%E6%8D%AE/:3:0","tags":["Python"],"title":"GRPC发送已经序列化好的数据","uri":"/grpc%E5%8F%91%E9%80%81%E5%B7%B2%E7%BB%8F%E5%BA%8F%E5%88%97%E5%8C%96%E5%A5%BD%E7%9A%84%E6%95%B0%E6%8D%AE/"},{"categories":["协议"],"content":"近期上线项目优化，需要将节点与 master 交互方式从之前的短轮训改进到长连接，同时也需要改进序列化传输方式（之前使用的是序列化 pythoon 对象的 ujosn），很自然就想到了 grpc。 ","date":"2022-07-28","objectID":"/grpc%E6%A1%86%E6%9E%B6%E5%85%A5%E9%97%A8/:0:0","tags":["gRPC"],"title":"GRPC框架入门","uri":"/grpc%E6%A1%86%E6%9E%B6%E5%85%A5%E9%97%A8/"},{"categories":["协议"],"content":"gRPC 是什么 gRPC 是一种现代化开源的高性能 RPC 框架，能够运行于任意环境之中。最初由谷歌进行开发。它使用 HTTP/2 作为传输协议。 Concept Diagram\" Concept Diagram 使用 gRPC， 我们可以一次性的在一个 .proto 文件中定义服务并使用任何支持它的语言去实现客户端和服务端，反过来，它们可以应用在各种场景中，从 Google 的服务器到你自己的平板电脑—— gRPC 帮你解决了不同语言及环境间通信的复杂性。使用 protocol buffers 还能获得其他好处，包括高效的序列化，简单的 IDL 以及容易进行接口更新。总之一句话，使用 gRPC 能让我们更容易编写跨语言的分布式代码。 IDL（Interface description language）是指接口描述语言，是用来描述软件组件接口的一种计算机语言，是跨平台开发的基础。IDL 通过一种中立的方式来描述接口，使得在不同平台上运行的对象和用不同语言编写的程序可以相互通信交流；比如，一个组件用 C++ 写成，另一个组件用 Go 写成。 ","date":"2022-07-28","objectID":"/grpc%E6%A1%86%E6%9E%B6%E5%85%A5%E9%97%A8/:1:0","tags":["gRPC"],"title":"GRPC框架入门","uri":"/grpc%E6%A1%86%E6%9E%B6%E5%85%A5%E9%97%A8/"},{"categories":["协议"],"content":"编写 .proto 文件 官方提供的教学场景（导航服务）很适合入门，覆盖了 RPC 的四种模式，创建 route_guide.proto 文件，定义以下消息和服务 syntax = \"proto3\";option go_package = \"./protos\";package routeguide;// Interface exported by the server. service RouteGuide { // A simple RPC. // // Obtains the feature at a given position. // // A feature with an empty name is returned if there's no feature at the given // position. rpc GetFeature(Point) returns (Feature) {} // A server-to-client streaming RPC. // // Obtains the Features available within the given Rectangle. Results are // streamed rather than returned at once (e.g. in a response message with a // repeated field), as the rectangle may cover a large area and contain a // huge number of features. rpc ListFeatures(Rectangle) returns (stream Feature) {} // A client-to-server streaming RPC. // // Accepts a stream of Points on a route being traversed, returning a // RouteSummary when traversal is completed. rpc RecordRoute(stream Point) returns (RouteSummary) {} // A Bidirectional streaming RPC. // // Accepts a stream of RouteNotes sent while a route is being traversed, // while receiving other RouteNotes (e.g. from other users). rpc RouteChat(stream RouteNote) returns (stream RouteNote) {}}// Points are represented as latitude-longitude pairs in the E7 representation // (degrees multiplied by 10**7 and rounded to the nearest integer). // Latitudes should be in the range +/- 90 degrees and longitude should be in // the range +/- 180 degrees (inclusive). message Point { int32 latitude = 1; int32 longitude = 2;}// A latitude-longitude rectangle, represented as two diagonally opposite // points \"lo\" and \"hi\". message Rectangle { // One corner of the rectangle. Point lo = 1; // The other corner of the rectangle. Point hi = 2;}// A feature names something at a given point. // // If a feature could not be named, the name is empty. message Feature { // The name of the feature. string name = 1; // The point where the feature is detected. Point location = 2;}// A RouteNote is a message sent while at a given point. message RouteNote { // The location from which the message is sent. Point location = 1; // The message to be sent. string message = 2;}// A RouteSummary is received in response to a RecordRoute rpc. // // It contains the number of individual points received, the number of // detected features, and the total distance covered as the cumulative sum of // the distance between each point. message RouteSummary { // The number of points received. int32 point_count = 1; // The number of known features passed while traversing the route. int32 feature_count = 2; // The distance covered in metres. int32 distance = 3; // The duration of the traversal in seconds. int32 elapsed_time = 4;} ","date":"2022-07-28","objectID":"/grpc%E6%A1%86%E6%9E%B6%E5%85%A5%E9%97%A8/:2:0","tags":["gRPC"],"title":"GRPC框架入门","uri":"/grpc%E6%A1%86%E6%9E%B6%E5%85%A5%E9%97%A8/"},{"categories":["协议"],"content":"普通、一元 RPC 普通 rpc，客户端向服务器发送一个请求，然后得到一个响应，就像普通的函数调用一样。 .proto 文件中的 GetFeature，发送一个坐标，返回坐标的地理名称。 ","date":"2022-07-28","objectID":"/grpc%E6%A1%86%E6%9E%B6%E5%85%A5%E9%97%A8/:3:0","tags":["gRPC"],"title":"GRPC框架入门","uri":"/grpc%E6%A1%86%E6%9E%B6%E5%85%A5%E9%97%A8/"},{"categories":["协议"],"content":"服务端流式 RPC 其中客户端向服务器发送请求，并获得一个流来读取一系列消息。客户端从返回的流中读取，直到没有更多的消息。gRPC 保证在单个 RPC 调用中的消息是有序的。 .proto 文件中的 ListFeatures，发送一个高低坐标构成一片区域，流式返回区域内的地理名称。 ","date":"2022-07-28","objectID":"/grpc%E6%A1%86%E6%9E%B6%E5%85%A5%E9%97%A8/:4:0","tags":["gRPC"],"title":"GRPC框架入门","uri":"/grpc%E6%A1%86%E6%9E%B6%E5%85%A5%E9%97%A8/"},{"categories":["协议"],"content":"客户端流式 RPC 其中客户端写入一系列消息并将其发送到服务器，同样使用提供的流。一旦客户端完成了消息的写入，它就等待服务器读取消息并返回响应。同样，gRPC 保证在单个 RPC 调用中对消息进行排序。 .proto 文件中的 RecordRoute，客户端流式发送坐标点，服务端返回坐标点的总数信息。 ","date":"2022-07-28","objectID":"/grpc%E6%A1%86%E6%9E%B6%E5%85%A5%E9%97%A8/:5:0","tags":["gRPC"],"title":"GRPC框架入门","uri":"/grpc%E6%A1%86%E6%9E%B6%E5%85%A5%E9%97%A8/"},{"categories":["协议"],"content":"双向流式 RPC 其中双方使用读写流发送一系列消息。这两个流独立运行，因此客户端和服务器可以按照自己喜欢的顺序读写: 例如，服务器可以等待接收所有客户端消息后再写响应，或者可以交替读取消息然后写入消息，或者其他读写组合。每个流中的消息是有序的。 .proto 文件中的 RouteChat，客户端流式发送坐标点，服务端流式返回之前经历过的坐标点。 ","date":"2022-07-28","objectID":"/grpc%E6%A1%86%E6%9E%B6%E5%85%A5%E9%97%A8/:6:0","tags":["gRPC"],"title":"GRPC框架入门","uri":"/grpc%E6%A1%86%E6%9E%B6%E5%85%A5%E9%97%A8/"},{"categories":["协议"],"content":"Python ","date":"2022-07-28","objectID":"/grpc%E6%A1%86%E6%9E%B6%E5%85%A5%E9%97%A8/:7:0","tags":["gRPC"],"title":"GRPC框架入门","uri":"/grpc%E6%A1%86%E6%9E%B6%E5%85%A5%E9%97%A8/"},{"categories":["协议"],"content":"安装 gRPC $ python -m pip install grpcio ","date":"2022-07-28","objectID":"/grpc%E6%A1%86%E6%9E%B6%E5%85%A5%E9%97%A8/:7:1","tags":["gRPC"],"title":"GRPC框架入门","uri":"/grpc%E6%A1%86%E6%9E%B6%E5%85%A5%E9%97%A8/"},{"categories":["协议"],"content":"安装 gRPC tools gRPC tools 包含了 protocol buffer 的编译器，生成 python 文件可以直接使用 gRPC tools。不用运行 protoc，指定 python-out 参数等，方便了很多 $ python -m pip install grpcio-tools ","date":"2022-07-28","objectID":"/grpc%E6%A1%86%E6%9E%B6%E5%85%A5%E9%97%A8/:7:2","tags":["gRPC"],"title":"GRPC框架入门","uri":"/grpc%E6%A1%86%E6%9E%B6%E5%85%A5%E9%97%A8/"},{"categories":["协议"],"content":"生成 gRPC 代码 cd 到存放 .ptoto 文件的目录，运行以下命令 $ python -m grpc_tools.protoc -I. --python_out=. --grpc_python_out=. route_guide.proto 会发现生成了两个 py 文件 oute_guide_pb2.py 包含了之前在 proto 文件中定义的消息 route_guide_pb2_grpc.py 包含了客户端会使用到的 RouteGuideStub 和服务端使用到的 RouteGuideServicer，add_RouteGuideServicer_to_server ","date":"2022-07-28","objectID":"/grpc%E6%A1%86%E6%9E%B6%E5%85%A5%E9%97%A8/:7:3","tags":["gRPC"],"title":"GRPC框架入门","uri":"/grpc%E6%A1%86%E6%9E%B6%E5%85%A5%E9%97%A8/"},{"categories":["协议"],"content":"server \"\"\"The Python implementation of the gRPC route guide server.\"\"\" from concurrent import futures import logging import math import time import grpc import route_guide_pb2 import route_guide_pb2_grpc import route_guide_resources def get_feature(feature_db, point): \"\"\"Returns Feature at given location or None.\"\"\" for feature in feature_db: if feature.location == point: return feature return None def get_distance(start, end): \"\"\"Distance between two points.\"\"\" coord_factor = 10000000.0 lat_1 = start.latitude / coord_factor lat_2 = end.latitude / coord_factor lon_1 = start.longitude / coord_factor lon_2 = end.longitude / coord_factor lat_rad_1 = math.radians(lat_1) lat_rad_2 = math.radians(lat_2) delta_lat_rad = math.radians(lat_2 - lat_1) delta_lon_rad = math.radians(lon_2 - lon_1) # Formula is based on http://mathforum.org/library/drmath/view/51879.html a = (pow(math.sin(delta_lat_rad / 2), 2) + (math.cos(lat_rad_1) * math.cos(lat_rad_2) * pow(math.sin(delta_lon_rad / 2), 2))) c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a)) R = 6371000 # metres return R * c class RouteGuideServicer(route_guide_pb2_grpc.RouteGuideServicer): \"\"\"Provides methods that implement functionality of route guide server.\"\"\" def __init__(self): self.db = route_guide_resources.read_route_guide_database() def GetFeature(self, request, context): feature = get_feature(self.db, request) if feature is None: return route_guide_pb2.Feature(name=\"\", location=request) else: return feature def ListFeatures(self, request, context): left = min(request.lo.longitude, request.hi.longitude) right = max(request.lo.longitude, request.hi.longitude) top = max(request.lo.latitude, request.hi.latitude) bottom = min(request.lo.latitude, request.hi.latitude) for feature in self.db: if (feature.location.longitude\u003e= left and feature.location.longitude \u003c= right and feature.location.latitude \u003e= bottom and feature.location.latitude \u003c= top): yield feature def RecordRoute(self, request_iterator, context): point_count = 0 feature_count = 0 distance = 0.0 prev_point = None start_time = time.time() for point in request_iterator: point_count += 1 if get_feature(self.db, point): feature_count += 1 if prev_point: distance += get_distance(prev_point, point) prev_point = point elapsed_time = time.time() - start_time return route_guide_pb2.RouteSummary(point_count=point_count, feature_count=feature_count, distance=int(distance), elapsed_time=int(elapsed_time)) def RouteChat(self, request_iterator, context): prev_notes = [] for new_note in request_iterator: for prev_note in prev_notes: if prev_note.location == new_note.location: yield prev_note prev_notes.append(new_note) def serve(): server = grpc.server(futures.ThreadPoolExecutor(max_workers=10)) route_guide_pb2_grpc.add_RouteGuideServicer_to_server( RouteGuideServicer(), server) server.add_insecure_port('[::]:50051') server.start() server.wait_for_termination() if __name__ == '__main__': logging.basicConfig() serve() ","date":"2022-07-28","objectID":"/grpc%E6%A1%86%E6%9E%B6%E5%85%A5%E9%97%A8/:7:4","tags":["gRPC"],"title":"GRPC框架入门","uri":"/grpc%E6%A1%86%E6%9E%B6%E5%85%A5%E9%97%A8/"},{"categories":["协议"],"content":"client 客户端方式多种多样，使用 grpcurl、postman 图形化客户端 等等，导入 .proto 文件即可 \"\"\"The Python implementation of the gRPC route guide client.\"\"\" from __future__ import print_function import logging import random import grpc import route_guide_pb2 import route_guide_pb2_grpc import route_guide_resources def make_route_note(message, latitude, longitude): return route_guide_pb2.RouteNote( message=message, location=route_guide_pb2.Point(latitude=latitude, longitude=longitude)) def guide_get_one_feature(stub, point): feature = stub.GetFeature(point) if not feature.location: print(\"Server returned incomplete feature\") return if feature.name: print(\"Feature called %sat %s\" % (feature.name, feature.location)) else: print(\"Found no feature at %s\" % feature.location) def guide_get_feature(stub): guide_get_one_feature( stub, route_guide_pb2.Point(latitude=409146138, longitude=-746188906)) guide_get_one_feature(stub, route_guide_pb2.Point(latitude=0, longitude=0)) def guide_list_features(stub): rectangle = route_guide_pb2.Rectangle( lo=route_guide_pb2.Point(latitude=400000000, longitude=-750000000), hi=route_guide_pb2.Point(latitude=420000000, longitude=-730000000)) print(\"Looking for features between 40, -75 and 42, -73\") features = stub.ListFeatures(rectangle) for feature in features: print(\"Feature called %sat %s\" % (feature.name, feature.location)) def generate_route(feature_list): for _ in range(0, 10): random_feature = feature_list[random.randint(0, len(feature_list) - 1)] print(\"Visiting point %s\" % random_feature.location) yield random_feature.location def guide_record_route(stub): feature_list = route_guide_resources.read_route_guide_database() route_iterator = generate_route(feature_list) route_summary = stub.RecordRoute(route_iterator) print(\"Finished trip with %spoints\" % route_summary.point_count) print(\"Passed %sfeatures\" % route_summary.feature_count) print(\"Travelled %smeters\" % route_summary.distance) print(\"It took %sseconds\" % route_summary.elapsed_time) def generate_messages(): messages = [ make_route_note(\"First message\", 0, 0), make_route_note(\"Second message\", 0, 1), make_route_note(\"Third message\", 1, 0), make_route_note(\"Fourth message\", 0, 0), make_route_note(\"Fifth message\", 1, 0), ] for msg in messages: print(\"Sending %sat %s\" % (msg.message, msg.location)) yield msg def guide_route_chat(stub): responses = stub.RouteChat(generate_messages()) for response in responses: print(\"Received message %sat %s\" % (response.message, response.location)) def run(): # NOTE(gRPC Python Team): .close() is possible on a channel and should be # used in circumstances in which the with statement does not fit the needs # of the code. with grpc.insecure_channel('localhost:50051') as channel: stub = route_guide_pb2_grpc.RouteGuideStub(channel) print(\"-------------- GetFeature --------------\") guide_get_feature(stub) print(\"-------------- ListFeatures --------------\") guide_list_features(stub) print(\"-------------- RecordRoute --------------\") guide_record_route(stub) print(\"-------------- RouteChat --------------\") guide_route_chat(stub) if __name__ == '__main__': logging.basicConfig() run() 可以发现对于流式处理 gRPC 是通过迭代器实现，对于要返回的信息用的是 yield 关键字而不是 return ","date":"2022-07-28","objectID":"/grpc%E6%A1%86%E6%9E%B6%E5%85%A5%E9%97%A8/:7:5","tags":["gRPC"],"title":"GRPC框架入门","uri":"/grpc%E6%A1%86%E6%9E%B6%E5%85%A5%E9%97%A8/"},{"categories":["协议"],"content":"Go ","date":"2022-07-28","objectID":"/grpc%E6%A1%86%E6%9E%B6%E5%85%A5%E9%97%A8/:8:0","tags":["gRPC"],"title":"GRPC框架入门","uri":"/grpc%E6%A1%86%E6%9E%B6%E5%85%A5%E9%97%A8/"},{"categories":["协议"],"content":"安装 protoc 编译器及 go 插件 Protocol buffer compiler 下载后最好放到自己的 PATH 下 安装 plugins，有两个 $ go install google.golang.org/protobuf/cmd/protoc-gen-go@v1.28 $ go install google.golang.org/grpc/cmd/protoc-gen-go-grpc@v1.2 ","date":"2022-07-28","objectID":"/grpc%E6%A1%86%E6%9E%B6%E5%85%A5%E9%97%A8/:8:1","tags":["gRPC"],"title":"GRPC框架入门","uri":"/grpc%E6%A1%86%E6%9E%B6%E5%85%A5%E9%97%A8/"},{"categories":["协议"],"content":"生成 gRPC 代码 $ protoc --go_out=. --go_opt=paths=source_relative --go-grpc_out=. --go-grpc_opt=paths=source_relative route_guide.proto 和生成 python 代码类似，生成了两个 .go 代码文件 route_guide.pb.go route_guide_grpc.pb.go 内容根上方生成的 python 代码类似。一个包含消息，一个是和 gRPC 服务客户端、服务端有关。 ","date":"2022-07-28","objectID":"/grpc%E6%A1%86%E6%9E%B6%E5%85%A5%E9%97%A8/:8:2","tags":["gRPC"],"title":"GRPC框架入门","uri":"/grpc%E6%A1%86%E6%9E%B6%E5%85%A5%E9%97%A8/"},{"categories":["协议"],"content":"server // Package main implements a simple gRPC server that demonstrates how to use gRPC-Go libraries // to perform unary, client streaming, server streaming and full duplex RPCs. // // It implements the route guide service whose definition can be found in routeguide/route_guide.proto. package main import ( \"context\" \"encoding/json\" \"flag\" \"fmt\" \"io\" \"io/ioutil\" \"log\" \"math\" \"net\" \"sync\" \"time\" \"google.golang.org/grpc\" \"google.golang.org/grpc/credentials\" \"google.golang.org/grpc/examples/data\" \"github.com/golang/protobuf/proto\" pb \"google.golang.org/grpc/examples/route_guide/routeguide\" ) var ( tls = flag.Bool(\"tls\", false, \"Connection uses TLS if true, else plain TCP\") certFile = flag.String(\"cert_file\", \"\",\"The TLS cert file\") keyFile = flag.String(\"key_file\", \"\",\"The TLS key file\") jsonDBFile = flag.String(\"json_db_file\", \"\",\"A json file containing a list of features\") port = flag.Int(\"port\", 50051, \"The server port\") ) type routeGuideServer struct { pb.UnimplementedRouteGuideServer savedFeatures []*pb.Feature // read-only after initialized mu sync.Mutex // protects routeNotes routeNotes map[string][]*pb.RouteNote } // GetFeature returns the feature at the given point. func (s *routeGuideServer) GetFeature(ctx context.Context, point *pb.Point) (*pb.Feature, error) { for _, feature := range s.savedFeatures { if proto.Equal(feature.Location, point) { return feature, nil } } // No feature was found, return an unnamed feature return \u0026pb.Feature{Location: point}, nil } // ListFeatures lists all features contained within the given bounding Rectangle. func (s *routeGuideServer) ListFeatures(rect *pb.Rectangle, stream pb.RouteGuide_ListFeaturesServer) error { for _, feature := range s.savedFeatures { if inRange(feature.Location, rect) { if err := stream.Send(feature); err != nil { return err } } } return nil } // RecordRoute records a route composited of a sequence of points. // // It gets a stream of points, and responds with statistics about the \"trip\": // number of points, number of known features visited, total distance traveled, and // total time spent. func (s *routeGuideServer) RecordRoute(stream pb.RouteGuide_RecordRouteServer) error { var pointCount, featureCount, distance int32 var lastPoint *pb.Point startTime := time.Now() for { point, err := stream.Recv() if err == io.EOF { endTime := time.Now() return stream.SendAndClose(\u0026pb.RouteSummary{ PointCount: pointCount, FeatureCount: featureCount, Distance: distance, ElapsedTime: int32(endTime.Sub(startTime).Seconds()), }) } if err != nil { return err } pointCount++ for _, feature := range s.savedFeatures { if proto.Equal(feature.Location, point) { featureCount++ } } if lastPoint != nil { distance += calcDistance(lastPoint, point) } lastPoint = point } } // RouteChat receives a stream of message/location pairs, and responds with a stream of all // previous messages at each of those locations. func (s *routeGuideServer) RouteChat(stream pb.RouteGuide_RouteChatServer) error { for { in, err := stream.Recv() if err == io.EOF { return nil } if err != nil { return err } key := serialize(in.Location) s.mu.Lock() s.routeNotes[key] = append(s.routeNotes[key], in) // Note: this copy prevents blocking other clients while serving this one. // We don't need to do a deep copy, because elements in the slice are // insert-only and never modified. rn := make([]*pb.RouteNote, len(s.routeNotes[key])) copy(rn, s.routeNotes[key]) s.mu.Unlock() for _, note := range rn { if err := stream.Send(note); err != nil { return err } } } } // loadFeatures loads features from a JSON file. func (s *routeGuideServer) loadFeatures(filePath string) { var data []byte if filePath != \"\" { var err error data, err = ioutil.ReadFile(filePath) if err != nil { log.Fatalf(\"Failed to load default features: %v\", err) } } else { data = exampleData } if err := json.Unmarshal(data, \u0026s.savedFeatures); err != nil { log.Fatalf(\"Failed to load default features: %v\", err) } } func toRadians(num float64) float64 { return num * math","date":"2022-07-28","objectID":"/grpc%E6%A1%86%E6%9E%B6%E5%85%A5%E9%97%A8/:8:3","tags":["gRPC"],"title":"GRPC框架入门","uri":"/grpc%E6%A1%86%E6%9E%B6%E5%85%A5%E9%97%A8/"},{"categories":["协议"],"content":"client // Package main implements a simple gRPC client that demonstrates how to use gRPC-Go libraries // to perform unary, client streaming, server streaming and full duplex RPCs. // // It interacts with the route guide service whose definition can be found in routeguide/route_guide.proto. package main import ( \"context\" \"flag\" \"io\" \"log\" \"math/rand\" \"time\" \"google.golang.org/grpc\" \"google.golang.org/grpc/credentials\" \"google.golang.org/grpc/credentials/insecure\" \"google.golang.org/grpc/examples/data\" pb \"google.golang.org/grpc/examples/route_guide/routeguide\" ) var ( tls = flag.Bool(\"tls\", false, \"Connection uses TLS if true, else plain TCP\") caFile = flag.String(\"ca_file\", \"\",\"The file containing the CA root cert file\") serverAddr = flag.String(\"addr\", \"localhost:50051\", \"The server address in the format of host:port\") serverHostOverride = flag.String(\"server_host_override\", \"x.test.example.com\", \"The server name used to verify the hostname returned by the TLS handshake\") ) // printFeature gets the feature for the given point. func printFeature(client pb.RouteGuideClient, point *pb.Point) { log.Printf(\"Getting feature for point (%d, %d)\", point.Latitude, point.Longitude) ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second) defer cancel() feature, err := client.GetFeature(ctx, point) if err != nil { log.Fatalf(\"client.GetFeature failed: %v\", err) } log.Println(feature) } // printFeatures lists all the features within the given bounding Rectangle. func printFeatures(client pb.RouteGuideClient, rect *pb.Rectangle) { log.Printf(\"Looking for features within %v\", rect) ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second) defer cancel() stream, err := client.ListFeatures(ctx, rect) if err != nil { log.Fatalf(\"client.ListFeatures failed: %v\", err) } for { feature, err := stream.Recv() if err == io.EOF { break } if err != nil { log.Fatalf(\"client.ListFeatures failed: %v\", err) } log.Printf(\"Feature: name: %q, point:(%v, %v)\", feature.GetName(), feature.GetLocation().GetLatitude(), feature.GetLocation().GetLongitude()) } } // runRecordRoute sends a sequence of points to server and expects to get a RouteSummary from server. func runRecordRoute(client pb.RouteGuideClient) { // Create a random number of random points r := rand.New(rand.NewSource(time.Now().UnixNano())) pointCount := int(r.Int31n(100)) + 2 // Traverse at least two points var points []*pb.Point for i := 0; i \u003c pointCount; i++ { points = append(points, randomPoint(r)) } log.Printf(\"Traversing %d points.\", len(points)) ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second) defer cancel() stream, err := client.RecordRoute(ctx) if err != nil { log.Fatalf(\"client.RecordRoute failed: %v\", err) } for _, point := range points { if err := stream.Send(point); err != nil { log.Fatalf(\"client.RecordRoute: stream.Send(%v) failed: %v\", point, err) } } reply, err := stream.CloseAndRecv() if err != nil { log.Fatalf(\"client.RecordRoute failed: %v\", err) } log.Printf(\"Route summary: %v\", reply) } // runRouteChat receives a sequence of route notes, while sending notes for various locations. func runRouteChat(client pb.RouteGuideClient) { notes := []*pb.RouteNote{ {Location: \u0026pb.Point{Latitude: 0, Longitude: 1}, Message: \"First message\"}, {Location: \u0026pb.Point{Latitude: 0, Longitude: 2}, Message: \"Second message\"}, {Location: \u0026pb.Point{Latitude: 0, Longitude: 3}, Message: \"Third message\"}, {Location: \u0026pb.Point{Latitude: 0, Longitude: 1}, Message: \"Fourth message\"}, {Location: \u0026pb.Point{Latitude: 0, Longitude: 2}, Message: \"Fifth message\"}, {Location: \u0026pb.Point{Latitude: 0, Longitude: 3}, Message: \"Sixth message\"}, } ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second) defer cancel() stream, err := client.RouteChat(ctx) if err != nil { log.Fatalf(\"client.RouteChat failed: %v\", err) } waitc := make(chan struct{}) go func() { for { in, err := stream.Recv() if err == io.EOF { // read done. close(waitc) return } if err !=","date":"2022-07-28","objectID":"/grpc%E6%A1%86%E6%9E%B6%E5%85%A5%E9%97%A8/:8:4","tags":["gRPC"],"title":"GRPC框架入门","uri":"/grpc%E6%A1%86%E6%9E%B6%E5%85%A5%E9%97%A8/"},{"categories":["学习记录"],"content":"首先说下自己并不是专门做安全的，此次总结也确实是工作中遇到了这类问题需要解决 当然如果你自己有过搭建服务的经历，或许会在服务的访问记录中看到各种乱七八载的访问 如果有以下情况的话，就送他一个iptables套餐吧 ","date":"2022-05-11","objectID":"/web%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/:0:0","tags":["网络安全"],"title":"Web安全基础学习","uri":"/web%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"},{"categories":["学习记录"],"content":"SQL注入 SQL注入是一种代码注入技术，用于攻击数据驱动的应用程序。 在应用程序中，如果没有做恰当的过滤，则可能使得恶意的SQL语句被插入输入字段中执行（例如将数据库内容转储给攻击者） 报错注入 extractvalue(1, concat(0x5c,(select user()))) updatexml(0x3a,concat(1,(select user())),1) http://ns2.stats.gov.cn/comment/api/index.php?gid=1\u0026page=2\u0026rlist%5B%5D=%40%60%27%60%2C+extractvalue%281%2C+concat_ws%280x20%2C+0x5c%2C%28select+md5%28202072102%29%29%29%29%2C%40%60%27%60 http://14.29.113.88:9292/api/sms_check.php?param=1%27+and+updatexml%281%2Cconcat%280x7e%2C%28SELECT+MD5%281234%29%29%2C0x7e%29%2C1%29--+ 数据路检测（mysql） sleep：sleep(1) 让sql运行多少秒 字符串连接：SELECT CONCAT(’some‘, ‘string’) 报错注入：convert(int, (db_name())) 等等 http://218.13.13.90:8081/fsGovPlatform/js/(select(0)from(select(sleep(34)))v)%2f*'+(select(0)from(select(sleep(34)))v)+'\"\"+(select(0)from(select(sleep(34)))v)+\"\"*%2f/timepicker/jquery-ui-timepicker-addon.js http://210.76.74.50/faq.php?action=grouppermission\u0026gids%5B100%5D%5B0%5D=%29+and+%28select+1+from+%28select+count%28%2A%29%2Cconcat%28%28select+concat%28user%2C0x3a%2Cmd5%281234%29%2C0x3a%29+from+mysql.user+limit+0%2C1%29%2Cfloor%28rand%280%29%2A2%29%29x+from+information_schema.tables+group+by+x%29a%29%23\u0026gids%5B99%5D=%27 http://xwrz.huizhou.gov.cn/invest-client/rzcs/index.html?assureType=123456\u0026minBalance=convert%28int%2Csys.fn_sqlvarbasetostr%28HashBytes%28%27MD5%27%2C%271078491144%27%29%29%29\u0026moneyrateStart=123456\u0026type=123456 ","date":"2022-05-11","objectID":"/web%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/:1:0","tags":["网络安全"],"title":"Web安全基础学习","uri":"/web%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"},{"categories":["学习记录"],"content":"XSS XSS全称为Cross Site Scripting，为了和CSS分开简写为XSS，中文名为跨站脚本。该漏洞发生在用户端，是指在渲染过程中发生了不在预期过程中的JavaScript代码执行。XSS通常被用于获取Cookie、以受攻击者的身份进行操作等行为 # 特征 \u003cscript src=\"...\"\u003e\u003c/script\u003e http://qqt.gdqy.gov.cn/tomcat-docs/appdev/sample/web/hello.jsp?test=\u003cscript\u003ealert(12345)\u003c/script\u003e ","date":"2022-05-11","objectID":"/web%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/:2:0","tags":["网络安全"],"title":"Web安全基础学习","uri":"/web%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"},{"categories":["学习记录"],"content":"CSRF 跨站请求伪造 (Cross-Site Request Forgery, CSRF)，也被称为 One Click Attack 或者 Session Riding ，通常缩写为CSRF，是一种对网站的恶意利用。尽管听起来像XSS，但它与XSS非常不同，XSS利用站点内的信任用户，而CSRF则通过伪装来自受信任用户的请求来利用受信任的网站 ","date":"2022-05-11","objectID":"/web%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/:3:0","tags":["网络安全"],"title":"Web安全基础学习","uri":"/web%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"},{"categories":["学习记录"],"content":"SSRF 服务端请求伪造（Server Side Request Forgery, SSRF）指的是攻击者在未能取得服务器所有权限时，利用服务器漏洞以服务器的身份发送一条构造好的请求给服务器所在内网。SSRF攻击通常针对外部网络无法直接访问的内部系统 通过各种非http协议 file:///path/to/file http://183.63.186.68/Web/file:%2f%2f%2fetc%2fpasswd.html ","date":"2022-05-11","objectID":"/web%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/:4:0","tags":["网络安全"],"title":"Web安全基础学习","uri":"/web%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"},{"categories":["学习记录"],"content":"命令注入 命令注入通常因为指Web应用在服务器上拼接系统命令而造成的漏洞。 该类漏洞通常出现在调用外部程序完成一些功能的情景下。比如一些Web管理界面的配置主机名/IP/掩码/网关、查看系统信息以及关闭重启等功能，或者一些站点提供如ping、nslookup、提供发送邮件、转换图片等功能都可能出现该类漏洞。 ","date":"2022-05-11","objectID":"/web%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/:5:0","tags":["网络安全"],"title":"Web安全基础学习","uri":"/web%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"},{"categories":["学习记录"],"content":"目录穿越 目录穿越（也被称为目录遍历/directory traversal/path traversal）是通过使用 ../ 等目录控制序列或者文件的绝对路径来访问存储在文件系统上的任意文件和目录，特别是应用程序源代码、配置文件、重要的系统文件等 ../ ..\\ ..;/ http://dfz.gd.gov.cn/index/ztlm/szfzg/gctj/nj//../../../../Gemfile ","date":"2022-05-11","objectID":"/web%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/:6:0","tags":["网络安全"],"title":"Web安全基础学习","uri":"/web%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"},{"categories":["学习记录"],"content":"文件读取 考虑读取可能有敏感信息的文件 用户目录下的敏感文件：.bash_history/.zsh_history/.profile/.bashrc/.gitconfig/.viminfopasswd 应用的配置文件：/etc/apache2/apache2.conf, /etc/nginx/nginx.conf 应用的日志文件：/var/log/apache2/access.log, /var/log/nginx/access.log 站点目录下的敏感文件：.svn/entries.git/HEADWEB-INF/web.xml.htaccess 特殊的备份文件：.swp/.swo/.bak/index.php Python的Cache：pycache_init_.cpython-35.pyc http://www.gdzwfw.gov.cn/portal/static//..%c1%9c..%c1%9c..%c1%9c..%c1%9c..%c1%9c..%c1%9c..%c1%9c..%c1%9c/windows/win.ini http://gcjs.jiangmen.cn/framework-ui/src//%2e%2e%5c%2e%2e%5c%2e%2e%5c%2e%2e%5c%2e%2e%5c%2e%2e%5c%2e%2e%5c%2e%2e%5c%2e%2e%5c%2e%2e%5c%2e%2e%5c%2e%2e%5c%2e%2e%5c%2e%2e%5c%2e%2e%5c%2e%2e%5c/etc/passwd http://zfbz.maoming.gov.cn/css/.svn/entries http://ggzy.zhuhai.gov.cn:8092/GPC/.git/HEAD ","date":"2022-05-11","objectID":"/web%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/:7:0","tags":["网络安全"],"title":"Web安全基础学习","uri":"/web%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"},{"categories":["学习记录"],"content":"文件上传 竞争上绕过 有的服务器采用了先保存，再删除不合法文件的方式，在这种服务器中，可以反复上传一个会生成Web Shell的文件并尝试访问，多次之后即可获得Shell http://bbs.968115.cn/backup.sh ","date":"2022-05-11","objectID":"/web%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/:8:0","tags":["网络安全"],"title":"Web安全基础学习","uri":"/web%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"},{"categories":["学习记录"],"content":"文件包含 常见的文件包含漏洞的形式为 \u003c?php include(\"inc/\" . $_GET['file']); ?\u003e 考虑常用的几种包含方式为 同目录包含 file=.htaccess 目录遍历 ?file=../../../../../../../../../var/lib/locate.db 日志注入 ?file=../../../../../../../../../var/log/apache/error.log 利用 /proc/self/environ 其中日志可以使用SSH日志或者Web日志等多种日志来源测试 http://183.63.186.142:8080/.htaccess ","date":"2022-05-11","objectID":"/web%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/:9:0","tags":["网络安全"],"title":"Web安全基础学习","uri":"/web%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"},{"categories":["学习记录"],"content":"XXE 当允许引用外部实体时，可通过构造恶意的XML内容，导致读取任意文件、执行系统命令、探测内网端口、攻击内网网站等后果。一般的XXE攻击，只有在服务器有回显或者报错的基础上才能使用XXE漏洞来读取服务器端文件，但是也可以通过Blind XXE的方式实现攻击 ","date":"2022-05-11","objectID":"/web%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/:10:0","tags":["网络安全"],"title":"Web安全基础学习","uri":"/web%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"},{"categories":["学习记录"],"content":"模版注入 模板引擎用于使用动态数据呈现内容。此上下文数据通常由用户控制并由模板进行格式化，以生成网页、电子邮件等。模板引擎通过使用代码构造（如条件语句、循环等）处理上下文数据，允许在模板中使用强大的语言表达式，以呈现动态内容。如果攻击者能够控制要呈现的模板，则他们将能够注入可暴露上下文数据，甚至在服务器上运行任意命令的表达式 ","date":"2022-05-11","objectID":"/web%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/:11:0","tags":["网络安全"],"title":"Web安全基础学习","uri":"/web%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"},{"categories":["学习记录"],"content":"Xpath注入 XPath注入攻击主要是通过构建特殊的输入，这些输入往往是XPath语法中的一些组合，这些输入将作为参数传入Web 应用程序，通过执行XPath查询而执行入侵者想要的操作，下面以登录验证中的模块为例，说明 XPath注入攻击的实现原理 ","date":"2022-05-11","objectID":"/web%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/:12:0","tags":["网络安全"],"title":"Web安全基础学习","uri":"/web%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"},{"categories":["学习记录"],"content":"逻辑漏洞/业务漏洞 逻辑漏洞是指由于程序逻辑不严导致一些逻辑分支处理错误造成的漏洞。 在实际开发中，因为开发者水平不一没有安全意识，而且业务发展迅速内部测试没有及时到位，所以常常会出现类似的漏洞 ","date":"2022-05-11","objectID":"/web%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/:13:0","tags":["网络安全"],"title":"Web安全基础学习","uri":"/web%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"},{"categories":["学习记录"],"content":"配置安全 弱密码位数过低字符集小为常用密码个人信息相关手机号生日姓名用户名使用键盘模式做密码 敏感文件泄漏.git.svn 数据库Mongo/Redis等数据库无密码且没有限制访问 加密体系在客户端存储私钥 三方库/软件公开漏洞后没有及时更新 ","date":"2022-05-11","objectID":"/web%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/:14:0","tags":["网络安全"],"title":"Web安全基础学习","uri":"/web%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"},{"categories":["学习记录"],"content":"中间件 ","date":"2022-05-11","objectID":"/web%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/:15:0","tags":["网络安全"],"title":"Web安全基础学习","uri":"/web%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"},{"categories":["学习记录"],"content":"Web Cache欺骗攻击 漏洞成因 当代理服务器设置为缓存静态文件并忽略这类文件的caching header时，访问 http://www.example.com/home.php/no-existent.css 时，会发生什么呢？整个响应流程如下： 浏览器请求 http://www.example.com/home.php/no-existent.css ; 服务器返回 http://www.example.com/home.php 的内容(通常来说不会缓存该页面); 响应经过代理服务器; 代理识别该文件有css后缀; 在缓存目录下，代理服务器创建目录 home.php ，将返回的内容作为 non-existent.css 保存。 漏洞利用 攻击者欺骗用户访问 http://www.example.com/home.php/logo.png?www.myhack58.com ,导致含有用户个人信息的页面被缓存，从而能被公开访问到。更严重的情况下，如果返回的内容包含session标识、安全问题的答案，或者csrf token。这样攻击者能接着获得这些信息，因为通常而言大部分网站静态资源都是公开可访问的。 ","date":"2022-05-11","objectID":"/web%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/:16:0","tags":["网络安全"],"title":"Web安全基础学习","uri":"/web%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"},{"categories":["学习记录"],"content":"HTTP走私请求 HTTP请求走私是一种干扰网站处理HTTP请求序列方式的技术，最早在 2005 年的一篇 文章 中被提出。 ","date":"2022-05-11","objectID":"/web%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/:17:0","tags":["网络安全"],"title":"Web安全基础学习","uri":"/web%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"},{"categories":["学习记录"],"content":"注意 文中的url举例均来自某为公司的测试请求，且对方访问是已经签署了访问协议 请不要随意访问文中举例url，更不要批量访问，否则后果自负！！！ ","date":"2022-05-11","objectID":"/web%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/:18:0","tags":["网络安全"],"title":"Web安全基础学习","uri":"/web%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"},{"categories":["终端工具"],"content":" Git Documentation Git 教程 - 廖雪峰 Git 常用命令 git init 初始化本地 git 环境 git clone \u003crepository\u003e 克隆一份代码到本地仓库 git pull 把远程仓库代码更新到本地，等于 git fetch + git merge git pull --rebase origin master 强制把远程仓库的代码更新到当前分支上面 git fetch 把远程库的代码更新到本地 git add . 把本地改动过的文件添加到暂存区中 git commit -m '\u003ccommit message\u003e' 把暂存区中的修改提交到本地库 git push 把本地库的修改提交到远程库中 git push origin \u003cbranch name\u003e 提交一个分支到远程库中 git branch -r/-a 查看远程分支 / 全部分支 git checkout master/bugfix 切换到某个分支 git checkout -b bugfix 新建 bugfix 分支 git checkout -d bugfix 删除 bugfix 分支 git merge master 假设当前在 bugfix 分支上，把 master 分支上的修改同步到 bugfix 分支上 git merge tool 调用 merge 工具 git stash 把未完成的修改保存起来 git stash list 查看所有保存列表 git stash pop 恢复本地分支到缓存状态 git blame \u003cfile name\u003e 查看某个文件每一行的修改记录，谁在什么时候修改的 git status 查看当前分支有哪些修改 git log 查看当前分支上面的日志信息 git diff 查看当前没有 add 的内容 git diff --cached 查看已经 add 但是没有 commit 的内容 git diff HEAD 上面两个命令显示内容的合并 git reset --hard HEAD 撤销本地修改 团队协作 Git 流程 ","date":"2022-04-24","objectID":"/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/:0:0","tags":["git"],"title":"Git常用命令总结","uri":"/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/"},{"categories":["终端工具"],"content":"克隆新项目，完成功能并提交 git clone \u003crepository\u003e 克隆代码仓库 git checkout -b \u003cbranch name\u003e 新建分支 \u003cmodify your code\u003e 完成功能的开发，代码的修改 git add . 把修改添加到暂存区 git commit -m '\u003ccommit message\u003e' 提交修改到 bugfix 分支 \u003creview 代码\u003e git checkout master 切换到 master 分支 git pull 更新代码 git merge \u003cbranch name\u003e 将新建分支合并到 master git push origin \u003cbranch name\u003e 把新建分支的代码 push 到远程仓库 ","date":"2022-04-24","objectID":"/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/:1:0","tags":["git"],"title":"Git常用命令总结","uri":"/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/"},{"categories":["终端工具"],"content":"正在新功能分支开发，需要紧急修复 bug 适用于新功能正在开发还不想提交的情况 因为工作区和暂存区的内容是公共的，不属于任何一个分支，所以就需要git stash临时保存修改 git add . 将当前代码添加暂存 git stash 保存修改 git checkout -b \u003cbugfix\u003e 新建 bugfix 分支 git pull --rebase origin master 主分支代码更新到当前分支 \u003cfix the bug\u003e 修复 bug git add . 添加暂存 git commit -m '\u003ccommit message\u003e' 提交代码 git push origin \u003cbugfix\u003e 推动 bugfix 分支到远程仓库 git checkout \u003cnew feature branch\u003e 回到新功能开发分支 git stash pop 恢复修改 \u003ccontinue develop\u003e 继续开发 ","date":"2022-04-24","objectID":"/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/:2:0","tags":["git"],"title":"Git常用命令总结","uri":"/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/"},{"categories":["编程语言"],"content":"在使用 Python Web 框架 Django 本地 runserver 启动后修改了代码，程序够自动重新加载并执行（live-reload），在开发调试阶段非常实用，可以提高开发效率。 在使用 Go 开发自己的项目或者使用 gin 框架进行本地调试的时候，也需要在文件修改后自动编译运行查看效果，那么则可以使用 air 这个工具。 ","date":"2022-04-21","objectID":"/%E4%BD%BF%E7%94%A8air%E5%AE%9E%E7%8E%B0go%E7%A8%8B%E5%BA%8F%E7%83%AD%E5%8A%A0%E8%BD%BD/:0:0","tags":["Golang"],"title":"使用air实现go程序热加载","uri":"/%E4%BD%BF%E7%94%A8air%E5%AE%9E%E7%8E%B0go%E7%A8%8B%E5%BA%8F%E7%83%AD%E5%8A%A0%E8%BD%BD/"},{"categories":["编程语言"],"content":"AIR air 使用 go 语言开发，可以实现 go 语言应用程序的热加载，它支持以下特性： 彩色日志输出 自定义构建或二进制命令 支持忽略子目录 启动后支持监听新目录 更好的构建流程 air 使用\" air 使用 ","date":"2022-04-21","objectID":"/%E4%BD%BF%E7%94%A8air%E5%AE%9E%E7%8E%B0go%E7%A8%8B%E5%BA%8F%E7%83%AD%E5%8A%A0%E8%BD%BD/:1:0","tags":["Golang"],"title":"使用air实现go程序热加载","uri":"/%E4%BD%BF%E7%94%A8air%E5%AE%9E%E7%8E%B0go%E7%A8%8B%E5%BA%8F%E7%83%AD%E5%8A%A0%E8%BD%BD/"},{"categories":["编程语言"],"content":"安装 由于是 go 语言开发，对于我来说就直接下载二进制文件放到系统 PATH 目录下了，当然也可以使用 go get 、Docker 等方式安装，具体可以查看 Readme 中其他的安装方法，这里就不再赘述了 ","date":"2022-04-21","objectID":"/%E4%BD%BF%E7%94%A8air%E5%AE%9E%E7%8E%B0go%E7%A8%8B%E5%BA%8F%E7%83%AD%E5%8A%A0%E8%BD%BD/:2:0","tags":["Golang"],"title":"使用air实现go程序热加载","uri":"/%E4%BD%BF%E7%94%A8air%E5%AE%9E%E7%8E%B0go%E7%A8%8B%E5%BA%8F%E7%83%AD%E5%8A%A0%E8%BD%BD/"},{"categories":["编程语言"],"content":"使用 写好 .air.conf 文件放在项目目录下然后直接执行 air 命令就行，非常简单 完整的示例以及注释如下，需要新增环境变量或者是命令行参数的可以在 full_bin 前后添加 # [Air](https://github.com/cosmtrek/air) TOML 格式的配置文件 # 工作目录 # 使用 . 或绝对路径，请注意 `tmp_dir` 目录必须在 `root` 目录下 root = \".\" tmp_dir = \"tmp\" [build] # 只需要写你平常编译使用的 shell 命令。你也可以使用 `make` cmd = \"go build -o ./tmp/main .\" # 由 `cmd` 命令得到的二进制文件名 bin = \"tmp/main\" # 自定义的二进制，可以在前方添加环境变量或者是后方添加命令行参数启动 eg：APP_ENV=dev full_bin = \"./tmp/main\" # 监听以下文件扩展名的文件。 include_ext = [\"go\", \"tpl\", \"tmpl\", \"html\"] # 忽略这些文件扩展名或目录 exclude_dir = [\"assets\", \"tmp\", \"vendor\", \"frontend/node_modules\"] # 监听以下指定目录的文件 include_dir = [] # 排除以下文件 exclude_file = [] # 如果文件更改过于频繁，则没有必要在每次更改时都触发构建。可以设置触发构建的延迟时间 delay = 1000 # ms # 发生构建错误时，停止运行旧的二进制文件。 stop_on_error = true # air 的日志文件名，该日志文件放置在你的 `tmp_dir` 中 log = \"air_errors.log\" [log] # 显示日志时间 time = true [color] # 自定义每个部分显示的颜色。如果找不到颜色，使用原始的应用程序日志。 main = \"magenta\" watcher = \"cyan\" build = \"yellow\" runner = \"green\" [misc] # 退出时删除 tmp 目录 clean_on_exit = true 生成并运行的二进制文件会放在当前目录下 tmp 目录，程序结束后会自动删除，非常贴心 ","date":"2022-04-21","objectID":"/%E4%BD%BF%E7%94%A8air%E5%AE%9E%E7%8E%B0go%E7%A8%8B%E5%BA%8F%E7%83%AD%E5%8A%A0%E8%BD%BD/:3:0","tags":["Golang"],"title":"使用air实现go程序热加载","uri":"/%E4%BD%BF%E7%94%A8air%E5%AE%9E%E7%8E%B0go%E7%A8%8B%E5%BA%8F%E7%83%AD%E5%8A%A0%E8%BD%BD/"},{"categories":["协议"],"content":" 官方文档 Language Guide (proto3) protocol-buffers 代码生成指南 网络上关于 Protocol Buffers 的翻译已经很多了，这里就不再重新写一遍了，主要记录一下常用语法。其实就是定义一个 .proto 文件，然后根据不同语言的插件生成不同的代码，通常代码会分为两个文件，以 go 语言为例子 xxx.pb.go 主要包含消息定义的 go 语言代码 xxx_grpc.pb.go 主要包含 grpc，也就是服务端，客户端之间交互的代码 至于为什么要分成两个文件（记得之前版本 go 语言只生成一个文件），应该是不同语言 grpc 的通信实现有很多吧，像 python 就有 gevent 和 asyncio 两种，拆分也是让文件分工更加清晰 至于 .proto 文件也是主要以：定义消息、定义服务、其他规范：注释、选项等等 组成 其他规范 文件开头通常是 syntax = \"proto3\";，这个必须写在开头，表示使用的是 proto3 的语法，不写的话默认为 proto2 其次是类似 option go_package = \"example.com/proto\"; 这样的选项，用于不同语言生成代码的参数 注释与 c/c++ 语法相同，使用：//（单行注释）和 /* ... */（多行注释） Message 命名采用驼峰命名方式，字段命名采用小写字母加下划线分隔方式 message SongServerRequest { required string song_name = 1; } Enums 类型名采用驼峰命名方式，字段命名采用大写字母加下划线分隔方式 enum Foo { FIRST_VALUE = 1; SECOND_VALUE = 2; } Service 与 rpc 方法名统一采用驼峰式命名 定义消息 (Message) Message 基本格式 message \u003cmessage name\u003e { \u003cfiled rule\u003e(规则) \u003cfiled type\u003e(类型) \u003cfiled name\u003e(名称) = \u003cfiled number\u003e(编号)} message name：在同一个 .proto 文件内必须唯一 filed rule：可以没有，常用的有 repeated、oneof filed type：数据类型，protobuf 定义的数据类型, 生产代码的会映射成对应语言的数据类型 filed name：字段名称，同一个 message 内必须唯一 filed number：字段的编号， 序列化成二进制数据时的字段编号 ","date":"2022-04-14","objectID":"/protocol-buffers%E5%8D%8F%E8%AE%AE%E4%BD%BF%E7%94%A8%E5%B0%8F%E7%BB%93/:0:0","tags":["proto"],"title":"Protocol Buffers协议使用小结","uri":"/protocol-buffers%E5%8D%8F%E8%AE%AE%E4%BD%BF%E7%94%A8%E5%B0%8F%E7%BB%93/"},{"categories":["协议"],"content":"指定字段类型 这里就截取我常用的语言 Python 和 Go，其他语言查看：Scalar Value Types .proto Type Python Type[3] Go Type Notes double float float64 float float float32 int32 int int32 使用变长编码，对于负值的效率很低，如果你的域有可能有负值，请使用 sint64 替代 int64 int/long int64 uint32 int/long uint32 使用变长编码 uint64 int/long uint64 使用变长编码 sint32 int int32 使用变长编码，这些编码在负值时比 int32 高效的多 sint64 int/long int64 使用变长编码，有符号的整型值。编码时比通常的 int64 高效。 fixed32 int/long uint32 总是 4 个字节，如果数值总是比总是比 228 大的话，这个类型会比 uint32 高效。 fixed64 int/long uint64 总是 8 个字节，如果数值总是比总是比 256 大的话，这个类型会比 uint64 高效。 sfixed32 int int32 总是 4 个字节 sfixed64 int/long int64 总是 8 个字节 bool bool bool string str/unicode string 一个字符串必须是 UTF-8 编码或者 7-bit ASCII 编码的文本。 bytes str (Python 2) bytes (Python 3) []byte 可能包含任意顺序的字节数据。 ","date":"2022-04-14","objectID":"/protocol-buffers%E5%8D%8F%E8%AE%AE%E4%BD%BF%E7%94%A8%E5%B0%8F%E7%BB%93/:1:0","tags":["proto"],"title":"Protocol Buffers协议使用小结","uri":"/protocol-buffers%E5%8D%8F%E8%AE%AE%E4%BD%BF%E7%94%A8%E5%B0%8F%E7%BB%93/"},{"categories":["协议"],"content":"默认值 当某个消息被解析时，如果某个被解析的信息不包含字段的值话，会使用该字段类型的默认值 对于 string，默认是一个空 string 对于 bytes，默认是一个空的 bytes 对于 bool，默认是 false 对于数值类型，默认是 0 对于枚举，默认是第一个定义的枚举值，必须为 0 对于消息类型（message），默认值根据编程语言来确定（Python 中为 None） ","date":"2022-04-14","objectID":"/protocol-buffers%E5%8D%8F%E8%AE%AE%E4%BD%BF%E7%94%A8%E5%B0%8F%E7%BB%93/:2:0","tags":["proto"],"title":"Protocol Buffers协议使用小结","uri":"/protocol-buffers%E5%8D%8F%E8%AE%AE%E4%BD%BF%E7%94%A8%E5%B0%8F%E7%BB%93/"},{"categories":["协议"],"content":"分配字段编号 消息定义中每个字段都有一个唯一的编号（1、2、3、4…）。这些编号用来标识二进制格式的字段。 1-15 只需要一个字节进行编码，而 16-2047 则需要两个字节（经常使用的字段应当对应 1-15 编号） 编号范围是 1 到 2^29-1(536,870,911) 编号 19000 到 19999 不可用（protocol buffer 协议实现中保留） ","date":"2022-04-14","objectID":"/protocol-buffers%E5%8D%8F%E8%AE%AE%E4%BD%BF%E7%94%A8%E5%B0%8F%E7%BB%93/:3:0","tags":["proto"],"title":"Protocol Buffers协议使用小结","uri":"/protocol-buffers%E5%8D%8F%E8%AE%AE%E4%BD%BF%E7%94%A8%E5%B0%8F%E7%BB%93/"},{"categories":["协议"],"content":"保留字段编号 对消息的字段有更新或者删除操作时最好使用 reserved 来声明保留字段编号，避免由于消息的更新或者删除操作无法正常解析 message Foo { reserved 2, 15, 9 to 11; reserved \"foo\", \"bar\";} ","date":"2022-04-14","objectID":"/protocol-buffers%E5%8D%8F%E8%AE%AE%E4%BD%BF%E7%94%A8%E5%B0%8F%E7%BB%93/:4:0","tags":["proto"],"title":"Protocol Buffers协议使用小结","uri":"/protocol-buffers%E5%8D%8F%E8%AE%AE%E4%BD%BF%E7%94%A8%E5%B0%8F%E7%BB%93/"},{"categories":["协议"],"content":"枚举 当某个字段的值需要是某些特定值中的一个时，可以在消息定义中添加一个枚举 enum 并且为每个特定值定义一个常量。例如，假设要为每一个 SearchRequest 消息添加一个 corpus 字段，而 corpus 的值可能是 UNIVERSAL，WEB，IMAGES，LOCAL，NEWS，PRODUCTS 或 VIDEO 中的一个。 其实可以很容易地实现这一点：通过向消息定义中添加一个枚举（enum）并且为每个可能的值定义一个常量就可以了。 message SearchRequest { string query = 1; int32 page_number = 2; int32 result_per_page = 3; enum Corpus { UNIVERSAL = 0; WEB = 1; IMAGES = 2; LOCAL = 3; NEWS = 4; PRODUCTS = 5; VIDEO = 6; } Corpus corpus = 4;} Corpus 枚举的第一个常量映射为 0：每个枚举类型必须将其第一个类型映射为 0，这是因为： 必须有有一个 0 值，我们可以用这个 0 值作为默认值 这个零值必须为第一个元素，为了兼容 proto2 语义，枚举的第一个值总是默认值 如果想在一个枚举中，不同的值可以指定相同的常量，需要设置 option allow_alias = true;，否则编译器会报错 message MyMessage1 { enum EnumAllowingAlias { option allow_alias = true; UNKNOWN = 0; STARTED = 1; RUNNING = 1; }}message MyMessage2 { enum EnumNotAllowingAlias { UNKNOWN = 0; STARTED = 1; // RUNNING = 1; // Uncommenting this line will cause a compile error inside Google and a warning message outside. }} 枚举中设置的常量必须在 32 位整形范围内，因为枚举值是使用可变编码方式的，对负数不够高效，因此不推荐在枚举中使用负数 ","date":"2022-04-14","objectID":"/protocol-buffers%E5%8D%8F%E8%AE%AE%E4%BD%BF%E7%94%A8%E5%B0%8F%E7%BB%93/:5:0","tags":["proto"],"title":"Protocol Buffers协议使用小结","uri":"/protocol-buffers%E5%8D%8F%E8%AE%AE%E4%BD%BF%E7%94%A8%E5%B0%8F%E7%BB%93/"},{"categories":["协议"],"content":"嵌套类型 你可以在其他消息类型中定义、使用消息类型，在下面的例子中，Result 消息就定义在 SearchResponse 消息内，如： message SearchResponse { message Result { string url = 1; string title = 2; repeated string snippets = 3; } repeated Result results = 1;} ","date":"2022-04-14","objectID":"/protocol-buffers%E5%8D%8F%E8%AE%AE%E4%BD%BF%E7%94%A8%E5%B0%8F%E7%BB%93/:6:0","tags":["proto"],"title":"Protocol Buffers协议使用小结","uri":"/protocol-buffers%E5%8D%8F%E8%AE%AE%E4%BD%BF%E7%94%A8%E5%B0%8F%E7%BB%93/"},{"categories":["协议"],"content":"使用其他消息类型 ","date":"2022-04-14","objectID":"/protocol-buffers%E5%8D%8F%E8%AE%AE%E4%BD%BF%E7%94%A8%E5%B0%8F%E7%BB%93/:7:0","tags":["proto"],"title":"Protocol Buffers协议使用小结","uri":"/protocol-buffers%E5%8D%8F%E8%AE%AE%E4%BD%BF%E7%94%A8%E5%B0%8F%E7%BB%93/"},{"categories":["协议"],"content":"导入定义 可以通过导入其他 .proto 文件中的定义来使用它们 import \"myproject/other_protos.proto\"; ","date":"2022-04-14","objectID":"/protocol-buffers%E5%8D%8F%E8%AE%AE%E4%BD%BF%E7%94%A8%E5%B0%8F%E7%BB%93/:7:1","tags":["proto"],"title":"Protocol Buffers协议使用小结","uri":"/protocol-buffers%E5%8D%8F%E8%AE%AE%E4%BD%BF%E7%94%A8%E5%B0%8F%E7%BB%93/"},{"categories":["协议"],"content":"使用 proto2 消息类型 在你的 proto3 消息中导入 proto2 的消息类型也是可以的，反之亦然，然后 proto2 枚举不可以直接在 proto3 的标识符中使用（如果仅仅在 proto2 消息中使用是可以的） 看文档中还有 Map、Any、Oneof 这样的语法，没有实际接触过，后续接触了在进行补充 定义服务 (Service) 定义服务就比较简单了，根据不同的响应模式添加 stream service SearchService { rpc Search (SearchRequest) returns (SearchResponse); // 一元模式 rpc Search (stream SearchRequest) returns (SearchResponse); // 客户端流模式 rpc Search (SearchRequest) returns (stream SearchResponse); // 服务端流模式 rpc Search (stream SearchRequest) returns (stream SearchResponse); // 双向流模式 } ","date":"2022-04-14","objectID":"/protocol-buffers%E5%8D%8F%E8%AE%AE%E4%BD%BF%E7%94%A8%E5%B0%8F%E7%BB%93/:7:2","tags":["proto"],"title":"Protocol Buffers协议使用小结","uri":"/protocol-buffers%E5%8D%8F%E8%AE%AE%E4%BD%BF%E7%94%A8%E5%B0%8F%E7%BB%93/"},{"categories":["随笔"],"content":"必看表演 狂欢大巡游（全园区的大迅游，上午下午各一次，特别热闹） 功夫山庄（动物表演，有海象、海豹、水獭等，建议提前10分钟占好位置） 极地奇缘（海豚表演剧场，建议提前10分钟占好位置） 白鲸之恋（白鲸与饲养员的互动） 人鱼华尔兹（美人鱼演员表演） ","date":"2022-04-04","objectID":"/%E6%AD%A6%E6%B1%89%E6%B5%B7%E6%98%8C%E6%9E%81%E5%9C%B0%E6%B5%B7%E6%B4%8B%E4%B8%96%E7%95%8C%E6%B8%B8%E7%8E%A9tips/:1:0","tags":["武汉"],"title":"武汉海昌极地海洋世界游玩tips","uri":"/%E6%AD%A6%E6%B1%89%E6%B5%B7%E6%98%8C%E6%9E%81%E5%9C%B0%E6%B5%B7%E6%B4%8B%E4%B8%96%E7%95%8C%E6%B8%B8%E7%8E%A9tips/"},{"categories":["随笔"],"content":"各展厅推荐游览方案 企鹅展厅 一定要在企鹅喂食的时间观看，喂食过程很好玩，而且吃完东西的企鹅很活泼，到处跑到处游 白鲸展厅 请务必17点以后去一趟白鲸展厅，那个时候大部分游客都已经玩累了出园回家了，你可以一个人享受整个白鲸展厅，这个时候你会看到不一样的白鲸，强烈推荐！！！ 海底两万里 这里也建议17点以后再去一趟，体验一下一个人的海底，才能值回票价！ ","date":"2022-04-04","objectID":"/%E6%AD%A6%E6%B1%89%E6%B5%B7%E6%98%8C%E6%9E%81%E5%9C%B0%E6%B5%B7%E6%B4%8B%E4%B8%96%E7%95%8C%E6%B8%B8%E7%8E%A9tips/:2:0","tags":["武汉"],"title":"武汉海昌极地海洋世界游玩tips","uri":"/%E6%AD%A6%E6%B1%89%E6%B5%B7%E6%98%8C%E6%9E%81%E5%9C%B0%E6%B5%B7%E6%B4%8B%E4%B8%96%E7%95%8C%E6%B8%B8%E7%8E%A9tips/"},{"categories":["随笔"],"content":"总结 17点以后的海洋公园才是最好玩的海洋公园，不到清场不要离开园区！我入园的时候比较晚，下午2点才入园，以为体验会很赶，但是17点以后的白鲸馆和海底两万里让我感觉赚了！表演尽量都看完，合理安排时间，不要走马观花，多停留一段时间可以看到不一样的场景。 ","date":"2022-04-04","objectID":"/%E6%AD%A6%E6%B1%89%E6%B5%B7%E6%98%8C%E6%9E%81%E5%9C%B0%E6%B5%B7%E6%B4%8B%E4%B8%96%E7%95%8C%E6%B8%B8%E7%8E%A9tips/:3:0","tags":["武汉"],"title":"武汉海昌极地海洋世界游玩tips","uri":"/%E6%AD%A6%E6%B1%89%E6%B5%B7%E6%98%8C%E6%9E%81%E5%9C%B0%E6%B5%B7%E6%B4%8B%E4%B8%96%E7%95%8C%E6%B8%B8%E7%8E%A9tips/"},{"categories":["协议"],"content":" Hypertext Transfer Protocol Secure (HTTPS) is an extension of the Hypertext Transfer Protocol (HTTP). It is used for secure communication over a computer network, and is widely used on the Internet. In HTTPS, the communication protocol is encrypted using Transport Layer Security (TLS) or, formerly, its predecessor, Secure Sockets Layer (SSL). The protocol is therefore also often referred to as HTTP over TLS, or HTTP over SSL. HTTPS (Hypertext Transfer Protocol Secure) 是基于 HTTP 的扩展，用于计算机网络的安全通信，已经在互联网得到广泛应用。在 HTTPS 中，原有的 HTTP 协议会得到 TLS （安全传输层协议） 或其前辈 SSL （安全套接层） 的加密。因此 HTTPS 也常指 HTTP over TLS 或 HTTP over SSL。 ","date":"2021-11-23","objectID":"/https%E5%8D%8F%E8%AE%AE%E6%98%AF%E5%A6%82%E4%BD%95%E6%8F%A1%E6%89%8B%E7%9A%84/:0:0","tags":["https"],"title":"HTTPS 协议是如何握手的","uri":"/https%E5%8D%8F%E8%AE%AE%E6%98%AF%E5%A6%82%E4%BD%95%E6%8F%A1%E6%89%8B%E7%9A%84/"},{"categories":["协议"],"content":"TLS 报文格式 TLS 协议各种通常分为两部分： 靠近应用层的握手协议 TLS Handshaking Protocols 靠近 TCP 的记录层协议 TLS Record Protocol ","date":"2021-11-23","objectID":"/https%E5%8D%8F%E8%AE%AE%E6%98%AF%E5%A6%82%E4%BD%95%E6%8F%A1%E6%89%8B%E7%9A%84/:1:0","tags":["https"],"title":"HTTPS 协议是如何握手的","uri":"/https%E5%8D%8F%E8%AE%AE%E6%98%AF%E5%A6%82%E4%BD%95%E6%8F%A1%E6%89%8B%E7%9A%84/"},{"categories":["协议"],"content":"记录层协议（TLS Record Protocol） 记录层协议也可以理解为报文头（TLS Record header），占用 5 个字节 第 1 个字节是类型（Record Type Values），目前有 4 种类型 第 2-3 字节是版本（Version Values），目前有 4 种版本 第 4-5 字节是长度（不包含 TLS 报文头本身长度） record type (1 byte) / / version (1 byte major, 1 byte minor) / / / / length (2 bytes) / / / +----+----+----+----+----+ | | | | | | | | | | | | TLS Record header +----+----+----+----+----+ Record Type Values dec hex ------------------------------------- CHANGE_CIPHER_SPEC 20 0x14 ALERT 21 0x15 HANDSHAKE 22 0x16 APPLICATION_DATA 23 0x17 Version Values dec hex ------------------------------------- SSL 3.0 3,0 0x0300 TLS 1.0 3,1 0x0301 TLS 1.1 3,2 0x0302 TLS 1.2 3,3 0x0303 ","date":"2021-11-23","objectID":"/https%E5%8D%8F%E8%AE%AE%E6%98%AF%E5%A6%82%E4%BD%95%E6%8F%A1%E6%89%8B%E7%9A%84/:1:1","tags":["https"],"title":"HTTPS 协议是如何握手的","uri":"/https%E5%8D%8F%E8%AE%AE%E6%98%AF%E5%A6%82%E4%BD%95%E6%8F%A1%E6%89%8B%E7%9A%84/"},{"categories":["协议"],"content":"握手协议（TLS Handshaking Protocols） TLS 握手协议还能细分为 5 个子协议： change_cipher_spec （密码切换协议，在 TLS 1.3 中这个协议已经删除，为了兼容 TLS 老版本，可能还会存在） alert（警告协议，用来表示关闭信息和错误） handshake（握手协议，TLS 协议簇中最最核心的协议） application_data（应用数据协议） heartbeat （心跳协议，这个是 TLS 1.3 新加的，TLS 1.3 之前的版本没有这个协议） 以记录类型为 handshake 举例： 其中 Handshake 协议中有 10 种握手消息类型（不计算扩展），格式如下： | Record Layer | Handshake Layer | | | | ...more messages +----+----+----+----+----+----+----+----+----+------ - - - -+-- | 22 | | | | | | | | | | |0x16| | | | | | | | |message | +----+----+----+----+----+----+----+----+----+------ - - - -+-- / / | \\ \\----\\-----\\ | / / | \\\\ type: 22 / | \\ handshake message length / type / length: arbitrary (up to 16k) Handshake Type Values dec hex ------------------------------------- HELLO_REQUEST 0 0x00 CLIENT_HELLO 1 0x01 SERVER_HELLO 2 0x02 CERTIFICATE 11 0x0b SERVER_KEY_EXCHANGE 12 0x0c CERTIFICATE_REQUEST 13 0x0d SERVER_DONE 14 0x0e CERTIFICATE_VERIFY 15 0x0f CLIENT_KEY_EXCHANGE 16 0x10 FINISHED 20 0x14 ","date":"2021-11-23","objectID":"/https%E5%8D%8F%E8%AE%AE%E6%98%AF%E5%A6%82%E4%BD%95%E6%8F%A1%E6%89%8B%E7%9A%84/:1:2","tags":["https"],"title":"HTTPS 协议是如何握手的","uri":"/https%E5%8D%8F%E8%AE%AE%E6%98%AF%E5%A6%82%E4%BD%95%E6%8F%A1%E6%89%8B%E7%9A%84/"},{"categories":["协议"],"content":"TLS/SSL 握手流程 在交换 Hello 信息中，交换随机数，协商出后续使用的加密套件和对应的算法 单向/双向发送证书允许客户端和服务端进行身份认证 Server/Client key Exchange 根据选择的算法交换相应参数，协商出预备主密钥 双端通过预备主密钥、随机数计算出主密钥，用于后续的对称加密数据传输 完整的握手流程： Client Server ClientHello --------\u003e ServerHello Certificate* ServerKeyExchange* CertificateRequest* \u003c-------- ServerHelloDone Certificate* ClientKeyExchange CertificateVerify* [ChangeCipherSpec] Finished --------\u003e [ChangeCipherSpec] \u003c-------- Finished Application Data \u003c-------\u003e Application Data *表示着此阶段在某些条件下不存在，[]表示不属于握手报文 ","date":"2021-11-23","objectID":"/https%E5%8D%8F%E8%AE%AE%E6%98%AF%E5%A6%82%E4%BD%95%E6%8F%A1%E6%89%8B%E7%9A%84/:2:0","tags":["https"],"title":"HTTPS 协议是如何握手的","uri":"/https%E5%8D%8F%E8%AE%AE%E6%98%AF%E5%A6%82%E4%BD%95%E6%8F%A1%E6%89%8B%E7%9A%84/"},{"categories":["协议"],"content":"Client Hello(Client -\u003e Server) 主要作用是告诉 Server，Client 所支持的 TLS 协议版本、支持的加密算法等等。 Client Hello\" Client Hello Client 随机数（Random）：Client 生成的随机数，暂时称作 ClientHello random，用于后续的主密钥生成。 会话 ID（Session ID）：当 Client 通过一次完整的握手，与 Server 建立了一次完整的 Session，Server 会记录这次 Session 的信息，以备恢复会话的时候使用。上图中该字段为空，说明这是第一次连接到服务器。 加密算法套件（Cipher Suite）：包含了 Client 所支持的密码算法套件。TLS 中使用的密码套件有一种标准格式。上面的抓包中，Client 发送了 46 套加密套件，Server 会从中选出一种用于本次加密连接使用。一个加密算法套件是 4 个算法的组合。 压缩方法（Compression Methods）：加密之前的压缩算法。这个字段在 TLS 1.2 中用的不多。在 TLS 1.3 中这个字段被删除。 扩展（Extension）：结构定义是一个枚举类型，用于携带一些扩展参数，加强 TLS 功能。（携带域名，是否支持 http/2.0 等等） ","date":"2021-11-23","objectID":"/https%E5%8D%8F%E8%AE%AE%E6%98%AF%E5%A6%82%E4%BD%95%E6%8F%A1%E6%89%8B%E7%9A%84/:2:1","tags":["https"],"title":"HTTPS 协议是如何握手的","uri":"/https%E5%8D%8F%E8%AE%AE%E6%98%AF%E5%A6%82%E4%BD%95%E6%8F%A1%E6%89%8B%E7%9A%84/"},{"categories":["协议"],"content":"Server Hello(Server -\u003e Client) 收到 Client Hello 之后服务器必须发送 Server Hello 信息，Server 会检查 TLS 版本和算法的 Client Hello 的条件，如果服务器接受并支持所有条件，它将发送其证书以及其他详细信息。否则，服务器将发送握手失败消息。 Server Hello\" Server Hello Server 随机数（Random）：Server 生成的随机数，暂时称作 ServerHello random。注意，至此 Client 和 Server 都拥有了两个随机数。 会话 ID（Session ID）：服务器将约定的 Session 参数存储在 TLS 缓存中，并生成与其对应的 Session id。它与 Server Hello 一起发送到 Client。Client 可以写入约定的参数到此 Session id，并给定到期时间。Client 将在 Client Hello 中包含此 id。如果 Client 在此到期时间之前再次连接到服务器，则服务器可以检查与 Session id 对应的缓存参数，并重用它们而无需完全握手。这非常有用，因为服务器和 Client 都可以节省大量的计算成本。 加密算法套件（Cipher Suite）：抓包中 Server 选择了 TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256 (0xc02f)，其中密钥协商算法是 ECDHE、身份认证算法是 RSA、加密模式是 AES_128_GCM、消息认证码算法（MAC）是 SHA256。 压缩方法（Compression Methods）：如果支持，服务器将同意 Client 的首选压缩方法。 扩展（Extension）：同上，只有由 Client 给出的扩展才能出现在 Server 的列表中。 ","date":"2021-11-23","objectID":"/https%E5%8D%8F%E8%AE%AE%E6%98%AF%E5%A6%82%E4%BD%95%E6%8F%A1%E6%89%8B%E7%9A%84/:2:2","tags":["https"],"title":"HTTPS 协议是如何握手的","uri":"/https%E5%8D%8F%E8%AE%AE%E6%98%AF%E5%A6%82%E4%BD%95%E6%8F%A1%E6%89%8B%E7%9A%84/"},{"categories":["协议"],"content":"Certificate(Server -\u003e Client) Server 将数字证书和到根 CA 整个链发给 Client，使得 Client 能用证书中公钥进行认证。 Certificate\" Certificate ","date":"2021-11-23","objectID":"/https%E5%8D%8F%E8%AE%AE%E6%98%AF%E5%A6%82%E4%BD%95%E6%8F%A1%E6%89%8B%E7%9A%84/:2:3","tags":["https"],"title":"HTTPS 协议是如何握手的","uri":"/https%E5%8D%8F%E8%AE%AE%E6%98%AF%E5%A6%82%E4%BD%95%E6%8F%A1%E6%89%8B%E7%9A%84/"},{"categories":["协议"],"content":"Server Key Exchange(Server -\u003e Client) 主要作用是根据不同的密钥协商算法交换必要的密码信息。 如果密钥协商算法是 (EC)DHE，所以需要此阶段传递 DH 参数和 DH 公钥。 如果密钥协商算法为 RSA ，Client 不需要额外参数就可以计算出预备主密钥，然后使用 Server Certificate 中的公钥加密发送给 Server，所以不需要此阶段。 Server Key Exchange\" Server Key Exchange ","date":"2021-11-23","objectID":"/https%E5%8D%8F%E8%AE%AE%E6%98%AF%E5%A6%82%E4%BD%95%E6%8F%A1%E6%89%8B%E7%9A%84/:2:4","tags":["https"],"title":"HTTPS 协议是如何握手的","uri":"/https%E5%8D%8F%E8%AE%AE%E6%98%AF%E5%A6%82%E4%BD%95%E6%8F%A1%E6%89%8B%E7%9A%84/"},{"categories":["协议"],"content":"Certificate Request(Server -\u003e Client, 可选） 这一步是可选的，如果有则表示双向认证。如果在对安全性要求高的常见可能用到。服务器用来验证 Client。服务器端发出 Certificate Request 消息，要求 Client 发他自己的证书过来进行验证。例如银行给你发的 USB 盾牌。 ","date":"2021-11-23","objectID":"/https%E5%8D%8F%E8%AE%AE%E6%98%AF%E5%A6%82%E4%BD%95%E6%8F%A1%E6%89%8B%E7%9A%84/:2:5","tags":["https"],"title":"HTTPS 协议是如何握手的","uri":"/https%E5%8D%8F%E8%AE%AE%E6%98%AF%E5%A6%82%E4%BD%95%E6%8F%A1%E6%89%8B%E7%9A%84/"},{"categories":["协议"],"content":"Server Hello Done(Server -\u003e Client) 此消息完成握手协商的服务器部分，它不携带任何附加信息。 从 Server Hello 到 Server Hello Done，有些 Server 的实现是每条单独发送，有 Server 实现是合并到一起发送。Sever Hello 和 Server Hello Done 都是只有头没有内容的数据。 Server Hello Done\" Server Hello Done ","date":"2021-11-23","objectID":"/https%E5%8D%8F%E8%AE%AE%E6%98%AF%E5%A6%82%E4%BD%95%E6%8F%A1%E6%89%8B%E7%9A%84/:2:6","tags":["https"],"title":"HTTPS 协议是如何握手的","uri":"/https%E5%8D%8F%E8%AE%AE%E6%98%AF%E5%A6%82%E4%BD%95%E6%8F%A1%E6%89%8B%E7%9A%84/"},{"categories":["协议"],"content":"Certificate(Client -\u003e Server, 可选） 如果 Server 要求发送 Client 证书，Client 便会在该阶段将自己的证书发送过去。Server 在之前发送的 Certificate Request 消息中包含了服务器端所支持的证书类型和 CA 列表，因此 Client 会在自己的证书中选择满足这两个条件的第一个证书发送过去。若 Client 没有证书，则发送一个 no_certificate 警告。 ","date":"2021-11-23","objectID":"/https%E5%8D%8F%E8%AE%AE%E6%98%AF%E5%A6%82%E4%BD%95%E6%8F%A1%E6%89%8B%E7%9A%84/:2:7","tags":["https"],"title":"HTTPS 协议是如何握手的","uri":"/https%E5%8D%8F%E8%AE%AE%E6%98%AF%E5%A6%82%E4%BD%95%E6%8F%A1%E6%89%8B%E7%9A%84/"},{"categories":["协议"],"content":"Client Key Exchange(Client -\u003e Server) 主要作用是交换或者协商出预备主密钥，用于主密钥的计算。 对于 RSA 握手协商算法来说，Client 会生成的一个 48 字节的预备主密钥，其中前 2 个字节是 ProtocolVersion，后 46 字节是随机数，用 Server 的公钥加密之后通过此阶段发给 Server，Server 用私钥来解密。 对于 (EC)DHE 密钥协商算法来说，预备主密钥是双方通过椭圆曲线算法生成的，双方各自生成临时公私钥对，保留私钥，将公钥发给对方，然后就可以用自己的私钥以及对方的公钥通过椭圆曲线算法来生成预备主密钥。此时传递的是 (EC)DHE 算法公钥（图中的 Pubkey），预备主密钥是密钥在双方不直接传递密钥的情况下得到的。 当 Server 获得了可以计算预备主密钥的所有条件后，结合之前的 ClientHello random 和 ServerHello random，通过伪随机函数 PRF 生成并截取 48 字节为主密钥，用于后续对称加密传输数据的密钥，Client 同理。 Client Key Exchange\" Client Key Exchange ","date":"2021-11-23","objectID":"/https%E5%8D%8F%E8%AE%AE%E6%98%AF%E5%A6%82%E4%BD%95%E6%8F%A1%E6%89%8B%E7%9A%84/:2:8","tags":["https"],"title":"HTTPS 协议是如何握手的","uri":"/https%E5%8D%8F%E8%AE%AE%E6%98%AF%E5%A6%82%E4%BD%95%E6%8F%A1%E6%89%8B%E7%9A%84/"},{"categories":["协议"],"content":"Change Cipher Spec(Client -\u003e Server) 主要作用是表明接下来传输数据过程中可以对应用数据协议进行加密了。 密码切换协议，表示随后的信息都将用双方商定的加密方法和密钥发送（Change Cipher Spec 是一个独立的协议，体现在数据包中就是一个字节的数据，用于告知 Server，Client 已经切换到之前协商好的加密套件（Cipher Suite）的状态，准备使用之前协商好的加密套件加密数据并传输了。其中第一条加密的消息就是接下来的 Encrypted Handshake Message Change Cipher Spec\" Change Cipher Spec ","date":"2021-11-23","objectID":"/https%E5%8D%8F%E8%AE%AE%E6%98%AF%E5%A6%82%E4%BD%95%E6%8F%A1%E6%89%8B%E7%9A%84/:2:9","tags":["https"],"title":"HTTPS 协议是如何握手的","uri":"/https%E5%8D%8F%E8%AE%AE%E6%98%AF%E5%A6%82%E4%BD%95%E6%8F%A1%E6%89%8B%E7%9A%84/"},{"categories":["协议"],"content":"Encrypted Handshake Message(Client -\u003e Server, 也称 Finshed) 生成对称加密密钥之后，发送一条加密的数据，让 Server 解密验证，确认密钥的正确性。 Encrypted Handshake Message\" Encrypted Handshake Message ","date":"2021-11-23","objectID":"/https%E5%8D%8F%E8%AE%AE%E6%98%AF%E5%A6%82%E4%BD%95%E6%8F%A1%E6%89%8B%E7%9A%84/:2:10","tags":["https"],"title":"HTTPS 协议是如何握手的","uri":"/https%E5%8D%8F%E8%AE%AE%E6%98%AF%E5%A6%82%E4%BD%95%E6%8F%A1%E6%89%8B%E7%9A%84/"},{"categories":["协议"],"content":"Change Cipher Spec(Server -\u003e Client) 密码切换协议，服务端和客户端一样，告诉客户端可以开始加密通信。 Change Cipher Spec\" Change Cipher Spec ","date":"2021-11-23","objectID":"/https%E5%8D%8F%E8%AE%AE%E6%98%AF%E5%A6%82%E4%BD%95%E6%8F%A1%E6%89%8B%E7%9A%84/:2:11","tags":["https"],"title":"HTTPS 协议是如何握手的","uri":"/https%E5%8D%8F%E8%AE%AE%E6%98%AF%E5%A6%82%E4%BD%95%E6%8F%A1%E6%89%8B%E7%9A%84/"},{"categories":["协议"],"content":"Encrypted Handshake Message(Server -\u003e Client, 也称 Finshed) 生成对称加密密钥之后，发送一条加密的数据，让客户端解密验证；如果对方可以解密，则双方认证无误开始通信。 Encrypted Handshake Message\" Encrypted Handshake Message ","date":"2021-11-23","objectID":"/https%E5%8D%8F%E8%AE%AE%E6%98%AF%E5%A6%82%E4%BD%95%E6%8F%A1%E6%89%8B%E7%9A%84/:2:12","tags":["https"],"title":"HTTPS 协议是如何握手的","uri":"/https%E5%8D%8F%E8%AE%AE%E6%98%AF%E5%A6%82%E4%BD%95%E6%8F%A1%E6%89%8B%E7%9A%84/"},{"categories":["协议"],"content":"APPLICATION_DATA(CLient \u003c-\u003e Server) 这个阶段就很简单了，数据开始加密传输，其中Record Type Values 为 Application Data（23） APPLICATION_DATA\" APPLICATION_DATA ","date":"2021-11-23","objectID":"/https%E5%8D%8F%E8%AE%AE%E6%98%AF%E5%A6%82%E4%BD%95%E6%8F%A1%E6%89%8B%E7%9A%84/:2:13","tags":["https"],"title":"HTTPS 协议是如何握手的","uri":"/https%E5%8D%8F%E8%AE%AE%E6%98%AF%E5%A6%82%E4%BD%95%E6%8F%A1%E6%89%8B%E7%9A%84/"},{"categories":["协议"],"content":"参考 Traffic analysis of a TLS session The Transport Layer Security (TLS) Protocol Version 1.2 HTTPS 温故知新系列——冰霜大佬 ","date":"2021-11-23","objectID":"/https%E5%8D%8F%E8%AE%AE%E6%98%AF%E5%A6%82%E4%BD%95%E6%8F%A1%E6%89%8B%E7%9A%84/:3:0","tags":["https"],"title":"HTTPS 协议是如何握手的","uri":"/https%E5%8D%8F%E8%AE%AE%E6%98%AF%E5%A6%82%E4%BD%95%E6%8F%A1%E6%89%8B%E7%9A%84/"},{"categories":["编程语言"],"content":"Go 语言中的 byte 和 rune 实际上是 uin8 和 int32 类型 byte 一般来表示一些原始数据（如网络中的数据传输） rune 则用来表示 Unciode 字符 在 go 中 string 的底层用的就是 byte 字节数组存储的，它的遍历有两种情况 package main import ( \"fmt\" ) func main() { s := \"abc汉字\" for i := 0; i \u003clen(s); i++ { fmt.Printf(\"%c,\", s[i]) } fmt.Println() for _, r := range s { fmt.Printf(\"%c,\", r) } } // 结果 // a,b,c,æ,±,,å,­,, // a,b,c,汉,字, 想获取字符串中的字符个数需要转换 []rune 数组，获取中文字符下标同理 package main import ( \"fmt\" ) func main() { s := \"你好世界\" fmt.Println(len(s)) fmt.Println(len([]rune(s))) } // 结果 // 12 // 4 ","date":"2021-11-12","objectID":"/golang%E4%B8%AD%E7%9A%84stringrune%E5%92%8Cbyte/:0:0","tags":["Golang"],"title":"Golang中的string、rune和byte","uri":"/golang%E4%B8%AD%E7%9A%84stringrune%E5%92%8Cbyte/"},{"categories":["源码阅读"],"content":"Redis 中字符串的实现并没有完全使用 C 字符串，而是重新定义了简单动态字符串 SDS（Simple Dynamic String）用来表示字符串（Redis 3.2前）。 sds.h/sdshdr struct sdshdr { unsigned int len; // 记录 buf 数组中已使字节的数量 unsigned int free; // 记录 buf 数组中未使用字节的数量 char buf[]; // 字节数组，用于保存字符串 }; buf 数组长度不一定就是字符串长度 + 1（\"\\0\"），还有 free 空间，数组内未使用的字节通过 free 属性记录。 相比于 C 字符串，SDS 有以下优势： 兼容部分 C 字符串函数 sds.c/sdsnew * mystring = sdsnewlen(\"abc\",3); * * You can print the string with printf() as there is an implicit \\0 at the * end of the string. However the string is binary safe and can contain * \\0 characters in the middle, as the length is stored in the sds header. */ sds sdsnewlen(const void *init, size_t initlen) { struct sdshdr *sh; if (init) { sh = zmalloc(sizeof(struct sdshdr)+initlen+1); } else { sh = zcalloc(sizeof(struct sdshdr)+initlen+1); } if (sh == NULL) return NULL; sh-\u003elen = initlen; sh-\u003efree = 0; if (initlen \u0026\u0026 init) memcpy(sh-\u003ebuf, init, initlen); sh-\u003ebuf[initlen] = '\\0'; return (char*)sh-\u003ebuf; } /* Create a new sds string starting from a null termined C string. */ sds sdsnew(const char *init) { size_t initlen = (init == NULL) ? 0 : strlen(init); return sdsnewlen(init, initlen); 从 SDS 的创建逻辑中可以看出 SDS 遵循 C 字符串以空字符（\"\\0\"）结尾。 SDS 中的 len 属性（sds.h/sdslen）同 C 字符串函数 strlen 返回结果相同，即不计算尾部空字符。 这样 SDS 就可以直接重用一部分 C 字符串函数库里面的函数（如打印，显示类函数，\u003cstdio.h\u003e/printf），而字符串的修改操作，则使用 SDS 自定义优化后的函数。 常数复杂度获取字符串长度 C 获取一个 C 字符串的长度，程序必须遍历整个字符串，直到遇到代表字符串结尾的空字符串位置，这个操作的复杂度为 O(N)。 但是对于 SDS 来说，获取字符串长度只需要访问 SDS 中的 len 属性。复杂度仅为 O(1)，确保了获取字符串长度这样的高频操作不会成为 Redis 性能瓶颈。 对于 SDS 的修改操作，SDS 会实时维护 len 属性，如 sds.c/sdscat（追加 C 字符串到 SDS 字符串） /* Append the specified binary-safe string pointed by 't' of 'len' bytes to the * end of the specified sds string 's'. * * After the call, the passed sds string is no longer valid and all the * references must be substituted with the new pointer returned by the call. */ sds sdscatlen(sds s, const void *t, size_t len) { struct sdshdr *sh; size_t curlen = sdslen(s); s = sdsMakeRoomFor(s,len); if (s == NULL) return NULL; sh = (void*) (s-(sizeof(struct sdshdr))); memcpy(s+curlen, t, len); sh-\u003elen = curlen+len; sh-\u003efree = sh-\u003efree-len; s[curlen+len] = '\\0'; return s; } /* Append the specified sds 't' to the existing sds 's'. * * After the call, the modified sds string is no longer valid and all the * references must be substituted with the new pointer returned by the call. */ sds sdscatsds(sds s, const sds t) { return sdscatlen(s, t, sdslen(t)); } 杜绝缓冲区溢出 C 字符串由于不记录自身长度，对其进行修改操作容易造成缓冲区溢出（buffer overflow）。如 C 字符串拼接函数 \u003cstdio.h\u003e/strcat，内存中相邻的字符串 s1 和 s2，对 s1 字符串做拼接操作时，如果没有提前为 s1 分配足够的空间，则 s2 保存的内容会被意外修改。 SDS 内部维护了一个 free 字段，当 SDS API 需要对其进行修改时，API 会调用 sdsMakeRoomForDS 函数检测当前 SDS 的 free 空间是否满足要求，满足直接进行修改；不满足 sdsMakeRoomForDS 则会将 SDS 的空间扩展至执行修改所需的大小，避免缓冲区溢出的情况（如上方 sds.c/sdscat）。 减少修改字符串长度时所需内存重分配次数 Redis 作为数据库，经常被用于速度要求严苛，数据被频繁修改的场景。SDS 实现了 空间预分配 和 惰性空间释放 两种优化策略。 sds.c/sdsMakeRoomFor /* Enlarge the free space at the end of the sds string so that the caller * is sure that after calling this function can overwrite up to addlen * bytes after the end of the string, plus one more byte for nul term. * * Note: this does not change the *length* of the sds string as returned * by sdslen(), but only the free buffer space we have. */ sds sdsMakeRoomFor(sds s, size_t addlen) { struct sdshdr *sh, *newsh; size_t free = sdsavail(s); size_t len, newlen; if (free\u003e= addlen) return s; len = sdslen(s); sh = (void*) (s-(sizeof(struct sdshdr))); newlen = (len+addlen); if (newlen \u003c SDS_MAX_PREALLOC) newlen *= 2; else newlen += SDS_MAX_PREALLOC; newsh = zrealloc(sh, sizeof(struct sdshdr)+newlen+1); if (newsh == NULL) return NULL; newsh-\u003efree = newlen - len; return newsh-\u003ebuf; } ","date":"2021-11-05","objectID":"/redis%E6%BA%90%E7%A0%81%E4%B9%8B%E7%AE%80%E5%8D%95%E5%8A%A8%E6%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2/:0:0","tags":["Redis"],"title":"Redis源码之简单动态字符串","uri":"/redis%E6%BA%90%E7%A0%81%E4%B9%8B%E7%AE%80%E5%8D%95%E5%8A%A8%E6%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"categories":["源码阅读"],"content":"空间预分配 可以发现，在 SDS API 进行字符串新增逻辑中会给 SDS 重新分配 free 空间。 如果 SDS 的长度（len 属性）小于 SDS_MAX_PREALLOC（1024KB=1M），则会分配和 len 属性同样大小的未使用空间给 buf，这时 SDS 的 len 属性和 free 属性值相同。 如果 SDS 长度大于或者等于 SDS_MAX_PREALLOC（1024KB=1M），则会直接给 free 属性分配 SDS_MAX_PREALLOC（1024KB=1M） 的大小。 通过空间预分配策略，Redis 可以减少连续执行字符串增长操作所需的内存重分配次数. ","date":"2021-11-05","objectID":"/redis%E6%BA%90%E7%A0%81%E4%B9%8B%E7%AE%80%E5%8D%95%E5%8A%A8%E6%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2/:1:0","tags":["Redis"],"title":"Redis源码之简单动态字符串","uri":"/redis%E6%BA%90%E7%A0%81%E4%B9%8B%E7%AE%80%E5%8D%95%E5%8A%A8%E6%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"categories":["源码阅读"],"content":"惰性空间释放 sds.c/sdstrim /* Remove the part of the string from left and from right composed just of * contiguous characters found in 'cset', that is a null terminted C string. * * After the call, the modified sds string is no longer valid and all the * references must be substituted with the new pointer returned by the call. * * Example: * * s = sdsnew(\"AA...AA.a.aa.aHelloWorld :::\"); * s = sdstrim(s,\"A. :\"); * printf(\"%s\\n\", s); * * Output will be just \"Hello World\". */ sds sdstrim(sds s, const char *cset) { struct sdshdr *sh = (void*) (s-(sizeof(struct sdshdr))); char *start, *end, *sp, *ep; size_t len; sp = start = s; ep = end = s+sdslen(s)-1; while(sp \u003c= end \u0026\u0026 strchr(cset, *sp)) sp++; while(ep\u003e start \u0026\u0026 strchr(cset, *ep)) ep--; len = (sp\u003e ep) ? 0 : ((ep-sp)+1); if (sh-\u003ebuf != sp) memmove(sh-\u003ebuf, sp, len); sh-\u003ebuf[len] = '\\0'; sh-\u003efree = sh-\u003efree+(sh-\u003elen-len); sh-\u003elen = len; return s; } 可以发现，在进行字符串剪切操作时，多出的 buf 空间并不会直接释放，而是存储在 free 字段中。 同时为了避免内存泄露，SDS 也提供了 sds.c/sdsRemoveFreeSpace 释放 free 空间操作，在 redis.c/clientsCronResizeQueryBuffer 中可以看到，当 querybuf 大于 1024 字节，会进行释放操作。 /* Reallocate the sds string so that it has no free space at the end. The * contained string remains not altered, but next concatenation operations * will require a reallocation. * * After the call, the passed sds string is no longer valid and all the * references must be substituted with the new pointer returned by the call. */ sds sdsRemoveFreeSpace(sds s) { struct sdshdr *sh; sh = (void*) (s-(sizeof(struct sdshdr))); sh = zrealloc(sh, sizeof(struct sdshdr)+sh-\u003elen+1); sh-\u003efree = 0; return sh-\u003ebuf; } /* The client query buffer is an sds.c string that can end with a lot of * free space not used, this function reclaims space if needed. * * The function always returns 0 as it never terminates the client. */ int clientsCronResizeQueryBuffer(redisClient *c) { size_t querybuf_size = sdsAllocSize(c-\u003equerybuf); time_t idletime = server.unixtime - c-\u003elastinteraction; /* There are two conditions to resize the query buffer: * 1) Query buffer is \u003e BIG_ARG and too big for latest peak. * 2) Client is inactive and the buffer is bigger than 1k. */ if (((querybuf_size\u003e REDIS_MBULK_BIG_ARG) \u0026\u0026 (querybuf_size/(c-\u003equerybuf_peak+1)) \u003e 2) || (querybuf_size\u003e 1024 \u0026\u0026 idletime \u003e 2)) { /* Only resize the query buffer if it is actually wasting space. */ if (sdsavail(c-\u003equerybuf) \u003e 1024) { c-\u003equerybuf = sdsRemoveFreeSpace(c-\u003equerybuf); } } /* Reset the peak again to capture the peak memory usage in the next * cycle. */ c-\u003equerybuf_peak = 0; return 0; } 二进制安全 SDS API 都会以处理二进制的方式来处理 SDS 存放在 buf 数组里的数据（如不以 “\\0” 当作字符串结尾），程序不会对其中的数据做任何限制、过滤、或者假设，数据在写入时是什么样的，他被读取时就是什么样子。因此 Redis 可以不仅可以保存文本数据，还可以保存图片、音频、视频、压缩文件这样的二进制数据。 SDS API SDS API\" SDS API ","date":"2021-11-05","objectID":"/redis%E6%BA%90%E7%A0%81%E4%B9%8B%E7%AE%80%E5%8D%95%E5%8A%A8%E6%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2/:2:0","tags":["Redis"],"title":"Redis源码之简单动态字符串","uri":"/redis%E6%BA%90%E7%A0%81%E4%B9%8B%E7%AE%80%E5%8D%95%E5%8A%A8%E6%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"categories":["运维部署"],"content":"有关静态博客部署的文章、视频教程已经很多了 大致总结可以分为三类： Github Pages + Github Action（网站托管，如：Vercel） 本地编译 + rsync 远程服务器 本地编译 + 推送对象存储（七牛云） ","date":"2021-11-04","objectID":"/%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/:0:0","tags":["博客"],"title":"静态博客部署的最佳实践","uri":"/%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"},{"categories":["运维部署"],"content":"最佳实践 本地更新完文章提交推送 触发 Github Action Action 的 workflow 中完成静态资源的编译、推送至云服务器 云服务器 Nginx 访问静态资源 之前博客一直部署在 Github+Vercel，奈何美国服务器延迟太高， 国内的阿里云、腾讯云的网站托管、云开发体验太差， 刚好双十一购入三年的 2 核 4G 8M 带宽的轻量服务器（腾讯云 YYDS）！！！ 趁着周末研究研究如何部署到云服务器上， 总体体验不错，满足了我既要远程编译，Github 托管代码、访问速度要快的需求， 这套流程中你只需要写好文章（不需要编博客译环境），推送至 Github 即可， 没有跑完这整个流程之前还比较担心 Github rsync 到腾讯云服务器会不会要很久，毕竟 Github 服务器在美国 实际测试 30s 内就可以完成整套 workflow，还是比较满意的 PS：首次可能会慢点，后续的 rsync 应该都是增量更新 顺带也开启了 HTTP/2.0，还是挺香的 ","date":"2021-11-04","objectID":"/%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/:1:0","tags":["博客"],"title":"静态博客部署的最佳实践","uri":"/%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"},{"categories":["运维部署"],"content":"部分配置文件 使用 PEM 格式生成公钥私钥 ssh-keygen -m PEM -t rsa -b 4096 生成的公钥追加到 authorized_keys 中 cd .ssh/;cat id_rsa.pub \u003e\u003e authorized_keys ","date":"2021-11-04","objectID":"/%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/:2:0","tags":["博客"],"title":"静态博客部署的最佳实践","uri":"/%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"},{"categories":["运维部署"],"content":"Github Action .github/workflows/main.yml # This is a basic workflow to help you get started with Actionsname:github pages# Controls when the workflow will runon:# Triggers the workflow on push or pull request events but only for the main branchpush:branches:[main]paths-ignore:- '.gitignore'- 'README.md'pull_request:branches:[main]# Allows you to run this workflow manually from the Actions tabworkflow_dispatch:# A workflow run is made up of one or more jobs that can run sequentially or in paralleljobs:# This workflow contains a single job called \"build\"deploy:# The type of runner that the job will run onruns-on:ubuntu-latestconcurrency:group:${{github.workflow}}-${{ github.ref }}# Steps represent a sequence of tasks that will be executed as part of the jobsteps:# Checks-out your repository under $GITHUB_WORKSPACE, so your job can access it- uses:actions/checkout@v2# Runs a single command using the runners shell- name:Setup Hugouses:peaceiris/actions-hugo@v2with:hugo-version:'0.85.0'extended:true- name:Buildrun:hugo --minify# Runs a set of commands using the runners shell- name:Github Deployuses:peaceiris/actions-gh-pages@v3if:github.ref == 'refs/heads/main'with:github_token:${{secrets.ACCESS_TOKEN}}publish_dir:./public# Deploy to Server- name:Serveruses:easingthemes/ssh-deploy@mainenv:SSH_PRIVATE_KEY:${{secrets.SERVER_SSH_KEY}}SOURCE:\"public/\"REMOTE_HOST:${{secrets.REMOTE_HOST}}REMOTE_USER:${{secrets.REMOTE_USER}}TARGET:${{secrets.REMOTE_TARGET}} ","date":"2021-11-04","objectID":"/%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/:2:1","tags":["博客"],"title":"静态博客部署的最佳实践","uri":"/%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"},{"categories":["运维部署"],"content":"Nginx 开启了 HTTP/2.0 HTTP 访问 301 跳转到 HTTPS server { listen 80; listen [::]:80; server_name \u003cyour.domain\u003e; return 301 https://$host$request_uri; } server { listen 443 ssl http2; listen [::]:443 ssl http2; server_name \u003cyour.domain\u003e; ssl_certificate \"\u003cyour.pem\u003e\"; ssl_certificate_key \"\u003cyour.key\u003e\"; ssl_session_cache shared:SSL:1m; ssl_session_timeout 10m; ssl_ciphers HIGH:!aNULL:!MD5; ssl_prefer_server_ciphers on; access_log /var/log/nginx/access.log; error_log /var/log/nginx/error.log; location / { root \u003cyour.dir\u003e/public; index index.html; } } ","date":"2021-11-04","objectID":"/%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/:2:2","tags":["博客"],"title":"静态博客部署的最佳实践","uri":"/%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"},{"categories":["做饭记录"],"content":"处理排骨 排骨冷水下锅，放入生姜、葱段、料酒去腥 水开后撇去浮沫 倒出排骨，冷水冲洗，沥干水分 ","date":"2021-11-04","objectID":"/%E7%82%96%E6%8E%92%E9%AA%A8%E6%B1%A4%E7%9A%84%E6%8A%80%E5%B7%A7/:1:0","tags":null,"title":"炖排骨汤的技巧","uri":"/%E7%82%96%E6%8E%92%E9%AA%A8%E6%B1%A4%E7%9A%84%E6%8A%80%E5%B7%A7/"},{"categories":["做饭记录"],"content":"煎制排骨 热锅凉油放入生姜葱段爆香 倒入沥干水分的排骨煎制两面金黄 淋入料酒去腥 倒入开水淹没过排骨 ","date":"2021-11-04","objectID":"/%E7%82%96%E6%8E%92%E9%AA%A8%E6%B1%A4%E7%9A%84%E6%8A%80%E5%B7%A7/:2:0","tags":null,"title":"炖排骨汤的技巧","uri":"/%E7%82%96%E6%8E%92%E9%AA%A8%E6%B1%A4%E7%9A%84%E6%8A%80%E5%B7%A7/"},{"categories":["做饭记录"],"content":"砂锅炖汤 水沸后转入砂锅 加入姜片、花椒、葱结、料酒去腥 大火炖煮至沸腾 加入配菜，如：玉米、山药、胡萝卜等 转小火继续炖煮 1 小时左右（切记不要炖久了，肉会烂成肉渣） 中途不要放盐，吃的时候在放盐 ","date":"2021-11-04","objectID":"/%E7%82%96%E6%8E%92%E9%AA%A8%E6%B1%A4%E7%9A%84%E6%8A%80%E5%B7%A7/:3:0","tags":null,"title":"炖排骨汤的技巧","uri":"/%E7%82%96%E6%8E%92%E9%AA%A8%E6%B1%A4%E7%9A%84%E6%8A%80%E5%B7%A7/"},{"categories":["编程语言"],"content":"编译 go build [-o 输出名] [-i] [编译标记] [包名] 默认我们 go build 的可执行文件都是当前操作系统可执行的文件，如果我想在 macOS 下编译一个 linux 下可执行文件，那需要怎么做呢？ 只需要指定目标操作系统的平台和处理器架构即可，例如 Window 平台终端下按如下方式指定环境变量。 SET CGO_ENABLED=0 // 禁用 CGO SET GOOS=linux // 目标平台是 linux SET GOARCH=amd64 // 目标处理器架构是 amd64 ","date":"2021-10-29","objectID":"/golang%E8%B7%A8%E5%B9%B3%E5%8F%B0%E7%BC%96%E8%AF%91%E5%8F%8A%E4%BC%98%E5%8C%96%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%93%E7%A7%AF/:1:0","tags":["Golang"],"title":"Golang跨平台编译及优化二进制体积","uri":"/golang%E8%B7%A8%E5%B9%B3%E5%8F%B0%E7%BC%96%E8%AF%91%E5%8F%8A%E4%BC%98%E5%8C%96%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%93%E7%A7%AF/"},{"categories":["编程语言"],"content":"macOS 编译 Linux 和 Windows 平台 64 位 可执行程序: CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build CGO_ENABLED=0 GOOS=windows GOARCH=amd64 go build ","date":"2021-10-29","objectID":"/golang%E8%B7%A8%E5%B9%B3%E5%8F%B0%E7%BC%96%E8%AF%91%E5%8F%8A%E4%BC%98%E5%8C%96%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%93%E7%A7%AF/:1:1","tags":["Golang"],"title":"Golang跨平台编译及优化二进制体积","uri":"/golang%E8%B7%A8%E5%B9%B3%E5%8F%B0%E7%BC%96%E8%AF%91%E5%8F%8A%E4%BC%98%E5%8C%96%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%93%E7%A7%AF/"},{"categories":["编程语言"],"content":"Linux 编译 Mac 和 Windows 平台 64 位可执行程序： CGO_ENABLED=0 GOOS=darwin GOARCH=amd64 go build CGO_ENABLED=0 GOOS=windows GOARCH=amd64 go build ","date":"2021-10-29","objectID":"/golang%E8%B7%A8%E5%B9%B3%E5%8F%B0%E7%BC%96%E8%AF%91%E5%8F%8A%E4%BC%98%E5%8C%96%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%93%E7%A7%AF/:1:2","tags":["Golang"],"title":"Golang跨平台编译及优化二进制体积","uri":"/golang%E8%B7%A8%E5%B9%B3%E5%8F%B0%E7%BC%96%E8%AF%91%E5%8F%8A%E4%BC%98%E5%8C%96%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%93%E7%A7%AF/"},{"categories":["编程语言"],"content":"Windows 编译 Mac 平台 64 位可执行程序 SET CGO_ENABLED=0 SET GOOS=darwin SET GOARCH=amd64 go build ","date":"2021-10-29","objectID":"/golang%E8%B7%A8%E5%B9%B3%E5%8F%B0%E7%BC%96%E8%AF%91%E5%8F%8A%E4%BC%98%E5%8C%96%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%93%E7%A7%AF/:1:3","tags":["Golang"],"title":"Golang跨平台编译及优化二进制体积","uri":"/golang%E8%B7%A8%E5%B9%B3%E5%8F%B0%E7%BC%96%E8%AF%91%E5%8F%8A%E4%BC%98%E5%8C%96%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%93%E7%A7%AF/"},{"categories":["编程语言"],"content":"优化 ","date":"2021-10-29","objectID":"/golang%E8%B7%A8%E5%B9%B3%E5%8F%B0%E7%BC%96%E8%AF%91%E5%8F%8A%E4%BC%98%E5%8C%96%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%93%E7%A7%AF/:2:0","tags":["Golang"],"title":"Golang跨平台编译及优化二进制体积","uri":"/golang%E8%B7%A8%E5%B9%B3%E5%8F%B0%E7%BC%96%E8%AF%91%E5%8F%8A%E4%BC%98%E5%8C%96%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%93%E7%A7%AF/"},{"categories":["编程语言"],"content":"新增args Go 编译器默认编译出来的程序会带有符号表和调试信息，一般来说 release 版本可以去除调试信息以减小二进制体积 go build -ldflags=\"-s -w\" -o server main.go -s：忽略符号表和调试信息 -w：忽略DWARFv3调试信息，使用该选项后将无法使用gdb进行调试 ","date":"2021-10-29","objectID":"/golang%E8%B7%A8%E5%B9%B3%E5%8F%B0%E7%BC%96%E8%AF%91%E5%8F%8A%E4%BC%98%E5%8C%96%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%93%E7%A7%AF/:2:1","tags":["Golang"],"title":"Golang跨平台编译及优化二进制体积","uri":"/golang%E8%B7%A8%E5%B9%B3%E5%8F%B0%E7%BC%96%E8%AF%91%E5%8F%8A%E4%BC%98%E5%8C%96%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%93%E7%A7%AF/"},{"categories":["编程语言"],"content":"使用 upx 减小体积 upx 是一个常用的压缩动态库和可执行文件的工具，通常可减少 50-70% 的体积。 upx 的安装方式非常简单，我们可以直接从 github 下载最新的 release 版本，支持 Windows 和 Linux，在 Ubuntu 或 Mac 可以直接使用包管理工具安装。 upx 有很多参数，最重要的则是压缩率，1-9，1 代表最低压缩率，9 代表最高压缩率。 go build -ldflags=\"-s -w\" -o server main.go \u0026\u0026 upx -9 server upx 压缩后的程序和压缩前的程序一样，无需解压仍然能够正常地运行，这种压缩方法称之为带壳压缩，压缩包含两个部分： 在程序开头或其他合适的地方插入解压代码； 将程序的其他部分压缩。 执行时，也包含两个部分： 首先执行的是程序开头的插入的解压代码，将原来的程序在内存中解压出来； 再执行解压后的程序。 也就是说，upx 在程序执行时，会有额外的解压动作，不过这个耗时几乎可以忽略。 如果对编译后的体积没什么要求的情况下，可以不使用 upx 来压缩。一般在服务器端独立运行的后台服务，无需压缩体积。 ","date":"2021-10-29","objectID":"/golang%E8%B7%A8%E5%B9%B3%E5%8F%B0%E7%BC%96%E8%AF%91%E5%8F%8A%E4%BC%98%E5%8C%96%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%93%E7%A7%AF/:2:2","tags":["Golang"],"title":"Golang跨平台编译及优化二进制体积","uri":"/golang%E8%B7%A8%E5%B9%B3%E5%8F%B0%E7%BC%96%E8%AF%91%E5%8F%8A%E4%BC%98%E5%8C%96%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%93%E7%A7%AF/"},{"categories":["编程语言"],"content":"参考 How to reduce compiled file size? StackOverflow ","date":"2021-10-29","objectID":"/golang%E8%B7%A8%E5%B9%B3%E5%8F%B0%E7%BC%96%E8%AF%91%E5%8F%8A%E4%BC%98%E5%8C%96%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%93%E7%A7%AF/:3:0","tags":["Golang"],"title":"Golang跨平台编译及优化二进制体积","uri":"/golang%E8%B7%A8%E5%B9%B3%E5%8F%B0%E7%BC%96%E8%AF%91%E5%8F%8A%E4%BC%98%E5%8C%96%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%93%E7%A7%AF/"},{"categories":["学习记录"],"content":" 本书主要介绍了计算机系统的基本概念, 包括最底层的内存中的数据表示、流水线指令的构成、虚拟存储器、编译系统、动态加载库以及用户应用等。书中提供了大量实际操作, 可以帮助读者更好地理解程序执行的方式, 改进程序的执行效率。 一本相见恨晚的书，非计科出身果然还是有很长的路要走。 首次阅读确实不是很懂，可以暂时放一放 当有了实际编码经验、抽象思维逻辑再阅读，你会有所收获的！ ","date":"2021-08-21","objectID":"/%E5%AD%A6%E4%B9%A0%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/:0:0","tags":["CSAPP"],"title":"学习《深入理解计算机系统》","uri":"/%E5%AD%A6%E4%B9%A0%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"},{"categories":["学习记录"],"content":"教材 我用阿里云盘分享了「深入理解计算机系统（第三版）.pdf」，你可以不限速下载🚀 复制这段内容打开「阿里云盘」App 即可获取 链接：https://www.aliyundrive.com/s/bTBiCehPPJv ","date":"2021-08-21","objectID":"/%E5%AD%A6%E4%B9%A0%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/:0:1","tags":["CSAPP"],"title":"学习《深入理解计算机系统》","uri":"/%E5%AD%A6%E4%B9%A0%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"},{"categories":["学习记录"],"content":"视频 ","date":"2021-08-21","objectID":"/%E5%AD%A6%E4%B9%A0%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/:0:2","tags":["CSAPP"],"title":"学习《深入理解计算机系统》","uri":"/%E5%AD%A6%E4%B9%A0%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"},{"categories":["学习记录"],"content":"其他 https://github.com/EugeneLiu/translationCSAPP https://www.zhihu.com/question/20354069 ","date":"2021-08-21","objectID":"/%E5%AD%A6%E4%B9%A0%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/:0:3","tags":["CSAPP"],"title":"学习《深入理解计算机系统》","uri":"/%E5%AD%A6%E4%B9%A0%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"},{"categories":["操作系统"],"content":"忽略 macOS Catalina 10.15 更新通知 隐藏 / 关闭更新通知依次打开 启动台 - 其他 - 终端，输入以下神秘代码，Enter 后输入用户密码即可。 sudo softwareupdate --ignore \"macOS Catalina\" 将来要是想开了，又想更新了，再次输入以下神秘代码即可。 sudo softwareupdate --reset-ignored Tip：此方法在 macOS 10.16 Big Sur 已经不适用，暂时没有找到合适的方法 屏蔽升级 Catalina 软件更新小红点 如果在此之前已经点击了软件更新出现了小红点，对于强迫症用户十分不友好。 打开 启动台 - 其他 - 终端 - 输入 defaults write com.apple.systempreferences AttentionPrefBundleIDs 0 然后继续输入 killall Dock 烦人的小红点就消失了！！！ 外接显示器 Dock 栏会乱跑 鼠标在上方屏幕红框处，也就是鼠标移不下去的地方放置一两秒，Dock 栏就会跑到上方屏幕 同理，鼠标放下下方屏幕，鼠标移不下去的地方放置，Dock 栏就会跑到下方屏幕 个人感觉这个设计很烂，而且也没有开关能永久固定 Dock 栏，希望 Appple 设计师能改改！！！ 也可以在设置 -\u003e 调度中心取消勾选「显示器具有单独的空间」 按住 Command 连续选中文件 Command 键是 macOS 上最基础的文件选择辅助按键之一。按住 Command 后再选文件，只要保持 Command 键一直按着，已经选中的文件就会一直保持被选中的状态。 相关的快捷键有：Command+A 全选所有文件 按住 Command 连续选中文件 Command 键是 macOS 上最基础的文件选择辅助按键之一。按住 Command 后再选文件，只要保持 Command 键一直按着，已经选中的文件就会一直保持被选中的状态。 相关的快捷键有：Command+A 全选所有文件 按住 Command + 鼠标移动，可以快速移动和删除图标 这个组合键，适用于 Mac 菜单栏上的图标和一些包括 Finder 在内的系统自带软件的菜单栏。 通过 Command + 点击在新窗口中打开 Finder 侧边栏上的项目 点住 Command 键后，再点击 Finder 侧边栏上的任意项目，这样就可以在新 Finder 窗口中打开。这个操作可以应用在任何侧边栏项目，包括收藏、共享和设备。当我们想要在两个窗口之间复制或移动文件时，这个功能非常实用。 Command + 鼠标拖拽可以移动后方的窗口，同时不影响前端窗口 想要查看背景中窗口，但是不想失去对最前方窗口的控制？通过 Command + 拖拽即可实现。 Command + 回车 Spotlight 中的搜索结果可以直接在 Finder 中查看 与 Dock 操作一样，当使用 Spotlight 搜索时，只需通过 Command + 回车即可打开搜索结果中文件的位置，直接回车会打开文件。 使用 Command 键选择不相邻的文件 Command 的其他组合键 Command + W：关闭最前面的窗口 Command + M：将最前面的窗口最小化至 “程序坞” Command + F：查找 Command + X：剪切所选项并拷贝到剪贴板 Command + C：将所选项拷贝到剪贴板 Command + V：将剪贴板的内容粘贴到当前文稿或应用中 Command + Z：撤销上一个命令 Command + A：全选各项 Command + tab：切换应用 Command + shift + 3: 全屏截图 Command + shift + 4: 部分截图 ","date":"2021-07-30","objectID":"/macos%E4%BD%BF%E7%94%A8%E5%B0%8F%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/:0:0","tags":["macOS"],"title":"MacOS 使用小方法总结","uri":"/macos%E4%BD%BF%E7%94%A8%E5%B0%8F%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/"},{"categories":["运维部署"],"content":"Confluence Confluence 是一个专业的企业知识管理与协同软件，也可以用于构建企业 wiki。使用简单，但它强大的编辑和站点管理特征能够帮助团队成员之间共享信息、文档协作、集体讨论，信息推送 ","date":"2021-07-25","objectID":"/docker%E9%83%A8%E7%BD%B2%E5%B9%B6%E7%A0%B4%E8%A7%A3confluence%E5%92%8Cjira%E5%8F%8A%E6%8F%92%E4%BB%B6/:1:0","tags":["开源软件"],"title":"Docker部署并破解Confluence和JIRA及插件","uri":"/docker%E9%83%A8%E7%BD%B2%E5%B9%B6%E7%A0%B4%E8%A7%A3confluence%E5%92%8Cjira%E5%8F%8A%E6%8F%92%E4%BB%B6/"},{"categories":["运维部署"],"content":"数据库设置 不建议将数据库部署在 Docker 容器，推荐使用云数据库或者物理机数据库。 文档 Confluence Data Center and Server documentation Database Configuration 数据库设置 选择安装的 Confluence 版本，阅读 Database Setup For MySQL 后，修改Mysql 配置文件 ，本文以 Mysql 8.0 为例 [mysqld] ... character-set-server=utf8mb4 collation-server=utf8mb4_bin default-storage-engine=INNODB max_allowed_packet=256M innodb_log_file_size=2GB transaction-isolation=READ-COMMITTED binlog_format=row log-bin-trust-function-creators = 1 // 如果为 Mysql5.7，关闭 derived_merge 能优化仪表板加载缓慢 optimizer_switch = derived_merge=off ... 如果 sql_mode = NO_AUTO_VALUE_ON_ZERO，请删除此选项 创建数据库 \u0026 用户 创建数据库 CREATEDATABASE\u003cdatabase-name\u003eCHARACTERSETutf8mb4COLLATEutf8mb4_bin; 创建用户 CREATEuser'\u003cconfluenceuser\u003e'@'localhost'IDENTIFIEDBY'\u003cpassword\u003e'; 如果 Confluence 与数据库不在同一台服务器上运行（或者是 Docker 用户），请用 Confluence 服务器的主机名或 IP 地址替换 localhost（也可以使用 %，表示允许所有 host） 授权 GRANTALLPRIVILEGESON\u003cdatabase-name\u003e.*TO'\u003cconfluenceuser\u003e'@'localhost'WITHGRANTOPTION; ","date":"2021-07-25","objectID":"/docker%E9%83%A8%E7%BD%B2%E5%B9%B6%E7%A0%B4%E8%A7%A3confluence%E5%92%8Cjira%E5%8F%8A%E6%8F%92%E4%BB%B6/:1:1","tags":["开源软件"],"title":"Docker部署并破解Confluence和JIRA及插件","uri":"/docker%E9%83%A8%E7%BD%B2%E5%B9%B6%E7%A0%B4%E8%A7%A3confluence%E5%92%8Cjira%E5%8F%8A%E6%8F%92%E4%BB%B6/"},{"categories":["运维部署"],"content":"Docker Compose 文档 镜像：atlassian/confluence-server 破解插件：atlassian-agent 项目已被私有，无法访问 准备工具 破解插件 atlassian-agent.jar 直接使用仓库内 atlassian-agent.jar 数据库驱动 官方镜像并没有内置 MySQL driver，需要自行下载：Database JDBC Drivers 。 Mysql 8.0 下载：mysql-connector-java-8.0.22.jar Mysql 5.7 下载：mysql-connector-java-5.1.48.jar docker-compose.yml version:'3'services:confluence:image:\"atlassian/confluence-server\"volumes:- ./atlassian-agent.jar:/var/atlassian/atlassian-agent.jar- ./mysql-connector-java-8.0.22.jar:/opt/atlassian/confluence/confluence/WEB-INF/lib/mysql-connector-java-8.0.22.jar- ~/your-confluence-home:/var/atlassian/application-data/confluenceenvironment:- JAVA_OPTS=\"-javaagent:/var/atlassian/atlassian-agent.jar\"- JVM_MINIMUM_MEMORY=2048m- JVM_MAXIMUM_MEMORY=2048m- JVM_RESERVED_CODE_CACHE_SIZE=512mports:- \"8090:8090\"restart:always 默认内存分配为 1024m，如果需要覆盖 Confluence Server 的默认内存分配，可以通过环境变量 JVM_MINIMUM_MEMORY、JVM_MAXIMUM_MEMORY、JVM_RESERVED_CODE_CACHE_SIZE 控制最小堆 (Xms) 和最大堆(Xmx)。 # 重新创建容器实现修改 docker-compose up --force-recreate -d 运行 docker-compose up -d 查看日志，发现 ========= agent working ========= 则插件正常运行 ","date":"2021-07-25","objectID":"/docker%E9%83%A8%E7%BD%B2%E5%B9%B6%E7%A0%B4%E8%A7%A3confluence%E5%92%8Cjira%E5%8F%8A%E6%8F%92%E4%BB%B6/:1:2","tags":["开源软件"],"title":"Docker部署并破解Confluence和JIRA及插件","uri":"/docker%E9%83%A8%E7%BD%B2%E5%B9%B6%E7%A0%B4%E8%A7%A3confluence%E5%92%8Cjira%E5%8F%8A%E6%8F%92%E4%BB%B6/"},{"categories":["运维部署"],"content":"初始化配置 破解 破解\" 破解 复制 Server ID BT5W-KP7Q-31DT-PTNG，使用容器内的 Java 环境，进入存放 atlassian-agent.jar 目录，运行下方命令生成 Key java -jar atlassian-agent.jar -d -m test@test.com -n BAT -p 'conf' -o http://localhost:8090 -s BT5W-KP7Q-31DT-PTNG 设置数据库 这里使用的宿主机搭建的 Mysql 8.0，一路下一步即可 配置数据库\" 配置数据库 查看授权细节 授权细节\" 授权细节 ","date":"2021-07-25","objectID":"/docker%E9%83%A8%E7%BD%B2%E5%B9%B6%E7%A0%B4%E8%A7%A3confluence%E5%92%8Cjira%E5%8F%8A%E6%8F%92%E4%BB%B6/:1:3","tags":["开源软件"],"title":"Docker部署并破解Confluence和JIRA及插件","uri":"/docker%E9%83%A8%E7%BD%B2%E5%B9%B6%E7%A0%B4%E8%A7%A3confluence%E5%92%8Cjira%E5%8F%8A%E6%8F%92%E4%BB%B6/"},{"categories":["运维部署"],"content":"插件破解 第三方插件将其应用密钥 / 插件关键字作为 - p 参数。如：-p ‘com.valiantys.spreadsheets’ java -jar atlassian-agent.jar -d -m mytest@mytest.com -n BAT -p 'com.valiantys.spreadsheets' -o http://localhost:8090 -s BDMK-KXF1-H7GV-F7QG 查找新应用，选择你想要的应用插件，点击免费使用，点击接受 \u0026 安装，进入管理应用页面，粘贴生成的许可证，点击更新完成破解 插件破解\" 插件破解 ","date":"2021-07-25","objectID":"/docker%E9%83%A8%E7%BD%B2%E5%B9%B6%E7%A0%B4%E8%A7%A3confluence%E5%92%8Cjira%E5%8F%8A%E6%8F%92%E4%BB%B6/:1:4","tags":["开源软件"],"title":"Docker部署并破解Confluence和JIRA及插件","uri":"/docker%E9%83%A8%E7%BD%B2%E5%B9%B6%E7%A0%B4%E8%A7%A3confluence%E5%92%8Cjira%E5%8F%8A%E6%8F%92%E4%BB%B6/"},{"categories":["运维部署"],"content":"JIRA JIRA 是 Atlassian 公司出品的项目与事务跟踪工具，被广泛应用于缺陷跟踪、客户服务、需求收集、流程审批、任务跟踪、项目跟踪和敏捷管理等工作领域。 Jira 搭建流程和 Confluence 类似，这里不再赘述，附上相关内容 ","date":"2021-07-25","objectID":"/docker%E9%83%A8%E7%BD%B2%E5%B9%B6%E7%A0%B4%E8%A7%A3confluence%E5%92%8Cjira%E5%8F%8A%E6%8F%92%E4%BB%B6/:2:0","tags":["开源软件"],"title":"Docker部署并破解Confluence和JIRA及插件","uri":"/docker%E9%83%A8%E7%BD%B2%E5%B9%B6%E7%A0%B4%E8%A7%A3confluence%E5%92%8Cjira%E5%8F%8A%E6%8F%92%E4%BB%B6/"},{"categories":["运维部署"],"content":"文档 Jira Software Data Center and Server documentation Connecting Jira applications to a database 镜像：atlassian/jira-software ","date":"2021-07-25","objectID":"/docker%E9%83%A8%E7%BD%B2%E5%B9%B6%E7%A0%B4%E8%A7%A3confluence%E5%92%8Cjira%E5%8F%8A%E6%8F%92%E4%BB%B6/:2:1","tags":["开源软件"],"title":"Docker部署并破解Confluence和JIRA及插件","uri":"/docker%E9%83%A8%E7%BD%B2%E5%B9%B6%E7%A0%B4%E8%A7%A3confluence%E5%92%8Cjira%E5%8F%8A%E6%8F%92%E4%BB%B6/"},{"categories":["运维部署"],"content":"破解命令 java -jar atlassian-agent.jar -d -m test@test.com -n BAT -p 'jira' -o http://localhost:8080 -s BT5W-KP7Q-31DT-PTNG ","date":"2021-07-25","objectID":"/docker%E9%83%A8%E7%BD%B2%E5%B9%B6%E7%A0%B4%E8%A7%A3confluence%E5%92%8Cjira%E5%8F%8A%E6%8F%92%E4%BB%B6/:2:2","tags":["开源软件"],"title":"Docker部署并破解Confluence和JIRA及插件","uri":"/docker%E9%83%A8%E7%BD%B2%E5%B9%B6%E7%A0%B4%E8%A7%A3confluence%E5%92%8Cjira%E5%8F%8A%E6%8F%92%E4%BB%B6/"},{"categories":["运维部署"],"content":"配置 Confluence 与 Jira 用户数据对接 进入 Jira 选择用户管理 \u003e Jira 用户服务器 \u003e 添加应用程序 添加应用程序\" 添加应用程序 进入 Confluence \u003e 用户管理 \u003e 用户目录 \u003e 添加目录（目录类型为：Atlassian Jira） 配置jira server\" 配置jira server 将 JIRA Server 顺序顶置最上，点击同步即可将 Jira 用户信息同步到 Confluence 添加目录\" 添加目录 如果是通过备份还原的 Jira 及 Confluence 可以直接禁用之前的用户目录然后移除。其他应用程序关联等设置比较简单，自行操作。 ","date":"2021-07-25","objectID":"/docker%E9%83%A8%E7%BD%B2%E5%B9%B6%E7%A0%B4%E8%A7%A3confluence%E5%92%8Cjira%E5%8F%8A%E6%8F%92%E4%BB%B6/:2:3","tags":["开源软件"],"title":"Docker部署并破解Confluence和JIRA及插件","uri":"/docker%E9%83%A8%E7%BD%B2%E5%B9%B6%E7%A0%B4%E8%A7%A3confluence%E5%92%8Cjira%E5%8F%8A%E6%8F%92%E4%BB%B6/"},{"categories":["运维部署"],"content":"异常记录 ","date":"2021-07-25","objectID":"/docker%E9%83%A8%E7%BD%B2%E5%B9%B6%E7%A0%B4%E8%A7%A3confluence%E5%92%8Cjira%E5%8F%8A%E6%8F%92%E4%BB%B6/:3:0","tags":["开源软件"],"title":"Docker部署并破解Confluence和JIRA及插件","uri":"/docker%E9%83%A8%E7%BD%B2%E5%B9%B6%E7%A0%B4%E8%A7%A3confluence%E5%92%8Cjira%E5%8F%8A%E6%8F%92%E4%BB%B6/"},{"categories":["运维部署"],"content":"Confluence 重启后一段时间内无响应 confluence_1 | WARNING: An illegal reflective access operation has occurred confluence_1 | WARNING: Illegal reflective access by com.atlassian.hibernate.adapter.proxy.BytecodeProviderImpl_ImplementV2Proxy (file:/opt/atlassian/confluence/confluence/WEB-INF/lib/hibernate.adapter-1.0.3.jar) to field java.lang.reflect.Field.modifiers confluence_1 | WARNING: Please consider reporting this to the maintainers of com.atlassian.hibernate.adapter.proxy.BytecodeProviderImpl_ImplementV2Proxy confluence_1 | WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations confluence_1 | WARNING: All illegal access operations will be denied in a future release confluence_1 | Security framework of XStream not explicitly initialized, using predefined black list on your own risk. 类似问题： https://community.atlassian.com/t5/Confluence-questions/Confluence-no-longer-responds-Debugging-articles/qaq-p/1404597 https://community.atlassian.com/t5/Confluence-questions/Illegal-reflective-access-by-BytecodeProviderImpl/qaq-p/1255035 https://community.atlassian.com/t5/Confluence-questions/hibernate-adapter-1-0-3-jar/qaq-p/1281057 不过等待一段时间会自动运行正常。。。 ","date":"2021-07-25","objectID":"/docker%E9%83%A8%E7%BD%B2%E5%B9%B6%E7%A0%B4%E8%A7%A3confluence%E5%92%8Cjira%E5%8F%8A%E6%8F%92%E4%BB%B6/:3:1","tags":["开源软件"],"title":"Docker部署并破解Confluence和JIRA及插件","uri":"/docker%E9%83%A8%E7%BD%B2%E5%B9%B6%E7%A0%B4%E8%A7%A3confluence%E5%92%8Cjira%E5%8F%8A%E6%8F%92%E4%BB%B6/"},{"categories":["运维部署"],"content":"备份文件恢复失败 Unable to complete import: An invalid XML character (Unicode: 0x8) was found in the CDATA section. 解压备份文件，下方文档链接中的中的Jar包处理一下 entities.xml 文件，重新打包 https://confluence.atlassian.com/jira/removing-invalid-characters-from-xml-backups-12079.html ","date":"2021-07-25","objectID":"/docker%E9%83%A8%E7%BD%B2%E5%B9%B6%E7%A0%B4%E8%A7%A3confluence%E5%92%8Cjira%E5%8F%8A%E6%8F%92%E4%BB%B6/:3:2","tags":["开源软件"],"title":"Docker部署并破解Confluence和JIRA及插件","uri":"/docker%E9%83%A8%E7%BD%B2%E5%B9%B6%E7%A0%B4%E8%A7%A3confluence%E5%92%8Cjira%E5%8F%8A%E6%8F%92%E4%BB%B6/"},{"categories":["编程语言"],"content":"以下代码有几点说明： Cat 和 Dog 都实现了 Animal 接口的 SetName 方法 Cat 实现的接口为值接收者（value receiver） Dog 实现的接口为指针接收者（pointer receiver） package main import ( \"fmt\" ) type Animal interface { SetName() } type Cat struct { Name string } func (c Cat) SetName() { c.Name = \"喵星人\" } type Dog struct { Name string } func (d *Dog) SetName() { d.Name = \"汪星人\" } func main() { var a1 Animal = Cat{} a1.SetName() fmt.Println(\"cat name:\", a1.(Cat).Name) var a2 Animal = \u0026Cat{} a2.SetName() fmt.Println(\"cat name:\", a2.(Cat).Name) var a3 Animal = \u0026Dog{} a1.SetName() fmt.Println(\"dog name:\", a3.(*Dog).Name) // cannot use Dog{} (value of type Dog) as type Animal in variable declaration: // Dog does not implement Animal (SetName method has pointer receiver) var a4 Animal = Dog{} a1.SetName() fmt.Println(\"dog name:\", a4.(*Dog).Name) var a5 Dog = Dog{} a5.SetName() fmt.Println(\"dog name:\", a5.Name) var a6 *Dog = \u0026Dog{} a6.SetName() fmt.Println(\"dog name:\", a6.Name) } 运行这段代码可以发现两点问题： a5、a6 赋值 Dog 结构体的值和指针都可以顺利运行 a1、a2、a3、a4 都是 Animal 接口类型，为什么 a4 为 Dog 结构体值的时候编译报错，a1 为 Cat 结构体值却不会 首先，在 golang 中，所有的参数传递都是值传递，并且有等价写法如下： func (c Cat) SetName() { c.Name = \"喵星人\" } 等价于 func SetName(c Cat) { c.Name = \"喵星人\" } 故 value receiver 和 pointer receiver 区别为： value receiver：方法拿到的是结构体的拷贝 pointer receiver：方法拿到的是结构体指针的拷贝，和原结构体指针指向的是同一个结构体（这也是为什么在方法内访问或者修改结构体需要定义为 pointer receiver） 在 go 语言官方文档：pointers vs values 有一段这样的描述： When the value is addressable, the language takes care of the common case of invoking a pointer method on a value by inserting the address operator automatically. In our example, the variable b is addressable, so we can call its Write method with just b.Write. The compiler will rewrite that to (\u0026b).Write for us. 当值是可寻址的时，go 会通过自动插入 address 操作符来处理对值调用指针方法的常见情况。在我们的例子中，变量 b 是可寻址的，所以我们可以用 b.Write 调用它的 Write 方法。编译器将把它重写为（\u0026b） 故以上代码可以理解为：Dog 定义的 SetName 接口方法为 pointer receiver，但是 var a5 Dog = Dog{} 中的 a5 虽然是 value（可寻址的），我们可以通过 \u0026a5 隐式获取 a5 结构体的地址，从而实现 pointer receiver 的调用。这就是为什么 a5、a6 都能调用 SetName 并且编译不会报错 那为什么类型为接口类型 Animal 的 a4 就不好使了呢？直接无法编译？ 可以根据以上原因推断：接口类型 Animal 的 a4 是不可寻址的，not addressable 的，编译器编译阶段就禁止获取接口类型的地址 还是在 go 语言官方文档：Interfaces 有一段这样的描述的描述，也可以看看文档中的举例： The concrete value stored in an interface is not addressable, in the same way that a map element is not addressable. Therefore, when you call a method on an interface, it must either have an identical receiver type or it must be directly discernible from the concrete type: pointer- and value-receiver methods can be called with pointers and values respectively, as you would expect. Value-receiver methods can be called with pointer values because they can be dereferenced first. Pointer-receiver methods cannot be called with values, however, because the value stored inside an interface has no address. When assigning a value to an interface, the compiler ensures that all possible interface methods can actually be called on that value, and thus trying to make an improper assignment will fail on compilation. 接口类型和 map 一样是无法寻址的，接口类型是一种抽象，实现接口类型的结构体可能会有很多。（感觉还是跟语言设计有关，Python 这样的脚本语言就是在运行过程中才知道对象有哪些方法，哪些属性） Value-receiver methods can be called with pointer values because they can be dereferenced first. Pointer-receiver methods cannot be called with values, however, because the value stored inside an interface has no address. Cat 实现的 SetName 为 Value receiver，所以调用者为 value 或者是 pointer 都是 ok 的（pointer 会先取值，dereferenced）； Dog 实现的 SetName 为 pointer receiver，当调用者为 value 时，由于调用者的类型为 Animal 接口类型（不可寻址的），所以无法通过 value 获取到 pointer，所以编译期就失败。 小小总结一下，对于接口类型变量调用实现的方法注意下面的情况： value 调用 pointer 调用 value receiver 方法 编译✅ 编译✅（dereferenced） pointer receiver 方法 编译❌ （not addressable） 编译✅ 最后关于「变量自动取地址」和「指针自动解引用」也算是 golang 提供的为数不多的语法糖吧，不研究一下确实不明白～ ","date":"2021-07-25","objectID":"/go%E4%B8%AD%E7%9A%84interfaces%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%80%BC%E6%8C%87%E9%92%88%E6%8E%A5%E6%94%B6%E8%80%85/:0:0","tags":["Golang"],"title":"Go中的Interfaces类型与值、指针接收者","uri":"/go%E4%B8%AD%E7%9A%84interfaces%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%80%BC%E6%8C%87%E9%92%88%E6%8E%A5%E6%94%B6%E8%80%85/"},{"categories":["操作系统"],"content":"安装 iTerm2 使用 iTerm2 替代 macOS 自带终端 Terminal Home\u0026Download：https://iterm2.com/ ","date":"2021-06-04","objectID":"/macos%E7%BB%88%E7%AB%AF%E9%85%8D%E7%BD%AE%E8%AE%B0%E5%BD%95/:1:0","tags":["macOS"],"title":"MacOS 终端配置记录","uri":"/macos%E7%BB%88%E7%AB%AF%E9%85%8D%E7%BD%AE%E8%AE%B0%E5%BD%95/"},{"categories":["操作系统"],"content":"安装 iTerm2 主题 This is a set of color schemes for iTerm (aka iTerm2). Github：https://github.com/mbadolato/iTerm2-Color-Schemes Example: Dracula iterm2-material-design ","date":"2021-06-04","objectID":"/macos%E7%BB%88%E7%AB%AF%E9%85%8D%E7%BD%AE%E8%AE%B0%E5%BD%95/:2:0","tags":["macOS"],"title":"MacOS 终端配置记录","uri":"/macos%E7%BB%88%E7%AB%AF%E9%85%8D%E7%BD%AE%E8%AE%B0%E5%BD%95/"},{"categories":["操作系统"],"content":"安装 oh-my-zsh Oh My Zsh is a delightful, open source, community-driven framework for managing your Zsh configuration. Home：https://ohmyz.sh/ Github：https://github.com/ohmyzsh/ohmyzsh # Install oh-my-zsh $ sh -c \"$(curl -fsSL https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh)\" ","date":"2021-06-04","objectID":"/macos%E7%BB%88%E7%AB%AF%E9%85%8D%E7%BD%AE%E8%AE%B0%E5%BD%95/:3:0","tags":["macOS"],"title":"MacOS 终端配置记录","uri":"/macos%E7%BB%88%E7%AB%AF%E9%85%8D%E7%BD%AE%E8%AE%B0%E5%BD%95/"},{"categories":["操作系统"],"content":"安装 zplug 插件管理器 Github：https://github.com/zplug/zplug $ curl -sL --proto-redir -all,https https://raw.githubusercontent.com/zplug/installer/master/installer.zsh | zsh ","date":"2021-06-04","objectID":"/macos%E7%BB%88%E7%AB%AF%E9%85%8D%E7%BD%AE%E8%AE%B0%E5%BD%95/:4:0","tags":["macOS"],"title":"MacOS 终端配置记录","uri":"/macos%E7%BB%88%E7%AB%AF%E9%85%8D%E7%BD%AE%E8%AE%B0%E5%BD%95/"},{"categories":["操作系统"],"content":"安装命令行工具 ","date":"2021-06-04","objectID":"/macos%E7%BB%88%E7%AB%AF%E9%85%8D%E7%BD%AE%E8%AE%B0%E5%BD%95/:5:0","tags":["macOS"],"title":"MacOS 终端配置记录","uri":"/macos%E7%BB%88%E7%AB%AF%E9%85%8D%E7%BD%AE%E8%AE%B0%E5%BD%95/"},{"categories":["操作系统"],"content":"fzf 命令行模糊搜索 Github：https://github.com/junegunn/fzf brew install fzf # To install useful key bindings and fuzzy completion: $(brew --prefix)/opt/fzf/install NOTE：put this line in the end of your zshrc, or it may not work, https://github.com/junegunn/fzf/issues/1304 [ -f ~/.fzf.zsh ] \u0026\u0026 source ~/.fzf.zsh ","date":"2021-06-04","objectID":"/macos%E7%BB%88%E7%AB%AF%E9%85%8D%E7%BD%AE%E8%AE%B0%E5%BD%95/:5:1","tags":["macOS"],"title":"MacOS 终端配置记录","uri":"/macos%E7%BB%88%E7%AB%AF%E9%85%8D%E7%BD%AE%E8%AE%B0%E5%BD%95/"},{"categories":["操作系统"],"content":"新增 zpug 插件配置 添加到 ~/.zshrc 文件 # install zplug, plugin manager for zsh, https://github.com/zplug/zplug # curl -sL --proto-redir -all,https https://raw.githubusercontent.com/zplug/installer/master/installer.zsh | zsh # zplug configruation if [[ ! -d \"${ZPLUG_HOME}\" ]]; then if [[ ! -d ~/.zplug ]]; then git clone https://github.com/zplug/zplug ~/.zplug # If we can't get zplug, it'll be a very sobering shell experience. To at # least complete the sourcing of this file, we'll define an always-false # returning zplug function. if [[ $? != 0 ]]; then function zplug() { return 1 } fi fi export ZPLUG_HOME=~/.zplug fi if [[ -d \"${ZPLUG_HOME}\" ]]; then source \"${ZPLUG_HOME}/init.zsh\" fi zplug 'plugins/git', from:oh-my-zsh, if:'which git' zplug 'romkatv/powerlevel10k', use:powerlevel10k.zsh-theme zplug \"plugins/vi-mode\", from:oh-my-zsh zplug 'zsh-users/zsh-autosuggestions' zplug 'zsh-users/zsh-completions', defer:2 zplug 'zsh-users/zsh-history-substring-search' zplug 'zsh-users/zsh-syntax-highlighting', defer:2 if ! zplug check; then zplug install fi zplug load ","date":"2021-06-04","objectID":"/macos%E7%BB%88%E7%AB%AF%E9%85%8D%E7%BD%AE%E8%AE%B0%E5%BD%95/:6:0","tags":["macOS"],"title":"MacOS 终端配置记录","uri":"/macos%E7%BB%88%E7%AB%AF%E9%85%8D%E7%BD%AE%E8%AE%B0%E5%BD%95/"},{"categories":["操作系统"],"content":"关于字体 在配置 powerlevel10k 主题时若缺少字体会提示下载，当然你也可以自行安装 Best option if on macOS and want to use Homebrew. All fonts are available via Homebrew Cask Fonts on macOS (OS X) brew tap homebrew/cask-fonts brew install --cask font-hack-nerd-font iTerm2 -\u003e Preferences -\u003e Profiles -\u003e Text -\u003e Non-Ascii-Font -\u003e nerd-font -\u003e restart iTerm2 ","date":"2021-06-04","objectID":"/macos%E7%BB%88%E7%AB%AF%E9%85%8D%E7%BD%AE%E8%AE%B0%E5%BD%95/:7:0","tags":["macOS"],"title":"MacOS 终端配置记录","uri":"/macos%E7%BB%88%E7%AB%AF%E9%85%8D%E7%BD%AE%E8%AE%B0%E5%BD%95/"},{"categories":["协议"],"content":"说到支持 HTTPS 协议，第一时间想到的是配置各种复杂的证书。实际上大多数代理服务器能够支持 HTTPS 都是通过 HTTP 协议中的 Web 隧道（也有叫做 HTTP 隧道）功能来实现的。 ","date":"2021-05-10","objectID":"/%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%A6%82%E4%BD%95%E6%94%AF%E6%8C%81https/:0:0","tags":["https"],"title":"代理服务器如何支持 HTTPS","uri":"/%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%A6%82%E4%BD%95%E6%94%AF%E6%8C%81https/"},{"categories":["协议"],"content":"Web 隧道 Web 隧道允许用户通过 HTTP 连接发送非 HTTP 流量（例如 FTP，Telnet，SMTP），这样就可以在 HTTP 上携带其他协议数据了。使用 Web 隧道最常见的原因就是要在 HTTP 链接中嵌入非 HTTP 流量。我们知道很多软件都是实现了自己的应用层协议，但是这些软件都支持设置代理，如 QQ，微信。 Web 隧道是用 HTTP 的 CONNECT 方法建立起来的。CONNECT 方法并不是 HTTP/1.1 核心规范的一部分，但却是一种得到广泛应用的扩展。CONNECT 方法请求隧道网关创建一条到达任意目的服务器和端口的 TCP 连接，并对客户端和服务器之间的后继数据进行盲转发。下面截取《HTTP 权威指南》配图，讲讲 CONNECT 方法如何建立一条 Web 隧道。 Connect 连接\" Connect 连接 客户端首先发送了一条 CONNECT 请求给代理服务器。 代理服务器收到了 CONNECT 请求，解析出报文中客户端希望访问的域名及端口号，然后向目标服务器进行 TCP 连接。（图中是到打开到主机 orders.joes-hardware.com 的标准 SSL 端口 443 的连接） 代理服务器一旦和目标网站建立了 TCP 连接，就发送一条 HTTP 200 Connection Established 的响应来通知客户端 Web 隧道建立成功，可以发送数据了。 此时客户端通过 Web 隧道发送的所有数据都会被代理服务器直接转发给目标网站。（如果是 HTTPS 协议则是各种 SSL 握手信息，加密后的 HTTP 报文） 客户端只有收到 200 Connection Established 才会继续发送数据。如果代理服务器和目标网站连接不成功怎么办呢？代理服务器可以自己灵活自定义：连接目标网站失败 502 Bad Gateway、代理认证未通过 407 Proxy Authentication Required 等等。 ","date":"2021-05-10","objectID":"/%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%A6%82%E4%BD%95%E6%94%AF%E6%8C%81https/:1:0","tags":["https"],"title":"代理服务器如何支持 HTTPS","uri":"/%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%A6%82%E4%BD%95%E6%94%AF%E6%8C%81https/"},{"categories":["协议"],"content":"CONNECT 请求 除了起始行之外，CONNECT 的语法与其他 HTTP 方法类似，只不过是主机名和端口号取代了 URI。其中主机和端口都必须指定，不然代理服务器就不清楚与谁建立连接了。 CONNECT home.netscape.com:443 HTTP/1.0 User-Agent: Mozilla/4.0 CONNECT 请求的 header 通常只会携带建立 Web 隧道所需要的信息，而不包含需要传输的请求信息。 常见的 CONNECT 请求 header： User-Agent：用户设备 Proxy-Authorization：认证信息 Proxy-Connection：是否支持长连接 Connect 请求抓包\" Connect 请求抓包 ","date":"2021-05-10","objectID":"/%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%A6%82%E4%BD%95%E6%94%AF%E6%8C%81https/:1:1","tags":["https"],"title":"代理服务器如何支持 HTTPS","uri":"/%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%A6%82%E4%BD%95%E6%94%AF%E6%8C%81https/"},{"categories":["协议"],"content":"CONNECT 响应 发送了请求之后，客户端会等待来自网关的响应。和普通 HTTP 报文一样，响应码 200 表示成功。按照惯例，响应中的原因短语通常被设置为 “Connection Established”。 HTTP/1.0 200 Connection Established Proxy-Agent: Netscape-Proxy/1.1 与普通 HTTP 响应不同，这个响应并不需要包含 Content-Type 首部。此时连接只是对原始字节进行转接，不再是报文的承载者，所以不需要使用内容类型了。 Connect 响应抓包\" Connect 响应抓包 ","date":"2021-05-10","objectID":"/%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%A6%82%E4%BD%95%E6%94%AF%E6%8C%81https/:1:2","tags":["https"],"title":"代理服务器如何支持 HTTPS","uri":"/%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%A6%82%E4%BD%95%E6%94%AF%E6%8C%81https/"},{"categories":["协议"],"content":"WebSocket 正因为有了 Web 隧道，代理服务器不需要其他应用层协议进行额外的编码解析，只要 Web 隧道建立成功之后即可发送任何非 HTTP 流量， 如 websocket 协议。 在 Python 的 websocket-client 框架中，如果使用 HTTP 代理，首先会对代理发送 CONNECT 连接建立 Web 隧道，然后在传输 ws、wss 协议数据 def _tunnel(sock, host, port, auth): debug(\"Connecting proxy...\") connect_header = \"CONNECT %s:%dHTTP/1.1\\r\\n\" % (host, port) connect_header += \"Host: %s:%d\\r\\n\" % (host, port) # TODO: support digest auth. if auth and auth[0]: auth_str = auth[0] if auth[1]: auth_str += \":\" + auth[1] encoded_str = base64encode(auth_str.encode()).strip().decode().replace('\\n', '') connect_header += \"Proxy-Authorization: Basic %s\\r\\n\" % encoded_str connect_header += \"\\r\\n\" dump(\"request header\", connect_header) send(sock, connect_header) try: status, resp_headers, status_message = read_headers(sock) except Exception as e: raise WebSocketProxyException(str(e)) if status != 200: raise WebSocketProxyException( \"failed CONNECT via proxy status: %r\" % status) return sock ","date":"2021-05-10","objectID":"/%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%A6%82%E4%BD%95%E6%94%AF%E6%8C%81https/:2:0","tags":["https"],"title":"代理服务器如何支持 HTTPS","uri":"/%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%A6%82%E4%BD%95%E6%94%AF%E6%8C%81https/"},{"categories":["协议"],"content":"非 Web 隧道 当然，也有的代理服务器能够在不建立 Web 隧道的情况下，实现了对其他应用层协议的解析，从而实现代理转发的目的。 例如 HTTPS 协议，客户端首先和代理服务器进行代理服务器完成 SSL 握手，代理服务器获取到客户端发送的完整请求（明文），然后在和目标主机进行 SSL 握手，成功后转发用户的请求。最后还要确定使用的 HTTP 客户端是否支持连接 HTTPS 代理，因为绝大多数应用层协议客户端都是通过 Web 隧道使用代理。 在 Python 的 HTTP 客户端框架 urllib3 的 1.26.0 版本 中才添加了对 HTPPS 代理连接的支持。 Added support for HTTPS proxies contacting HTTPS servers (Pull #1923 , Pull #1806 ) proxies = { 'http': 'http://proxy_ip:port', # http 请求 'https': 'http://proxy_ip:port', # CONNECT 请求 'https': 'https://proxy_ip:port' # 与 proxy 进行 ssl } ","date":"2021-05-10","objectID":"/%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%A6%82%E4%BD%95%E6%94%AF%E6%8C%81https/:3:0","tags":["https"],"title":"代理服务器如何支持 HTTPS","uri":"/%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%A6%82%E4%BD%95%E6%94%AF%E6%8C%81https/"},{"categories":["学习记录"],"content":"墙的原理 在讨论 vpn、proxy 这些之前，有必要先提一下目前主流防火墙的实现原理。GFW 实现网络封锁的手段主要有两种：dns 劫持和 ip 封锁（除此之外，还有 dns 污染和关键词过滤，这里我们不讨论）。 ","date":"2021-03-20","objectID":"/%E6%B5%85%E8%B0%88vpnproxyshadowsocks%E6%9C%BA%E5%9C%BA%E4%B9%8B%E9%97%B4%E7%9A%84%E8%81%94%E7%B3%BB%E5%92%8C%E5%8C%BA%E5%88%AB/:1:0","tags":["科学上网"],"title":"浅谈 vpn、proxy、shadowsocks、机场之间的联系和区别","uri":"/%E6%B5%85%E8%B0%88vpnproxyshadowsocks%E6%9C%BA%E5%9C%BA%E4%B9%8B%E9%97%B4%E7%9A%84%E8%81%94%E7%B3%BB%E5%92%8C%E5%8C%BA%E5%88%AB/"},{"categories":["学习记录"],"content":"Dns 劫持 ip 是网络上各主机的 “地址”，要想访问 “别人家”，当然得要有地址。但 ip 是一串数字，是给电脑看的，人记起来太麻烦，所以就有了域名（也就是我们常说的网址）和 dns （网域名称系统，Domain Name System）。 域名是一串英文字符串，方便人记忆。dns 将域名和 ip 关联起来，形成映射。用户访问域名所在的目标网站前，将域名发给 dns 服务器询问这对映射关系，拿到对应的 ip 后就可以在茫茫网海中找到那个 “她” 了。而 GFW 所做的就是站在用户和 dns 服务器之间，破坏它们的正常通讯，并向用户回传一个假 ip。用户拿不到真正的 ip，自然也就访问不到本想访问的网站了。 Dns 劫持是 GFW 早期唯一的技术手段，所以那个时候的用户通过修改 Hosts 文件的方式就可以零成本突破封锁了。 ","date":"2021-03-20","objectID":"/%E6%B5%85%E8%B0%88vpnproxyshadowsocks%E6%9C%BA%E5%9C%BA%E4%B9%8B%E9%97%B4%E7%9A%84%E8%81%94%E7%B3%BB%E5%92%8C%E5%8C%BA%E5%88%AB/:1:1","tags":["科学上网"],"title":"浅谈 vpn、proxy、shadowsocks、机场之间的联系和区别","uri":"/%E6%B5%85%E8%B0%88vpnproxyshadowsocks%E6%9C%BA%E5%9C%BA%E4%B9%8B%E9%97%B4%E7%9A%84%E8%81%94%E7%B3%BB%E5%92%8C%E5%8C%BA%E5%88%AB/"},{"categories":["学习记录"],"content":"IP 封锁 dns 劫持之后，GFW 引入了 ip 封锁，直接锁住了访问目标网站的去路，用户发往被封锁 ip 的任何数据都会被墙截断。 这个时候，依靠类似于修改 Hosts 文件这种低成本方法突破封锁就显得有些天方夜谭了。那么，解决办法是什么呢？答案是：在第三方架设翻墙服务器，中转与目标服务器间的来往流量。目前为止，GFW 采用的是黑名单模式，像 Google、Facebook 这种在黑名单上的网站的 ip 无法访问，而不在黑名单上的第三方不记名 ip 可以。 于是，一切就很明朗了，我们目前几乎所有的翻墙手段都是基于上述原理实现的。vpn 是，shadowsocks 是，还有一些比较冷门的（比如 v2ray）同样如此，只不过它们的技术细节不同（这个我们不会深入）。 ","date":"2021-03-20","objectID":"/%E6%B5%85%E8%B0%88vpnproxyshadowsocks%E6%9C%BA%E5%9C%BA%E4%B9%8B%E9%97%B4%E7%9A%84%E8%81%94%E7%B3%BB%E5%92%8C%E5%8C%BA%E5%88%AB/:1:2","tags":["科学上网"],"title":"浅谈 vpn、proxy、shadowsocks、机场之间的联系和区别","uri":"/%E6%B5%85%E8%B0%88vpnproxyshadowsocks%E6%9C%BA%E5%9C%BA%E4%B9%8B%E9%97%B4%E7%9A%84%E8%81%94%E7%B3%BB%E5%92%8C%E5%8C%BA%E5%88%AB/"},{"categories":["学习记录"],"content":"VPN VPN ，全称 “虚拟私人网络（Virtual Private Network）” 或者是“虚拟专用网络”，是一种加密通讯技术。vpn 是一个统称，它有很多的具体实现，比如 PPTP、L2TP/IPSec 等。 vpn 最常用的场景就是在外网的小伙伴（如酒店网络，家庭 WIFI 等等）访问公司内部的网络使用，如果不使用 vpn，直接连入公司内网，则数据明文在外网中传输会有被窃听的风险。vpn 是一种加密通讯技术，它被设计出来的目的是数据传输安全和网络匿名。 vpn 出现远早于 GFW，所以它不是为了翻墙而生的。而既然不是为翻墙而生，那从翻墙的角度上讲，vpn 协议就存在诸多问题。使用 VPN，不足之处在于数据分流不灵活，会将开启了 VPN 的设备的所有数据流量全部导向至 VPN 服务器上；另外如果 VPN 服务器上有流量监视软件运行，那么用户所传输的数据将有信息安全威胁；进一步来说，由于 VPN 设计的初衷并不是用于翻墙，因此数据流量的特征非常明显，容易引起审查机构注意，导致被封。 所以，VPN 这种翻墙方式基本已经没落了。但即便如此，vpn 作为过去很长一段时间最主流最热门最常用最为人所知的翻墙手段，已然成为翻墙的代名词。即便是 vpn 已不再常用的今天，当人们谈及翻墙的时候，说得最多的仍是：“你有什么好用的 vpn 吗？”。 ","date":"2021-03-20","objectID":"/%E6%B5%85%E8%B0%88vpnproxyshadowsocks%E6%9C%BA%E5%9C%BA%E4%B9%8B%E9%97%B4%E7%9A%84%E8%81%94%E7%B3%BB%E5%92%8C%E5%8C%BA%E5%88%AB/:2:0","tags":["科学上网"],"title":"浅谈 vpn、proxy、shadowsocks、机场之间的联系和区别","uri":"/%E6%B5%85%E8%B0%88vpnproxyshadowsocks%E6%9C%BA%E5%9C%BA%E4%B9%8B%E9%97%B4%E7%9A%84%E8%81%94%E7%B3%BB%E5%92%8C%E5%8C%BA%E5%88%AB/"},{"categories":["学习记录"],"content":"Proxy（代理） Proxy（代理）又分为正向代理和反向代理。 ","date":"2021-03-20","objectID":"/%E6%B5%85%E8%B0%88vpnproxyshadowsocks%E6%9C%BA%E5%9C%BA%E4%B9%8B%E9%97%B4%E7%9A%84%E8%81%94%E7%B3%BB%E5%92%8C%E5%8C%BA%E5%88%AB/:3:0","tags":["科学上网"],"title":"浅谈 vpn、proxy、shadowsocks、机场之间的联系和区别","uri":"/%E6%B5%85%E8%B0%88vpnproxyshadowsocks%E6%9C%BA%E5%9C%BA%E4%B9%8B%E9%97%B4%E7%9A%84%E8%81%94%E7%B3%BB%E5%92%8C%E5%8C%BA%E5%88%AB/"},{"categories":["学习记录"],"content":"正向代理 翻墙所用的代理都是正向代理。正向代理主要有 HTTP、HTTP over TLS(HTTPS)、Socks、Socks over TLS 几种。其中，HTTP 和 Socks 无法用于翻墙，HTTPS 和 Socks over TLS 可以用于翻墙。不过，Socks over TLS 几乎没人用，我们这里就不多说了。 Proxy 的历史同样早于 GFW，它最早被设计出来的目的当然也不是翻墙。正向代理最主要的目的和 vpn 差不多，都是用于匿名，但 HTTP 和 Socks 不能加密，只能匿名，HTTPS 既可以匿名，也可以用于加密通信。 从理论上讲，四种代理协议都可以通过 “用户先将数据发给代理服务器，再由代理服务器转发给目的服务器” 的方法达到翻墙目的。但由于 HTTP 和 Socks 都是明文协议，GFW 可以通过检查数据包内的内容得知用户的真实意图，进而拦截数据包。所以，HTTP 和 Socks 一般只用作本地代理。而 HTTPS 协议是加密通讯，GFW 无法得知数据包内的真实内容，类似于关键词过滤的手段无法施展。不仅如此，HTTPS 代理的流量特征和我们平时访问网站时所产生的 HTTPS 流量几乎一模一样，GFW 无法分辨，稳定性爆表。理论上讲，HTTPS 代理无论是安全性，还是在隐匿性，都要比目前最为流行的 shadowsocks 好。 事实上，在所有已知的翻墙协议中，无论是 vpn 协议，还是代理协议，它应该都是最好的。v2ray 的 vmess over tls 也许能和 HTTPS 代理媲美。但 v2ray 存在的时间较短、使用者较少、社区也没有 HTTPS 代理活跃（从全球范围上看），故而，相比于 HTTPS 代理，vmess 协议潜在的安全漏洞可能要多。 当然，HTTPS 代理也有它的缺点，其中最大的缺点就是配置复杂。即便能用默认参数就用默认参数，用户自己只作最低限度的配置，对新手而言，这也是一个无比痛苦的过程。更别说，想要正常使用 HTTPS 代理，你还要购买域名和证书这些，非常麻烦。所以，即便是在 shadowsocks 出现之前，HTTPS 代理也没在大陆流行起来。这也是造成 v2ray 的小众的主要原因之一（另一个是用户没有从 shadowsocks 迁移到 v2ray 的动力），它的配置同样相当复杂。除此之外，HTTPS 代理只能转发 tcp 流量，对 udp 无能为力。 这里推荐刘亚晨先生的一篇文章「各种加密代理协议的简单对比 」。 ","date":"2021-03-20","objectID":"/%E6%B5%85%E8%B0%88vpnproxyshadowsocks%E6%9C%BA%E5%9C%BA%E4%B9%8B%E9%97%B4%E7%9A%84%E8%81%94%E7%B3%BB%E5%92%8C%E5%8C%BA%E5%88%AB/:4:0","tags":["科学上网"],"title":"浅谈 vpn、proxy、shadowsocks、机场之间的联系和区别","uri":"/%E6%B5%85%E8%B0%88vpnproxyshadowsocks%E6%9C%BA%E5%9C%BA%E4%B9%8B%E9%97%B4%E7%9A%84%E8%81%94%E7%B3%BB%E5%92%8C%E5%8C%BA%E5%88%AB/"},{"categories":["学习记录"],"content":"反向代理 反向代理的作用主要是为服务器做缓存和负载均衡。这里不做过多讨论，感兴趣的朋友可以看 这里 。顺带一提，shadowsocks 里也有负载均衡的概念，但 shadowsocks 的负载均衡和反向代理的负载均衡不是一个概念。 反向代理的负载均衡是指：在多个真正的服务器前架设一个代理服务器，用户所有的数据都发给代理服务器，然后代理服务器根据各个真实服务器的状态将数据转发给一个任务较少的服务器处理。这样，服务商既可以架设多个服务器分担任务、减轻压力，用户也只要记一个域名或 ip 就可以了。 而 shadowsocks 的负载均衡是指：每隔一段时间更改一次翻墙服务器，将用户的数据平均发给多个不同的翻墙服务器，以避免发往某一个翻墙服务器的流量过多。 ","date":"2021-03-20","objectID":"/%E6%B5%85%E8%B0%88vpnproxyshadowsocks%E6%9C%BA%E5%9C%BA%E4%B9%8B%E9%97%B4%E7%9A%84%E8%81%94%E7%B3%BB%E5%92%8C%E5%8C%BA%E5%88%AB/:5:0","tags":["科学上网"],"title":"浅谈 vpn、proxy、shadowsocks、机场之间的联系和区别","uri":"/%E6%B5%85%E8%B0%88vpnproxyshadowsocks%E6%9C%BA%E5%9C%BA%E4%B9%8B%E9%97%B4%E7%9A%84%E8%81%94%E7%B3%BB%E5%92%8C%E5%8C%BA%E5%88%AB/"},{"categories":["学习记录"],"content":"shadowsocks 最后，就是我们的 shadowsocks 闪亮登场了。介绍之前，我这里先附上 shadowsocks 的 官网链接 。英文比较好的同学建议看看官网上对 shadowsocks 的介绍。 在 shadowsocks 之前，墙内网民主要依靠寻找现成的技术实现翻墙。比如 vpn、HTTPS、tor 的中继网桥以及之后的 meek 插件等等，虽然也有自己的技术，比如一种依靠 Google 隐藏 ip 实现翻墙的技术（名字忘了）, 但毕竟难成大器，再加上 GFW 逐渐加大对 VPN 的干扰，人们迫切需要一种简单可靠的技术来抵御 GFW 的进攻。 于是，大概是在 2013 年吧（具体时间我也不太清楚），@clowwindy 带着他的 shadowsocks 横空出世。Shadowsocks 同样是一种代理协议，但是作为 clowwindy 为国人设计的专门用于翻墙的代理协议，相对于 vpn，shadowsocks 有着极强的隐匿性；相对于 HTTP 代理，shadowsocks 提供了较为完善的加密方案，虽然比不上 HTTPS 代理和 vpn，但使用的也是成熟的工业级的加密算法，普通个人用户完全不用顾虑；相对于 HTTPS 代理，shadowsocks 的安装配置更为简单，中文社区更为活跃，中文文档教程更完善，更符合中国国情。 Shdadowsocks 最初的版本是由 clowwindy 使用 Python（一种目前非常热门的脚本编程语言）实现的。所以 clowwindy 的版本被称为 Python 版。shadowsocks 有点名气之后，不同的开发者使用不同的编程语言为其写了很多分支版本。比如，@cyfdecyf 开发维护的 Go 版本，@madeye 开发维护的 libev 版本（由纯 C 语言编写，基于 libev 库开发），由 @librehat 开发维护的 c++ 版，由 @zhou0 开发维护的 Perl 版。这些版本的安装使用指南都可以在 shadowsocks 的官网上查阅。 2015 年，clowwindy 因喝茶事件被迫停止了 shadowsocks 的维护，并删除了其开源在 GitHub 上的代码，Python 版就此停滞。但其它版本仍处于维护更新中。其中，更新最频繁，新技术跟进最快的是由 @madeye 维护的 libev 版本。这里有必要说明下，目前，shadowsocks 协议（请区分 “shadowsocks 协议” 和“shadowsocks 协议的具体实现”这两者的区别）是由 shadowsocks 社区内的成员共同维护，协议上任何新改进都是社区成员共同商讨的结果。但对这些变化，不同的版本的 shadowsocks 跟进速度不同。而跟进速度最快的就是我上面说的 libev 版。无论是 SIP007 确认的 ADEA Ciphers（一种同时进行认证和加密的算法），还是 SIP003 引进的 simple-obfs（tor 开发的一种混淆插件），shadowsocks-libev 都是最早引入自己软件的。 shadowsocks 是 c/s 架构，shadowsocks 的客户端则就是百花齐放了，有我们现在用的小飞机（Shadowsocks），ClashX，移动端等等。 ","date":"2021-03-20","objectID":"/%E6%B5%85%E8%B0%88vpnproxyshadowsocks%E6%9C%BA%E5%9C%BA%E4%B9%8B%E9%97%B4%E7%9A%84%E8%81%94%E7%B3%BB%E5%92%8C%E5%8C%BA%E5%88%AB/:6:0","tags":["科学上网"],"title":"浅谈 vpn、proxy、shadowsocks、机场之间的联系和区别","uri":"/%E6%B5%85%E8%B0%88vpnproxyshadowsocks%E6%9C%BA%E5%9C%BA%E4%B9%8B%E9%97%B4%E7%9A%84%E8%81%94%E7%B3%BB%E5%92%8C%E5%8C%BA%E5%88%AB/"},{"categories":["学习记录"],"content":"机场 随着 GFW 的不断升级，其实 shadowsocks 流量也会被检测出来，导致部署 shadowsocks 的服务器 IP 被封禁。其实 shadowsocks 还只是众多科学上网协议中的一种，其实还有 ssr（ShadowsocksR），v2ray（改善了 shadowsocks 的一些缺点，更难被 GFW 检测到，不过配置复杂），Trojan（上文提到过，模仿 https 流量，隐蔽性更强）。 由于自己购买国外的 vps 部署的协议随着 GFW 的不断升级是有可能被识别到导致封 IP 的，如果 vps 提供商不支持更换 IP，那么你这台 vps 就浪费了。如果不想被封就需要不断学习新的隐蔽性更好的协议，所以对于个人用户来说，学习成本很高。 这时候，机场服务就应运而生，只需要少量的付费，通过一条订阅就可以拿到上百条支持各种协议的线路，即使是那个节点被封，那随便切换一条就行。如今对于普通用户来说，机场已经成为了最多的科学上网方式。 ","date":"2021-03-20","objectID":"/%E6%B5%85%E8%B0%88vpnproxyshadowsocks%E6%9C%BA%E5%9C%BA%E4%B9%8B%E9%97%B4%E7%9A%84%E8%81%94%E7%B3%BB%E5%92%8C%E5%8C%BA%E5%88%AB/:7:0","tags":["科学上网"],"title":"浅谈 vpn、proxy、shadowsocks、机场之间的联系和区别","uri":"/%E6%B5%85%E8%B0%88vpnproxyshadowsocks%E6%9C%BA%E5%9C%BA%E4%B9%8B%E9%97%B4%E7%9A%84%E8%81%94%E7%B3%BB%E5%92%8C%E5%8C%BA%E5%88%AB/"},{"categories":["学习记录"],"content":"总结 vpn 是是一种加密通讯技术，它的核心技术是在加密，防窃听上。由于 GFW 刚上的时候 vpn 这项技术成熟，vpn 被迫营业，充当起了第一代翻墙手段。 shadowsocks 闪亮登场，有着很强的隐蔽性，配置简单 GFW 不断升级，更多的隐蔽性强的协议 v2ray，Trojan 机场服务，通过订阅拿到上百条线路，并且协议齐全，如果你不太想折腾并且不追求极致，机场服务是个不错的选择。 参考 https://github.com/sxcool1024/freedom https://github.com/shadowsocks ","date":"2021-03-20","objectID":"/%E6%B5%85%E8%B0%88vpnproxyshadowsocks%E6%9C%BA%E5%9C%BA%E4%B9%8B%E9%97%B4%E7%9A%84%E8%81%94%E7%B3%BB%E5%92%8C%E5%8C%BA%E5%88%AB/:8:0","tags":["科学上网"],"title":"浅谈 vpn、proxy、shadowsocks、机场之间的联系和区别","uri":"/%E6%B5%85%E8%B0%88vpnproxyshadowsocks%E6%9C%BA%E5%9C%BA%E4%B9%8B%E9%97%B4%E7%9A%84%E8%81%94%E7%B3%BB%E5%92%8C%E5%8C%BA%E5%88%AB/"},{"categories":["操作系统"],"content":"  Now we have become very big, Different from the original idea. Collect premium software in various categories. awesome-mac 官方 macOS 最新系统：https://www.apple.com.cn/macos macOS 支持：https://support.apple.com/zh-cn/macos 制作 macOS 安装器：https://support.apple.com/zh-cn/HT201372 macOS 使用手册：https://support.apple.com/zh-cn/guide/mac-help/welcome/mac 序列号查询：https://checkcoverage.apple.com/cn/zh/ 软件下载 MacWk：https://macwk.com/ 马可菠萝：https://www.macbl.com/ 瓜子云盘：https://yun.naodai.org/Software appstorrent：https://www.appstorrent.ru/ Xclient：https://xclient.info/ 麦氪搜：https://www.imacso.com/ Github：https://github.com/search?q=macos 兼容检测 Arm 芯片兼容：https://isapplesiliconready.com/zh ","date":"2021-03-20","objectID":"/macos%E7%9B%B8%E5%85%B3%E8%B5%84%E6%BA%90%E5%90%88%E9%9B%86/:0:0","tags":["macOS"],"title":"MacOS相关资源合集","uri":"/macos%E7%9B%B8%E5%85%B3%E8%B5%84%E6%BA%90%E5%90%88%E9%9B%86/"},{"categories":["操作系统"],"content":"终端快捷键 快捷键应该是每一个需要和终端天天打交道的程序员必备的技能了，如果你还停留在每次前后左右一个字符一个字符移动光标的话，那你需要好好学习下面的终端快捷键，这可以大大提高你的效率 ","date":"2020-08-21","objectID":"/linux%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%BF%AB%E6%8D%B7%E9%94%AE/:1:0","tags":["linux"],"title":"Linux命令行快捷键","uri":"/linux%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%BF%AB%E6%8D%B7%E9%94%AE/"},{"categories":["操作系统"],"content":"最常用 tab 命令或路径的补全键 ","date":"2020-08-21","objectID":"/linux%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%BF%AB%E6%8D%B7%E9%94%AE/:1:1","tags":["linux"],"title":"Linux命令行快捷键","uri":"/linux%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%BF%AB%E6%8D%B7%E9%94%AE/"},{"categories":["操作系统"],"content":"移动光标 Ctrl + a/Home 切换到命令行开始 Ctrl + e/End 切换到命令行末尾 Ctrl + f 光标向右移动一个字符（相当于方向键右键） Ctrl + b 光标向右移动一个字符（相当于方向键左键） ","date":"2020-08-21","objectID":"/linux%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%BF%AB%E6%8D%B7%E9%94%AE/:1:2","tags":["linux"],"title":"Linux命令行快捷键","uri":"/linux%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%BF%AB%E6%8D%B7%E9%94%AE/"},{"categories":["操作系统"],"content":"剪切、粘贴、清除 Ctrl + l 清除屏幕内容，效果等同于 clear 命令 Ctrl + u 清除剪切光标之前的内容 Ctrl + k 剪切清除光标之后的内容 Ctrl + y 粘贴刚才所删除的字符 Ctrl + w 剪切光标所在处之前的一个词（以空格、标点等为分隔符） Ctrl + h 删除光标所在处的前一个字符（相当于退格键） Ctrl + t 颠倒光标所在处及其之前的字符位置，并将光标移动到下一个字符 Alt + t 交换当前与以前单词的位置 Alt + d 剪切光标之后的词 ","date":"2020-08-21","objectID":"/linux%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%BF%AB%E6%8D%B7%E9%94%AE/:1:3","tags":["linux"],"title":"Linux命令行快捷键","uri":"/linux%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%BF%AB%E6%8D%B7%E9%94%AE/"},{"categories":["操作系统"],"content":"控制快捷键 Ctrl + c 终止命令 Ctrl + s 锁住终端 Ctrl + q 解锁终端 Ctrl + z 转入后台运行, 但在当前用户退出后就会终止 Ctrl + d 退出 shell，logout Ctrl +（x u） 按住 Ctrl 的同时再先后按 x 和 u，撤销刚才的操作 ","date":"2020-08-21","objectID":"/linux%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%BF%AB%E6%8D%B7%E9%94%AE/:1:4","tags":["linux"],"title":"Linux命令行快捷键","uri":"/linux%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%BF%AB%E6%8D%B7%E9%94%AE/"},{"categories":["操作系统"],"content":"重复执行命令、查找历史命令 Ctrl + o 重复执行命令 Ctrl + r 在历史命令中查找 （这个非常好用，输入关键字就调出以前的命令了） history 显示你所有执行过的编号 + 历史命令。这个可以配合 !n（n 是编号）来执行某某历史命令 !! 重复执行最后一条命令 (有四种方法) 使用上方向键，并回车执行。 按 !! 并回车执行。 输入 !-1 并回车执行。 按 Ctrl+P 并回车执行。 !\\$ 显示系统最近的一条参数（最后这个比较有用，比如我先用 cat /etc/hosts，然后我想用 vim 编辑。 一般的做法是先用↑ 显示最后一条命令，然后用 Home 移动到命令最前，删除 cat，然后再输入 vim 命 令。其实完全可以用 vim !$ 来代替） cd - 回到前一个工作路径 ","date":"2020-08-21","objectID":"/linux%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%BF%AB%E6%8D%B7%E9%94%AE/:1:5","tags":["linux"],"title":"Linux命令行快捷键","uri":"/linux%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%BF%AB%E6%8D%B7%E9%94%AE/"},{"categories":["操作系统"],"content":"推荐文档 熟练使用命令行是一种常常被忽视，或被认为难以掌握的技能，但实际上，它会提高你作为工程师的灵活性以及生产力。本文是一份我在 Linux 上工作时，发现的一些命令行使用技巧的摘要。有些技巧非常基础，而另一些则相当复杂，甚至晦涩难懂。这篇文章并不长，但当你能够熟练掌握这里列出的所有技巧时，你就学会了很多关于命令行的东西了。 《命令行的艺术》 ","date":"2020-08-21","objectID":"/linux%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%BF%AB%E6%8D%B7%E9%94%AE/:2:0","tags":["linux"],"title":"Linux命令行快捷键","uri":"/linux%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%BF%AB%E6%8D%B7%E9%94%AE/"},{"categories":[""],"content":"目录结构\" 目录结构 Linux将整个文件系统看做一棵树，这棵树的树根叫做根文件系统，用/表示。 目录 全称 备注 /bin binaries 存放着只曾哥系统必须的二进制或可执行文件 /sbin system binaries 存放只能由root用户运行的系统二进制文件 /lib library 二进制文件的公共库 /usr unix system resources 与根目录结构类似，存放不是操作系统必须的二进制文件或应用程序，面向最终用户，centos7中/bin-\u003e/usr/bin, /sbin-\u003e/usr/sbin /etc editable text config 存放配置文件 /home 存放不同用户的文件、配置和软件 /boot 系统启动所需文件，如linux内核 /dev device 包含设备文件，可以像管理普通文件一样管理硬件或者驱动程序 /opt optional 包含软件或者软件包 /var variable 存放操作系统运行过程中发生变化的文件，如系统日志或缓存文件 /tmp temporary 存放临时文件，系统会定期或目录大小到达一定上线后自动清理 /proc processes 正在运行的内核信息映射，主要包括进程信息、内存资源信息、磁盘分区信息等。（虚拟文件系统，不占内存） /lost+found Lost+Found 这个目录在大多数情况下都是空的。但是如果你正在工作突然停电，或是没有用正常方式关机，在你重新启动机器的时候，这里就存放了一些文件。 /srv service 存放一些对外的服务数据（不是软件，而是数据），如web、ftp、流媒体等 /media linux 系统会自动识别一些设备，例如U盘、光驱等等，当识别后，Linux 会把识别的设备挂载到这个目录下。 /mnt 系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将光驱挂载在 /mnt/ 上，然后进入该目录就可以查看光驱里的内容 ","date":"2020-08-11","objectID":"/linux%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84%E5%A4%87%E5%BF%98/:0:0","tags":[""],"title":"Linux系统目录结构备忘","uri":"/linux%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84%E5%A4%87%E5%BF%98/"},{"categories":["协议"],"content":" SOCKS 是一种网络传输协议，主要用于客户端与外网服务器之间通讯的中间传递。SOCKS 是 “Socket Secure” 的缩写。当防火墙后的客户端要访问外部的服务器时，就跟 SOCKS 代理服务器连接。这个代理服务器控制客户端访问外网的资格，允许的话，就将客户端的请求发往外部的服务器。这个协议最初由 David Koblas 开发，而后由 NEC 的 Ying-Da Lee 将其扩展到 SOCKS4。最新协议是 SOCKS5，与前一版本相比，增加支持 UDP（用户数据报协议） 、验证，以及 IPv6 。根据 OSI 模型 ，SOCKS 是 会话层 的协议，位于 表示层 与 传输层 之间。SOCKS 协议不提供 加密 。 SOCKS5 ","date":"2020-07-19","objectID":"/socks%E5%8D%8F%E8%AE%AE%E4%BA%A4%E4%BA%92%E6%B5%81%E7%A8%8B%E8%AE%B0%E5%BD%95/:0:0","tags":["socks"],"title":"SOCKS协议交互流程记录","uri":"/socks%E5%8D%8F%E8%AE%AE%E4%BA%A4%E4%BA%92%E6%B5%81%E7%A8%8B%E8%AE%B0%E5%BD%95/"},{"categories":["协议"],"content":"SOCKS 协议版本认证 创建与 SOCKS5 服务器的 TCP 连接后客户端需要先发送请求来确认协议版本及认证方式（以字节为单位） ","date":"2020-07-19","objectID":"/socks%E5%8D%8F%E8%AE%AE%E4%BA%A4%E4%BA%92%E6%B5%81%E7%A8%8B%E8%AE%B0%E5%BD%95/:1:0","tags":["socks"],"title":"SOCKS协议交互流程记录","uri":"/socks%E5%8D%8F%E8%AE%AE%E4%BA%A4%E4%BA%92%E6%B5%81%E7%A8%8B%E8%AE%B0%E5%BD%95/"},{"categories":["协议"],"content":"client send # +----+----------+----------+ # |VER | NMETHODS | METHODS | # +----+----------+----------+ # | 1 | 1 | 1 to 255 | # +----+----------+----------+ VER：SOCKS5 协议版本 0x05 NMETHODS：METHODS 所占字节长度 METHODS：客户端支持的认证方式列表，每个方法占 1 字节 0x00 不需要认证 0x01 GSSAPI 0x02 用户名、密码认证 0x03 to 0x7F 由 IANA 分配（保留） 0x80 to 0xFE 私人方法保留 0xFF 无可接受的方法 服务器从客户端提供的 METHODS 中选择一个并通过以下消息通知客户端 ","date":"2020-07-19","objectID":"/socks%E5%8D%8F%E8%AE%AE%E4%BA%A4%E4%BA%92%E6%B5%81%E7%A8%8B%E8%AE%B0%E5%BD%95/:1:1","tags":["socks"],"title":"SOCKS协议交互流程记录","uri":"/socks%E5%8D%8F%E8%AE%AE%E4%BA%A4%E4%BA%92%E6%B5%81%E7%A8%8B%E8%AE%B0%E5%BD%95/"},{"categories":["协议"],"content":"server reply # +----+--------+ # |VER | METHOD | # +----+--------+ # | 1 | 1 | # +----+--------+ VER：协议版本 0x05 METHOD：服务端选中的方法。如果返回 0xFF 表示没有一个认证方法被选中，客户端需要关闭连接。 ","date":"2020-07-19","objectID":"/socks%E5%8D%8F%E8%AE%AE%E4%BA%A4%E4%BA%92%E6%B5%81%E7%A8%8B%E8%AE%B0%E5%BD%95/:1:2","tags":["socks"],"title":"SOCKS协议交互流程记录","uri":"/socks%E5%8D%8F%E8%AE%AE%E4%BA%A4%E4%BA%92%E6%B5%81%E7%A8%8B%E8%AE%B0%E5%BD%95/"},{"categories":["协议"],"content":"SOCKS 用户名密码认证 如果 SOCKS 协议版本认证中服务端返回的 METHOD 是 0x02，即需要用户名密码认证，则客户端会发送用户名密码认证信息。如果返回的 METHOD 是 0x00，即不需要认证，直接跳转下一步发送 SOCKS 请求信息。 ","date":"2020-07-19","objectID":"/socks%E5%8D%8F%E8%AE%AE%E4%BA%A4%E4%BA%92%E6%B5%81%E7%A8%8B%E8%AE%B0%E5%BD%95/:2:0","tags":["socks"],"title":"SOCKS协议交互流程记录","uri":"/socks%E5%8D%8F%E8%AE%AE%E4%BA%A4%E4%BA%92%E6%B5%81%E7%A8%8B%E8%AE%B0%E5%BD%95/"},{"categories":["协议"],"content":"client send # +----+------+----------+------+----------+ # |VER | ULEN | UNAME | PLEN | PASSWD | # +----+------+----------+------+----------+ # | 1 | 1 | 1 to 255 | 1 | 1 to 255 | # +----+------+----------+------+----------+ VER：认证协议版本 0x01 ULEN：用户名长度 UNAME： 用户名 PLEN：密码长度 PASSWD：密码 ","date":"2020-07-19","objectID":"/socks%E5%8D%8F%E8%AE%AE%E4%BA%A4%E4%BA%92%E6%B5%81%E7%A8%8B%E8%AE%B0%E5%BD%95/:2:1","tags":["socks"],"title":"SOCKS协议交互流程记录","uri":"/socks%E5%8D%8F%E8%AE%AE%E4%BA%A4%E4%BA%92%E6%B5%81%E7%A8%8B%E8%AE%B0%E5%BD%95/"},{"categories":["协议"],"content":"server reply # +----+--------+ # |VER | STATUS | # +----+--------+ # | 1 | 1 | # +----+--------+ VER：认证协议版本 0x01 STATUS：认证状态 0x00 成功 0x01 失败 ","date":"2020-07-19","objectID":"/socks%E5%8D%8F%E8%AE%AE%E4%BA%A4%E4%BA%92%E6%B5%81%E7%A8%8B%E8%AE%B0%E5%BD%95/:2:2","tags":["socks"],"title":"SOCKS协议交互流程记录","uri":"/socks%E5%8D%8F%E8%AE%AE%E4%BA%A4%E4%BA%92%E6%B5%81%E7%A8%8B%E8%AE%B0%E5%BD%95/"},{"categories":["协议"],"content":"发送 SOCKS 请求信息 认证结束后客户端就可以发送请求信息。如果认证方法有特殊封装要求，请求必须按照方法所定义的方式进行封装。 ","date":"2020-07-19","objectID":"/socks%E5%8D%8F%E8%AE%AE%E4%BA%A4%E4%BA%92%E6%B5%81%E7%A8%8B%E8%AE%B0%E5%BD%95/:3:0","tags":["socks"],"title":"SOCKS协议交互流程记录","uri":"/socks%E5%8D%8F%E8%AE%AE%E4%BA%A4%E4%BA%92%E6%B5%81%E7%A8%8B%E8%AE%B0%E5%BD%95/"},{"categories":["协议"],"content":"client send # +----+-----+-------+------+----------+----------+ # |VER | CMD | RSV | ATYP | DST.ADDR | DST.PORT | # +----+-----+-------+------+----------+----------+ # | 1 | 1 | X'00' | 1 | Variable | 2 | # +----+-----+-------+------+----------+----------+ VER：SOCKS5 协议版本 0x05 CMD：SOCK 命令码 0x01 CONNECT 请求 0x02 BIND 请求 0x03 UDP 转发 RSV：0x00 保留 ATYP：DST.ADDR 类型 0x01 IPv4 地址，DST.ADDR 部分 4 字节长度 0x03 域名，DST.ADDR 部分第一个字节为域名长度，DST.ADDR 剩余的内容为域名，没有 \\ 0 结尾。 0x04 IPv6 地址，16 个字节长度。 DST.ADDR：目的地址 DST.PORT：网络字节序表示的目的端口 ","date":"2020-07-19","objectID":"/socks%E5%8D%8F%E8%AE%AE%E4%BA%A4%E4%BA%92%E6%B5%81%E7%A8%8B%E8%AE%B0%E5%BD%95/:3:1","tags":["socks"],"title":"SOCKS协议交互流程记录","uri":"/socks%E5%8D%8F%E8%AE%AE%E4%BA%A4%E4%BA%92%E6%B5%81%E7%A8%8B%E8%AE%B0%E5%BD%95/"},{"categories":["协议"],"content":"server reply # +----+-----+-------+------+----------+----------+ # |VER | REP | RSV | ATYP | BND.ADDR | BND.PORT | # +----+-----+-------+------+----------+----------+ # | 1 | 1 | X'00' | 1 | Variable | 2 | # +----+-----+-------+------+----------+----------+ VER：SOCKS5 协议版本 0x05 REP：应答字段 0x00 成功 0x01 常规 SOCKS 服务器连接失败 0x02 现有规则不允许连接 0x03 网络不可达 0x04 主机不可达 0x05 连接被拒 0x06 TTL 超时 0x07 不支持的命令 0x08 不支持的地址类型 0x09 to 0xFF 未定义 RSV：0x00 保留 ATYP：BND.ADDR 类型 0x01 IPv4 地址，DST.ADDR 部分 4 字节长度 0x03 域名，DST.ADDR 部分第一个字节为域名长度，DST.ADDR 剩余的内容为域名，没有 \\ 0 结尾。 0x04 IPv6 地址，16 个字节长度。 BND.ADDR：服务器绑定的地址 BND.PORT：网络字节序表示的服务器绑定的端口 当服务端返回 REP 应答字段为 0x00，即成功时，客户端和服务端之间进行数据透传，完成 SOCKS5 代理。 SOCKS4 SOCKS 4 只支持 TCP 转发 ","date":"2020-07-19","objectID":"/socks%E5%8D%8F%E8%AE%AE%E4%BA%A4%E4%BA%92%E6%B5%81%E7%A8%8B%E8%AE%B0%E5%BD%95/:3:2","tags":["socks"],"title":"SOCKS协议交互流程记录","uri":"/socks%E5%8D%8F%E8%AE%AE%E4%BA%A4%E4%BA%92%E6%B5%81%E7%A8%8B%E8%AE%B0%E5%BD%95/"},{"categories":["协议"],"content":"发送 SOCKS 请求信息 ","date":"2020-07-19","objectID":"/socks%E5%8D%8F%E8%AE%AE%E4%BA%A4%E4%BA%92%E6%B5%81%E7%A8%8B%E8%AE%B0%E5%BD%95/:4:0","tags":["socks"],"title":"SOCKS协议交互流程记录","uri":"/socks%E5%8D%8F%E8%AE%AE%E4%BA%A4%E4%BA%92%E6%B5%81%E7%A8%8B%E8%AE%B0%E5%BD%95/"},{"categories":["协议"],"content":"client send # +----+------+----------+--------+----------+----------+ # |VN | CD | DSTPORT | DSTIP | USERID | NULL | # +----+------+----------+--------+----------+----------+ # | 1 | 1 | 2 | 4 | variable | 1 | # +----+------+----------+--------+----------+----------+ VN：SOCKS4 协议版本 0x04 CD：SOCK 命令码 0x01 CONNECT 请求 0x02 BIND 请求 DSTPORT：目的主机的端口 DSTIP：目的主机的 IP 地址 USERID：用户 USERID NULL：0x00 ","date":"2020-07-19","objectID":"/socks%E5%8D%8F%E8%AE%AE%E4%BA%A4%E4%BA%92%E6%B5%81%E7%A8%8B%E8%AE%B0%E5%BD%95/:4:1","tags":["socks"],"title":"SOCKS协议交互流程记录","uri":"/socks%E5%8D%8F%E8%AE%AE%E4%BA%A4%E4%BA%92%E6%B5%81%E7%A8%8B%E8%AE%B0%E5%BD%95/"},{"categories":["协议"],"content":"server reply # +-------+-------+----------+-----------+ # | VN | CD | DSTPORT | DSTIP | # +-------+-------+----------+-----------+ # | 1 | 1 | 2 | 4 | # +-------+-------+----------+-----------+ VN：回复代码的版本，应为 0x00（注意不是 0x04) CD：SOCK 命令码 90(0x5a) 请求得到允许； 91(0x5b) 请求被拒绝或失败； 92(0x5c) 由于 SOCKS 服务器无法连接到客户端的 identd（一个验证身份的进程），请求被拒绝； 93(0x5d) 由于客户端程序与 identd 报告的用户身份不同，连接被拒绝。 DSTPORT：目的主机的端口（和请求包中相同） DSTIP：目的主机的 IP 地址（和请求包中相同） 当服务端返回 CD 字段为 90(0x5a)，即允许时，客户端和服务端之间进行数据透传，完成 SOCKS4 代理。 SOCKS4a SOCKS4a 协议是 SOCKS4 的一个补丁版，可以在 SOCKS4a 代理服务器上完成 DNS 解析 ","date":"2020-07-19","objectID":"/socks%E5%8D%8F%E8%AE%AE%E4%BA%A4%E4%BA%92%E6%B5%81%E7%A8%8B%E8%AE%B0%E5%BD%95/:4:2","tags":["socks"],"title":"SOCKS协议交互流程记录","uri":"/socks%E5%8D%8F%E8%AE%AE%E4%BA%A4%E4%BA%92%E6%B5%81%E7%A8%8B%E8%AE%B0%E5%BD%95/"},{"categories":["协议"],"content":"发送 SOCKS 请求信息 ","date":"2020-07-19","objectID":"/socks%E5%8D%8F%E8%AE%AE%E4%BA%A4%E4%BA%92%E6%B5%81%E7%A8%8B%E8%AE%B0%E5%BD%95/:5:0","tags":["socks"],"title":"SOCKS协议交互流程记录","uri":"/socks%E5%8D%8F%E8%AE%AE%E4%BA%A4%E4%BA%92%E6%B5%81%E7%A8%8B%E8%AE%B0%E5%BD%95/"},{"categories":["协议"],"content":"client send # +----+------+----------+--------+----------+----------+------------+----------+ # |VN | CD | DSTPORT | DSTIP | USERID | NULL | HOSTNAME | NULL | # +----+------+----------+--------+----------+----------+------------+----------+ # | 1 | 1 | 2 | 4 | variable | 1 | variable | 1 | # +----+------+----------+--------+----------+----------+------------+----------+ DSTIP：0.0.0.x，其中 x 是非零，一般都为 1。（原文：such an address is inadmissible as a destination IP address and thus should never occur if the client can resolve the domain name） HOSTNAME：域名 其余字段和 SOCKS4 相同 ","date":"2020-07-19","objectID":"/socks%E5%8D%8F%E8%AE%AE%E4%BA%A4%E4%BA%92%E6%B5%81%E7%A8%8B%E8%AE%B0%E5%BD%95/:5:1","tags":["socks"],"title":"SOCKS协议交互流程记录","uri":"/socks%E5%8D%8F%E8%AE%AE%E4%BA%A4%E4%BA%92%E6%B5%81%E7%A8%8B%E8%AE%B0%E5%BD%95/"},{"categories":["协议"],"content":"server reply SOCKS4a 代理首先把 HOSTNAME 如：www.example.com 解析成对应的主机 IP 地址，并且和 IP 地址连接上，再向客户端发送和 SOCKS4 一样的响应。当服务端返回 CD 字段为 90(0x5a)，即允许时，客户端和服务端之间进行数据透传，完成 SOCKS4a 代理。 SOCKS4，SOCKS4a 和 SOCKS5 的区别 比如浏览器使用 SOCKS4 代理访问 www.baidu.com，浏览器先用本地的 DNS 解析把 www.baidu.com 转换成对应的 IP 地址，然后向 SOCKS4 服务器发送报文。如果此时我们的电脑受限本地完成不了 DNS 解析，那怎么办呢？SOCKS4a 就是解决这样的问题的，客户端可以把域名发送到 SOCKS4a 服务器上完成 DNS 解析，发送的 DSTIP 则为 0.0.0.1 这样的假 IP，然后就是和 SOCKS4 一样进行数据转发。SOCKS5 代理和 SOCKS4 SOCKS4a 比，多了一个验证功能和 udp 代理的功能。 SOCKS 协议 RFC SOCKS4.protocol.txt and SOCKS4A.protocol.txt for SOCKS 4 and the SOCKS 4A extension, respectively. SOCKS5_rfc1928.txt and SOCKS5_rfc1929.txt for SOCKS 5, and SOCKS 5 Username/Password authentication. ","date":"2020-07-19","objectID":"/socks%E5%8D%8F%E8%AE%AE%E4%BA%A4%E4%BA%92%E6%B5%81%E7%A8%8B%E8%AE%B0%E5%BD%95/:5:2","tags":["socks"],"title":"SOCKS协议交互流程记录","uri":"/socks%E5%8D%8F%E8%AE%AE%E4%BA%A4%E4%BA%92%E6%B5%81%E7%A8%8B%E8%AE%B0%E5%BD%95/"},{"categories":["操作系统"],"content":"黑苹果和白苹果最大的区别其实在显示效果上。同样一个网页，白苹果的显示就会细腻很多，而黑苹果颗粒感非常严重，造成上述原因是因为大多数苹果设备的屏幕本身的分辨率很高，如果你的显示器分辨率达到视网膜级别的话，哪怕是黑苹果也是默认开启 HiDPI 的。So 本人的 2k 分辨率显示器就很尴尬了，下面记录一下开启 HiDPI 的过程。 ","date":"2020-07-11","objectID":"/%E9%BB%91%E8%8B%B9%E6%9E%9C%E4%B8%80%E9%94%AE%E5%BC%80%E5%90%AFhidpi/:0:0","tags":["黑苹果"],"title":"黑苹果一键开启 HiDPI","uri":"/%E9%BB%91%E8%8B%B9%E6%9E%9C%E4%B8%80%E9%94%AE%E5%BC%80%E5%90%AFhidpi/"},{"categories":["操作系统"],"content":"HiDPI 的概念 有关 retina 和 HiDPI 那点事 总之 HiDPI 是苹果一个牛逼的显示技术，通过牺牲一定的分辨率实现更细腻的显示效果，这就是为什么 2K 显示器开启 HiDPI 的效果要比 1080P 好的原因了。 ","date":"2020-07-11","objectID":"/%E9%BB%91%E8%8B%B9%E6%9E%9C%E4%B8%80%E9%94%AE%E5%BC%80%E5%90%AFhidpi/:1:0","tags":["黑苹果"],"title":"黑苹果一键开启 HiDPI","uri":"/%E9%BB%91%E8%8B%B9%E6%9E%9C%E4%B8%80%E9%94%AE%E5%BC%80%E5%90%AFhidpi/"},{"categories":["操作系统"],"content":"黑苹果开启原生 HiDPI 终端中运行如下命令 sh -c \"$(curl -fsSL https://raw.githubusercontent.com/xzhih/one-key-hidpi/master/hidpi.sh)\" 如果出现 curl: (7) Failed to connect to raw.githubusercontent.com port 443:xxx，应该是被墙了，可以挂上梯子 export https_proxy=http://127.0.0.1:7890 http_proxy=http://127.0.0.1:7890 all_proxy=socks5://127.0.0.1:7890 终端运行后选择相应分辨率重启即可生效！ ","date":"2020-07-11","objectID":"/%E9%BB%91%E8%8B%B9%E6%9E%9C%E4%B8%80%E9%94%AE%E5%BC%80%E5%90%AFhidpi/:2:0","tags":["黑苹果"],"title":"黑苹果一键开启 HiDPI","uri":"/%E9%BB%91%E8%8B%B9%E6%9E%9C%E4%B8%80%E9%94%AE%E5%BC%80%E5%90%AFhidpi/"},{"categories":["操作系统"],"content":"HiDPI 开启效果 可以看到 HiDPI 开启后，「显示器选项」里面的缩放显示如图所示。可随意选择缩放模式而且不会高糊，在显示上明显感觉图标颗粒感更小了，显示更加细腻了。 ","date":"2020-07-11","objectID":"/%E9%BB%91%E8%8B%B9%E6%9E%9C%E4%B8%80%E9%94%AE%E5%BC%80%E5%90%AFhidpi/:3:0","tags":["黑苹果"],"title":"黑苹果一键开启 HiDPI","uri":"/%E9%BB%91%E8%8B%B9%E6%9E%9C%E4%B8%80%E9%94%AE%E5%BC%80%E5%90%AFhidpi/"},{"categories":["终端工具"],"content":" ApacheBench （ab）是用于对 Apache 超文本传输协议（HTTP）服务器进行基准测试的工具。ab 命令会创建很多的并发访问线程，模拟多个访问者同时对某一 URL 地址进行访问。它的测试目标是基于 URL 的，因此，既可以用来测试 Apache 的负载压力，也可以测试 nginx、lighthttp、tomcat、IIS 等其它 Web 服务器的压力。ab 命令对发出负载的计算机要求很低，既不会占用很高 CPU，也不会占用很多内存，但却会给目标服务器造成巨大的负载，其原理类似 CC 攻击。自己测试使用也须注意，否则一次上太多的负载，可能造成目标服务器因资源耗完，严重时甚至导致死机。 ","date":"2020-05-26","objectID":"/apachebench-http%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/:0:0","tags":[""],"title":"ApacheBench HTTP 服务器基准测试工具使用总结","uri":"/apachebench-http%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"},{"categories":["终端工具"],"content":"ApacheBench 安装 ","date":"2020-05-26","objectID":"/apachebench-http%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/:1:0","tags":[""],"title":"ApacheBench HTTP 服务器基准测试工具使用总结","uri":"/apachebench-http%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"},{"categories":["终端工具"],"content":"macOS Mac 下自带 apache，查看版本： apachectl -v 查看 ab 版本: ab -V ","date":"2020-05-26","objectID":"/apachebench-http%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/:1:1","tags":[""],"title":"ApacheBench HTTP 服务器基准测试工具使用总结","uri":"/apachebench-http%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"},{"categories":["终端工具"],"content":"Window Windows 系统 Apache：下载链接 ","date":"2020-05-26","objectID":"/apachebench-http%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/:1:2","tags":[""],"title":"ApacheBench HTTP 服务器基准测试工具使用总结","uri":"/apachebench-http%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"},{"categories":["终端工具"],"content":"Linux Ubuntu apt-get install apache2-utils CentOS yum -y install httpd-tools ","date":"2020-05-26","objectID":"/apachebench-http%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/:1:3","tags":[""],"title":"ApacheBench HTTP 服务器基准测试工具使用总结","uri":"/apachebench-http%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"},{"categories":["终端工具"],"content":"ApacheBench 使用 ","date":"2020-05-26","objectID":"/apachebench-http%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/:2:0","tags":[""],"title":"ApacheBench HTTP 服务器基准测试工具使用总结","uri":"/apachebench-http%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"},{"categories":["终端工具"],"content":"Options ab 压力测试工具的用法，查看： ab -h # 或者 man ab Usage: ab [options] [http[s]://]hostname[:port]/path Options are: -n requests Number of requests to perform # 在测试会话中所执行的请求个数（本次测试总共要访问页面的次数）。默认时，仅执行一个请求。 -c concurrency Number of multiple requests to make at a time # 一次产生的请求个数（并发数）。默认是一次一个。 -t timelimit Seconds to max. to spend on benchmarking This implies -n 50000 # 测试所进行的最大秒数。其内部隐含值是 - n 50000。它可以使对服务器的测试限制在一个固定的总时间以内。默认时，没有时间限制。 -s timeout Seconds to max. wait for each response Default is 30 seconds # 套接字超时之前要等待的最大秒数。默认值为 30 秒。在 2.4.4 及更高版本中可用。 -b windowsize Size of TCP send/receive buffer, in bytes # TCP 发送 / 接收缓冲区的大小，以字节为单位。 -B address Address to bind to when making outgoing connections # 建立传出连接时要绑定的地址。 -p postfile File containing data to POST. Remember also to set -T # 包含要发布的数据的文件。记住也要设置 - T。 -u putfile File containing data to PUT. Remember also to set -T # 包含数据到 PUT 的文件。记住也要设置 - T。 -T content-type Content-type header to use for POST/PUT data, eg. 'application/x-www-form-urlencoded' Default is 'text/plain' # 用于 POST / PUT 数据的内容类型标头，例如 application/x-www-form-urlencoded。默认值为 text/plain。 -v verbosity How much troubleshooting info to print # 设置详细级别 4 上方将在标题上显示信息，3 上方将显示响应代码（404、200 等），2 上方将显示警告和信息。 -w Print out results in HTML tables # 在 HTML 表格中打印出结果。默认表是两列宽，带有白色背景。 -i Use HEAD instead of GET # 做 HEAD 请求，而不是 GET。 -x attributes String to insert as table attributes # 用作的属性的字符串 \u003ctable\u003e。插入属性。\u003ctable here \u003e -y attributes String to insert as tr attributes # 用作的属性的字符串 \u003ctr\u003e。 -z attributes String to insert as td or th attributes # 用作的属性的字符串 \u003ctd\u003e。 -C attribute Add cookie, eg. 'Apache=1234'. (repeatable) # cookie-name=value 对请求附加一个 Cookie: 行。 其典型形式是 name=value 的一个参数对。此参数可以重复，用逗号分割。 -H attribute Add Arbitrary header line, eg. 'Accept-Encoding: gzip' Inserted after all normal header lines. (repeatable) # 将额外的标头添加到请求。该参数是典型地在一个有效报头线的形式，含有一个冒号分隔的字段值对（即，\"Accept-Encoding: zip/zop;8bit\"）。 -A attribute Add Basic WWW Authentication, the attributes are a colon separated username and password. # 向服务器提供 BASIC 身份验证凭据。用户名和密码用单个: 分隔，并通过编码为 base64 的网络发送。无论服务器是否需要该字符串，都将发送该字符串（即，已发送所需的 401 身份验证）。 -P attribute Add Basic Proxy Authentication, the attributes are a colon separated username and password. # 在代理途中提供 BASIC 身份验证凭据。用户名和密码用单个: 分隔，并通过编码为 base64 的网络发送。不管代理是否需要它都将发送该字符串（即，已发送所需的 407 代理身份验证）。 -X proxy:port Proxyserver and port number to use # 使用代理服务器处理请求。 -V Print version number and exit # 显示版本号并退出。 -k Use HTTP KeepAlive feature # 启用 HTTP KeepAlive 功能，即在一个 HTTP 会话中执行多个请求。默认为 no KeepAlive。 -d Do not show percentiles served table. # 不要显示 “XX [ms] 表中的投放百分比”。（旧版支持）。 -S Do not show confidence estimators and warnings. # 当平均值和中位数相距标准偏差的一倍或两倍以上时，请勿显示中位数和标准偏差值，也不会显示警告 / 错误消息。并默认为最小值 / 平均值 / 最大值。（旧版支持）。 -q Do not show progress when doing more than 150 requests # 当处理 150 个以上的请求时，每 10％或 100 个左右的请求 ab 输出进度计数 stderr。该 -q 标志将禁止显示这些消息。 -l Accept variable document length (use this for dynamic pages) # 如果响应的长度不是恒定的，请不要报告错误。这对于动态页面很有用。在 2.4.7 及更高版本中可用。 -g filename Output collected data to gnuplot format file. # 将所有测量值写为 “gnuplot” 或 TSV（制表符单独值）文件。此文件可以轻松导入到 Gnuplot，IDL，Mathematica，Igor 甚至 Excel 等软件包中。标签位于文件的第一行。 -e filename Output CSV file with percentages served # 编写一个逗号分隔值（CSV）文件，其中包含为每个百分比（从 1％到 100％）提供该百分比请求所花费的时间（以毫秒为单位）。通常，它比 “gnuplot” 文件有用。因为结果已经 “装箱” 了。 -r Don not exit on socket receive errors. # 套接字接收错误时不退出 -m method Method name # 请求的自定义 HTTP 方法。在 2.4.10 及更高版本中可用。 -h Display usage information (this message) # 显示使用情况信息。 -I Disable TLS Server Name Indication (SNI) extension # 禁用 TLS 服务器名称指示 (SNI) 扩展 -Z ciphersuite Specify SSL/TLS cipher suite (See openssl ciphers) # 指定 SSL / TLS 密码套件（请参阅 openssl 密码） -f protocol Specify SSL/TLS protocol (SSL2, TLS1, TLS1.1, TLS1.2 or ALL) # 指定 SSL / TLS 协议（SSL2，SSL3，TLS1，TLS1.1，TLS1.2 或 ALL）。TLS1.1 和 TLS1.2 支持在 2.4.4 及更高版本中提供。 -E certfile Specify optional client certificate chain and private key # 指定可选的客户端证书链和私钥 ","date":"2020-05-26","objectID":"/apachebench-http%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/:2:1","tags":[""],"title":"ApacheBench HTTP 服务器基准测试工具使用总结","uri":"/apachebench-http%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"},{"categories":["终端工具"],"content":"Output 执行命令 ab -n 1000 -c 200 http://pts.aliyun.com/lite/index.htm/ 获取结果分析 # apache 版本信息 This is ApacheBench, Version 2.3 \u003c$Revision: 1843412 $\u003e Copyright 1996 Adam Twiss, Zeus Technology Ltd, http://www.zeustech.net/ Licensed to The Apache Software Foundation, http://www.apache.org/ Benchmarking pts.aliyun.com (be patient) Completed 100 requests Completed 200 requests Completed 300 requests Completed 400 requests Completed 500 requests Completed 600 requests Completed 700 requests Completed 800 requests Completed 900 requests Completed 1000 requests Finished 1000 requests # 请求返回 header 类型 Server Software: Tengine/Aserver # 请求 ip 或者域名 Server Hostname: pts.aliyun.com # 请求端口，当前请求为 https 所以端口为 443，请求 https 端口 80 Server Port: 80 # 从命令行字符串解析请求 URI。 Document Path: /lite/index.htm/ # 这是第一个成功返回的文档的大小（以字节为单位）。如果在测试过程中文档长度发生变化，则将响应视为错误。 Document Length: 357 bytes # 测试期间使用的并发客户端数 Concurrency Level: 200 从建立连接到最后接受完成总时间 Time taken for tests: 1.280 seconds # 完成请求数 Complete requests: 1000 # 失败请求数 Failed requests: 0 # 不在 200 系列响应代码中的响应数。如果所有响应均为 200，则不会打印此字段。 Non-2xx responses: 1000 # 从服务器接收的字节总数 Total transferred: 642000 bytes # HTML 接收字节数，减去了 Total transferred 中 HTTP 响应数据中的头信息的长度 HTML transferred: 357000 bytes # 吞吐率：每秒请求数（总请求数 / 总时间，相当于 LR 中的每秒事务数 TPS） Requests per second: 781.47 [#/sec] (mean) # 用户平均请求等待时间 Time per request: 255.928 [ms] (mean) # 服务器处理每个请求平均响应时间，mean 表示为平均值 Time per request: 1.280 [ms] (mean, across all concurrent requests) # 由公式计算得出的传输速率 totalread / 1024 / timetaken Transfer rate: 489.95 [Kbytes/sec] received # 连接消耗时间分解 Connection Times (ms) min mean[+/-sd] median max 最小值 平均值 标准差 中间值 最大值 Connect: 22 30 4.0 30 38 Processing: 22 95 164.5 34 1200 Waiting: 22 83 154.3 33 1200 Total: 46 125 163.4 66 1227 # 按完成请求的百分比，得出完成请求中花费时间最长的那一个请求的时间，也就是这些请求完成时间的最大值（毫秒） Percentage of the requests served within a certain time (ms) # 50% 请求完成时间的最大值是 66 毫秒 50% 66 66% 69 75% 71 80% 80 90% 317 # 90% 请求完成时间的最大值是 148 毫秒 95% 536 98% 744 99% 825 # // 100% 请求完成时间的最大值是 1227 毫秒（最长请求） 100% 1227 (longest request) ","date":"2020-05-26","objectID":"/apachebench-http%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/:2:2","tags":[""],"title":"ApacheBench HTTP 服务器基准测试工具使用总结","uri":"/apachebench-http%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"},{"categories":["终端工具"],"content":"性能指标 ","date":"2020-05-26","objectID":"/apachebench-http%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/:3:0","tags":[""],"title":"ApacheBench HTTP 服务器基准测试工具使用总结","uri":"/apachebench-http%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"},{"categories":["终端工具"],"content":"1、吞吐率（Requests per second） 服务器并发处理能力的量化描述，单位是 reqs/s，指的是在某个并发用户数下单位时间内处理的请求数。某个并发用户数下单位时间内能处理的最大请求数，称之为最大吞吐率。 记住：吞吐率是基于并发用户数的。这句话代表了两个含义： a、吞吐率和并发用户数相关； b、不同的并发用户数下，吞吐率一般是不同的。 计算公式：总请求数 / 处理完成这些请求数所花费的时间，即： Request per second=Complete requests/Time taken for tests 必须要说明的是，这个数值表示当前机器的整体性能，值越大越好。 ","date":"2020-05-26","objectID":"/apachebench-http%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/:3:1","tags":[""],"title":"ApacheBench HTTP 服务器基准测试工具使用总结","uri":"/apachebench-http%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"},{"categories":["终端工具"],"content":"2、并发连接数（The number of concurrent connections） 并发连接数指的是某个时刻服务器所接受的请求数目，简单的讲，就是一个会话。 ","date":"2020-05-26","objectID":"/apachebench-http%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/:3:2","tags":[""],"title":"ApacheBench HTTP 服务器基准测试工具使用总结","uri":"/apachebench-http%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"},{"categories":["终端工具"],"content":"3、并发用户数（Concurrency Level） 要注意区分这个概念和并发连接数之间的区别，一个用户可能同时会产生多个会话，也即连接数。在 HTTP/1.1 下，IE7 支持两个并发连接，IE8 支持 6 个并发连接，FireFox3 支持 4 个并发连接，所以相应的，我们的并发用户数就得除以这个基数。 ","date":"2020-05-26","objectID":"/apachebench-http%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/:3:3","tags":[""],"title":"ApacheBench HTTP 服务器基准测试工具使用总结","uri":"/apachebench-http%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"},{"categories":["终端工具"],"content":"4、用户平均请求等待时间（Time per request） 计算公式：处理完成所有请求数所花费的时间 /（总请求数 / 并发用户数），即：Time per request=Time taken for tests/（Complete requests/Concurrency Level） ","date":"2020-05-26","objectID":"/apachebench-http%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/:3:4","tags":[""],"title":"ApacheBench HTTP 服务器基准测试工具使用总结","uri":"/apachebench-http%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"},{"categories":["终端工具"],"content":"5、服务器平均请求等待时间（Time per request:across all concurrent requests） 计算公式：处理完成所有请求数所花费的时间 / 总请求数，即： Time taken for/testsComplete requests 可以看到，它是吞吐率的倒数。同时，它也等于用户平均请求等待时间 / 并发用户数，即： Time per request/Concurrency Level ","date":"2020-05-26","objectID":"/apachebench-http%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/:3:5","tags":[""],"title":"ApacheBench HTTP 服务器基准测试工具使用总结","uri":"/apachebench-http%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"},{"categories":["编程语言"],"content":"经常看到一些 Python 第三方库的 features 中都写到了 Thread safety（线程安全），那么究竟什么是线程安全呢？ 线程不安全 首先看看线程不安全的情况，下面一段代码开启的了两个线程，对全局变量 number 自增 100 万次 from threading import Thread number = 0 def target(): global number for _ in range(1000000): number += 1 thread_01 = Thread(target=target) thread_02 = Thread(target=target) thread_01.start() thread_02.start() thread_01.join() thread_02.join() print(number) 1476577 1134416 1437371 连续输出多次发现结果并不是我们想要的 200 万，这就是线程不安全。究其原因就是 number+=1 这段代码不是原子操作 原子操作 原子操作（atomic operation），指不会被线程调度机制打断的操作，这种操作一旦开始，就一直运行到结束，中间不会切换到其他线程，有点类似数据库中的事务。 在 Python 的 官方文档 中就列出了哪些操作是原子操作（L、L1、L2 是列表，D、D1、D2 是字典，x、y 是对象，i、j 是 int） L.append(x) L1.extend(L2) x = L[i] x = L.pop() L1 [i:j] = L2 L.sort() x = y x.field = y D[x] = y D1.update(D2) D.keys() 这些操作不是 i = i + 1 L.append(L[-1]) L [i] = L[j] D [x] = D[x] + 1 两个线程同时读取到了同一个 number 值完成自增操作后然后赋值，本来已经加两次的操作却只增加了一次。 dis 模块 当我们还是无法确定我们的代码是否具有原子性的时候，可以尝试通过 dis（Python 字节码反汇编器） 模块里的 dis 函数来查看 \u003e\u003e\u003e from dis import dis \u003e\u003e\u003e number = 0 \u003e\u003e\u003e \u003e\u003e\u003e def target(): ... global number ... number += 1 ... \u003e\u003e\u003e dis(target) 3 0 LOAD_GLOBAL 0 (number) 2 LOAD_CONST 1 (1) 4 INPLACE_ADD 6 STORE_GLOBAL 0 (number) 8 LOAD_CONST 0 (None) 10 RETURN_VALUE 可以发现 numver += 1 这一行代码是由 4 条字节码实现的，其他字节码可以查看 Python 字节码说明 LOAD_GLOBAL：加载全局变量 number LOAD_CONST：加载被加数 1 INPLACE_ADD：将两个值相加 STORE_GLOBAL：相加后的结果重新赋值给 number 当一行代码被分成多条字节码指令的时候，就代表在线程线程切换时，有可能只执行了一条字节码指令，此时若这行代码里有被多个线程共享的变量或资源时，并且拆分的多条指令里有对于这个共享变量的写操作，就会发生数据的冲突，导致数据的不准确。 其实一个操作是不是原子的有两种评判标准（个人理解）： 对于纯 Python 代码，是不是只有一条 bytecode 对于 C 实现的函数，内部有没有释放 GIL（如内置数据类型 ints, lists, dicts, etc 的一些操作） 如何线程安全 可以使用 Python 的 threading 模块提供的三种消息通信机制 Event Condition Queue 如 urllib3 中实现的连接池就使用了 Queue 中的 LifoQueue 来实现线程安全 疑问 ","date":"2020-04-19","objectID":"/python%E4%B8%AD%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E5%92%8C%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C/:0:0","tags":["Python"],"title":"Python中的线程安全和原子操作","uri":"/python%E4%B8%AD%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E5%92%8C%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C/"},{"categories":["编程语言"],"content":"Python 中有 GIL 了为什么还会出现线程不安全呢？ GIL 的作用是：对于一个解释器，只能有一个 thread 在执行 bytecode。所以每时每刻只有一条 bytecode 在被执行一个 thread。GIL 保证了 bytecode 这层面上是 thread safe 的。 但是如果你有个操作比如 x += 1，这个操作需要多个 bytecodes 操作，在执行这个操作的多条 bytecodes 期间的时候可能中途就换 thread 了，这样就出现了 data races 的情况了。 ","date":"2020-04-19","objectID":"/python%E4%B8%AD%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E5%92%8C%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C/:1:0","tags":["Python"],"title":"Python中的线程安全和原子操作","uri":"/python%E4%B8%AD%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E5%92%8C%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C/"},{"categories":["编程语言"],"content":"Python 中 list 操作是线程安全为什么还要使用 Queue 呢？ 列表操作确实是线程安全的，可以用作多线程中存储对象。但是一般不用列表，而是使用 Queue，因为后者内部实现了 Condition 锁的通信机制，能保证顺序等等。 参考 https://stackoverflow.com/questions/6319207/are-lists-thread-safe https://www.zoulei.net/2016/07/31/list_dict_threading_safe/ https://www.cnblogs.com/wongbingming/p/9035579.html https://zhuanlan.zhihu.com/p/34150765 ","date":"2020-04-19","objectID":"/python%E4%B8%AD%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E5%92%8C%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C/:2:0","tags":["Python"],"title":"Python中的线程安全和原子操作","uri":"/python%E4%B8%AD%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E5%92%8C%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C/"},{"categories":["随笔"],"content":"毕业进入公司起，直属 Leader 常常提到：「编程不仅仅是知识和技能，更重要的是去领会编程领域的文化」。 刚进入公司的我似乎并没有马上接受这一点，认为这可能只是所谓的 “玄学” 罢了，所以也就是当作任务记下了，并没有很好的理会。 直到我工作了一年后，疫情期间读完 Leader 发来的一篇《如何成为一名黑客》，文章似乎解答了我初入编程行业的疑惑并且指明了未来的方向。 标题是如何成为一名黑客，这里的黑客并不是我们所认为的在网络中来无影去无踪的 “黑客”。在我看来，这篇文章讲述的是你如何成为一名优秀并且受人尊敬的计算机工程师。 ","date":"2020-04-06","objectID":"/%E5%A6%82%E4%BD%95%E6%88%90%E4%B8%BA%E4%B8%80%E5%90%8D%E9%BB%91%E5%AE%A2/:0:0","tags":null,"title":"如何成为一名黑客","uri":"/%E5%A6%82%E4%BD%95%E6%88%90%E4%B8%BA%E4%B8%80%E5%90%8D%E9%BB%91%E5%AE%A2/"},{"categories":["随笔"],"content":"基本的态度 这个世界充满了令人着迷的问题等着我们去解决 你要从解决问题，磨练技术，以及锻炼智力中得到基本的享受以及动力。的确，回想这一年的工作时光，另我开心的事情莫过于解决了棘手问题，学习了一门新的语言，自己完成的功能第二天就上线，得到了客户的认可等等。 一个问题不应该被解决两次 不应该把宝贵的时间浪费在发明轮子上。初入公司我想着把很多 python2 的代码重构成 python3，现在想想确实浪费时间，应该着重于解决新的问题而不是在旧问题上浪费时间。 无聊和乏味的工作是罪恶的 重复性劳动浪费我们解决新问题的时间，而解决新问题才是最大的价值所在。提取公共函数，将日常的工作变成自动化等等。 崇尚自由 其实这一点并不是很理解，产品经理提出无理的需求？？？ 2020/09/10 更新：这个上升到政治层面就比较好理解了，比如美国打压 WeChat 和 Tik Tok 态度不能代替能力 只具备这些态度并不能使你成为一名黑客，也不能使你成为一个运动健将和摇滚明星。成为一名黑客需要智力、实践、奉献精神、以及辛苦的工作。 ","date":"2020-04-06","objectID":"/%E5%A6%82%E4%BD%95%E6%88%90%E4%B8%BA%E4%B8%80%E5%90%8D%E9%BB%91%E5%AE%A2/:1:0","tags":null,"title":"如何成为一名黑客","uri":"/%E5%A6%82%E4%BD%95%E6%88%90%E4%B8%BA%E4%B8%80%E5%90%8D%E9%BB%91%E5%AE%A2/"},{"categories":["随笔"],"content":"基本的技能 学习如何编程（这里包括以下内容有几句话写的很好，我想全搬运过来） 有一个大体的规律，就是如果你过于偏重使用一种语言，这种语言一方面会成为你得心应手的工具，另一方面也会阻碍你的学习。有这个问题的不只是编程语言，类似 RubyOnRails、CakePHP、以及 Django 的 web 应用框架也有这个问题，它们只会让你肤浅地懂得一些东西，当你碰到难以解决的问题或者需要调试时，你就可能不知所措了。 单单学习编程语言并不会让你达到黑客的程度，甚至连程序员的程度都难企及——你需要脱离某种编程语言的束缚，学习通过编程解决问题的思路。要成为一个真正的黑客，你需要达到几天就能学会一门编程语言的水平，你可以将文档里的信息和你已经掌握的知识结合起来，很快就学会一门编程语言。这意味着你需要先学会机种思路截然不同的语言才行。 编程是一个复杂的技能，我无法给你完整的指南来教会你如何编程，不过我可以告诉你，书本和课程也无法教会你如何编程——很多黑客，或者也许几乎所有的黑客，都是靠自学的。你从书本上学到语言的特点——只是一些皮毛，但要使书面知识成为自身技能，你只能通过实践和虚心向他人学习。因此你要做的就是 (a) 读代码，(b) 写代码。 学习编程就象学习自然语言写作一样。最好的做法是读一些大师的名著，试着自己写点东西，再读些，再写点，再读些，再写点…… 如此往复，直到你的文章具备范文的力量和感觉为止。 学会使用开源的 Unix 系统 Unix 还是 Internet 的操作系统。你可以学会上网却不知道 Unix，但你不了解 Unix 就无法成为一名 Internet 黑客。因此，今天的黑客文化在很大程度上是以 Unix 为核心的。（这点并不总是真的，一些很早的黑客对此一直很不满，但 Unix 和 Internet 之间的联系已是如此之强，就连 Microsoft 这样强力的公司也对此也无可奈何。） 学会使用万维网以及编写 HTML 学会使用 Google，Stack Overflow，Github 等等 学习英语，如果你的水平不够的话 Linus Torvalds 是芬兰人，但他的代码注解是用英语写的（很明显他从没想过其他的可能性）。他流利的英语。是他能够管理全球范围的 Linux 开发人员社区的重要因素，这是一个值得学习的例子。 就算你的母语是英语，这也无法保证你的语言技能足够达到黑客的标准。如果你的写作文字不通、语法混乱、错字连篇，包括我在内的大部分的黑客都会忽略你的存在。虽然写作马虎不一定意味着思考也马虎，但我们发现两者的关联性还是挺强的——马虎的头脑对我们来说毫无价值，如果你写作能力不够，就好好学习写作吧。（划重点，终于知道王哥为什么每次都会特别强调然后纠正我的错别字了） ","date":"2020-04-06","objectID":"/%E5%A6%82%E4%BD%95%E6%88%90%E4%B8%BA%E4%B8%80%E5%90%8D%E9%BB%91%E5%AE%A2/:2:0","tags":null,"title":"如何成为一名黑客","uri":"/%E5%A6%82%E4%BD%95%E6%88%90%E4%B8%BA%E4%B8%80%E5%90%8D%E9%BB%91%E5%AE%A2/"},{"categories":["随笔"],"content":"提高自己在编程圈中的地位 以下就是以后的人生所追求的吧，自己离这些还很遥远。 撰写开源软件 黑客领域里最受尊敬的偶像，是那些写了大型的、好用的、用途广泛的软件，并把它们发布出来，使得每人都在使用他软件的人。 帮助测试并调试开源软件 如果你是个新手，试着找一个你感兴趣的正在开发中的程序，做一个好的 beta 测试员。你会自然地从帮着测试，进步到帮着抓 bug，到最后帮着改程序。你会从中学到很多，而且善因种善果，以后别人也会很乐意帮助你。 发布有用的信息 另一件好事是收集整理有用有趣的信息，做成网页或类似 FAQ 的文档，并且让大家都能看到。技术性 FAQ 的维护者会受到和开源代码的作者一样多的尊敬。（比如 Github 上面很多 awesome language 和国内很多大佬的博客，录制的教程等等） 帮助维护基础设施的运转 黑客文化（还有互联网工程方面的发展）是靠志愿者推动的。要使 Internet 能正常工作，就要有大量枯燥的工作不得不去完成——管理邮件列表和新闻组，维护大型软件库，开发 RFC 和其它技术标准等等。 做这类事情的人会得到很多尊敬，因为每人都知道这些事情费时颇多，而又不象编程那样有趣。做这些事情需要奉献精神。 为黑客文化本身服务 黑客文化没有领袖，这点是确认无疑的。但黑客圈里确实有些文化英雄、部落长者、史学家、还有发言人。如果你在这圈里呆足够长时间，你也许也能成为其中之一。 记住：黑客们不相信他们的部落长者的自夸，因此过分追求这种名誉是危险的。与其奋力追求，不如先摆正自己的位置，等它自己落到你的手中——那时则要做到谦虚和优雅。 常读常新，每隔一段时间读一遍都会有新的收获。最后附上这篇文档。 如何成为一名黑客 ","date":"2020-04-06","objectID":"/%E5%A6%82%E4%BD%95%E6%88%90%E4%B8%BA%E4%B8%80%E5%90%8D%E9%BB%91%E5%AE%A2/:3:0","tags":null,"title":"如何成为一名黑客","uri":"/%E5%A6%82%E4%BD%95%E6%88%90%E4%B8%BA%E4%B8%80%E5%90%8D%E9%BB%91%E5%AE%A2/"},{"categories":["编程语言"],"content":"原文 Beautiful is better than ugly. Explicit is better than implicit. Simple is better than complex. Complex is better than complicated. Flat is better than nested. Sparse is better than dense. Readability counts. Special cases aren’t special enough to break the rules. Although practicality beats purity. Errors should never pass silently. Unless explicitly silenced. In the face of ambiguity, refuse the temptation to guess. There should be one– and preferably only one –obvious way to do it. Although that way may not be obvious at first unless you’re Dutch. Now is better than never. Although never is often better than right now. If the implementation is hard to explain, it’s a bad idea. If the implementation is easy to explain, it may be a good idea. Namespaces are one honking great idea – let’s do more of those! ","date":"2020-01-16","objectID":"/python%E4%B9%8B%E7%A6%85/:1:0","tags":["Python"],"title":"Python之禅","uri":"/python%E4%B9%8B%E7%A6%85/"},{"categories":["编程语言"],"content":"解读 The Zen of Python 是 Python 语言的指导原则，遵循这些基本原则，你就可以像个 Pythonista 一样编程。具体内容你可以在 Python 命令行输 import this 看到： Beautiful is better than ugly. # 优美胜于丑陋（Python 以编写优美的代码为目标） Explicit is better than implicit. # 明了胜于晦涩（优美的代码应当是明了的，命名规范，风格相似） Simple is better than complex. # 简洁胜于复杂（优美的代码应当是简洁的，不要有复杂的内部实现） Complex is better than complicated. # 复杂胜于凌乱（如果复杂不可避免，那代码间也不能有难懂的关系，要保持接口简洁） Flat is better than nested. # 扁平胜于嵌套（优美的代码应当是扁平的，不能有太多的嵌套） Sparse is better than dense. # 间隔胜于紧凑（优美的代码有适当的间隔，不要奢望一行代码解决问题） Readability counts. # 可读性很重要（优美的代码是可读的） Special cases aren’t special enough to break the rules. Although practicality beats purity. # 即便假借特例的实用性之名，也不可违背这些规则（这些规则至高无上） Errors should never pass silently. Unless explicitly silenced. # 不要包容所有错误，除非你确定需要这样做（精准地捕获异常，不写 except:pass 风格的代码） In the face of ambiguity, refuse the temptation to guess. # 当存在多种可能，不要尝试去猜测 There should be one– and preferably only one –obvious way to do it. # 而是尽量找一种，最好是唯一一种明显的解决方案（如果不确定，就用穷举法） Although that way may not be obvious at first unless you’re Dutch. # 虽然这并不容易，因为你不是 Python 之父（这里的 Dutch 是指 Guido） Now is better than never. Although never is often better than right now. # 做也许好过不做，但不假思索就动手还不如不做（动手之前要细思量） If the implementation is hard to explain, it’s a bad idea. # 如果你无法向人描述你的方案，那肯定不是一个好方案 If the implementation is easy to explain, it may be a good idea. # 如果你能向人简洁描述你的方案，那也许是一个好方案（方案测评标准） Namespaces are one honking great idea – let’s do more of those! # 命名空间是一种绝妙的理念，我们应当多加利用（倡导与号召） 这首特别的 “诗” 开始作为一个笑话，但它确实包含了很多关于 Python 背后的哲学真理。Python 之禅已经正式成文 PEP 20，具体内容见：PEP 20 ","date":"2020-01-16","objectID":"/python%E4%B9%8B%E7%A6%85/:2:0","tags":["Python"],"title":"Python之禅","uri":"/python%E4%B9%8B%E7%A6%85/"},{"categories":["学习记录"],"content":"这几天整理了大学期间的书籍，发现了当时选修日语课时自己总结打印出来的的日语五十音巧记，现在看到还有点好笑，不过当时确实帮助自己应付过了期末考试。直到现在两年过去了，自己还是可以背出日语五十音前面几十个，这里就记录一下吧，万一以后有用呢 ^.^ ","date":"2020-01-05","objectID":"/%E6%97%A5%E8%AF%AD%E4%BA%94%E5%8D%81%E9%9F%B3%E7%AC%A8%E6%8B%99%E8%AE%B0%E5%BF%86/:0:0","tags":["日语"],"title":"日语五十音笨拙记忆","uri":"/%E6%97%A5%E8%AF%AD%E4%BA%94%E5%8D%81%E9%9F%B3%E7%AC%A8%E6%8B%99%E8%AE%B0%E5%BF%86/"},{"categories":["学习记录"],"content":"あ行 清音 あア “女” 孩子胖 “了” 一圈, 惨叫了一声 “啊 (a)” いイ 平假名い和片假名イ拼在一起就会组成一个汉字 “以 (i)\"，读音也是以 うウ 平假名う很像字母 W 横过来,“屋 (u)”, 片假名ウ像“家” 字的宝盖头, 有家有房 “屋” えエ “元” 朝的 “工” 人很悲 “哀 (e)” おオ 有学 “术” 的“才”子都很 “傲(o)” 气 ","date":"2020-01-05","objectID":"/%E6%97%A5%E8%AF%AD%E4%BA%94%E5%8D%81%E9%9F%B3%E7%AC%A8%E6%8B%99%E8%AE%B0%E5%BF%86/:1:0","tags":["日语"],"title":"日语五十音笨拙记忆","uri":"/%E6%97%A5%E8%AF%AD%E4%BA%94%E5%8D%81%E9%9F%B3%E7%AC%A8%E6%8B%99%E8%AE%B0%E5%BF%86/"},{"categories":["学习记录"],"content":"か行 清音 浊音 かカ 因为被 “卡 (ka)” 住了，所以要多用 “一点”” 力 \" ga( が ガ) きキ 长得像琵琶, 琵琶调音 key(ki) gi( ぎ ギ) くク 小时候 “小于” 别人, 长大后终于 “大于” 别人, 感动的要 “哭(ku)” 了 gu( ぐ グ) けケ “开 (ke)” 了一 “个” 豆 “汁” 店 ge( げ ゲ) こコ “扣 (ko)” 了“两条鱼” 放在鱼篓里 go( ご ゴ) ","date":"2020-01-05","objectID":"/%E6%97%A5%E8%AF%AD%E4%BA%94%E5%8D%81%E9%9F%B3%E7%AC%A8%E6%8B%99%E8%AE%B0%E5%BF%86/:2:0","tags":["日语"],"title":"日语五十音笨拙记忆","uri":"/%E6%97%A5%E8%AF%AD%E4%BA%94%E5%8D%81%E9%9F%B3%E7%AC%A8%E6%8B%99%E8%AE%B0%E5%BF%86/"},{"categories":["学习记录"],"content":"さ行 清音 浊音 さサ 一个人弯着腿跪在 “艹” 上面, 是不是很 “傻 (sa)” za( ざ ザ) しシ 用 “吸管” 喝水,“吸(shi)” 出来“三点水 ji( じ ジ) すス 一个人上吊 “又”\" 苏 (su)\" 醒了 zu( ず ズ) せセ 世界被 “塞 (se)” 得满满的 ze( ぜ ゼ) そソ 一位艺人比起了 V 字 “手 (so)” zo( ぞ ゾ) ","date":"2020-01-05","objectID":"/%E6%97%A5%E8%AF%AD%E4%BA%94%E5%8D%81%E9%9F%B3%E7%AC%A8%E6%8B%99%E8%AE%B0%E5%BF%86/:3:0","tags":["日语"],"title":"日语五十音笨拙记忆","uri":"/%E6%97%A5%E8%AF%AD%E4%BA%94%E5%8D%81%E9%9F%B3%E7%AC%A8%E6%8B%99%E8%AE%B0%E5%BF%86/"},{"categories":["学习记录"],"content":"た行 清音 浊音 たタ “他 (ta)” 在半夜 “十二” 点的 “夕” 阳下 da( だ ダ) ちチ “吃 (chi)“5 千个包子 ji( ぢ ヂ) つツ 好 “粗 (tsu)” 的一根绳子打了三个结 zu( づ ヅ) てテ 路人 “乙” 撞到了 “行” 人老 “太太 (te)” de( で デ) とト “丫” 头 “拖 (to)” 着一个萝 “卜” do( ど ド) ","date":"2020-01-05","objectID":"/%E6%97%A5%E8%AF%AD%E4%BA%94%E5%8D%81%E9%9F%B3%E7%AC%A8%E6%8B%99%E8%AE%B0%E5%BF%86/:4:0","tags":["日语"],"title":"日语五十音笨拙记忆","uri":"/%E6%97%A5%E8%AF%AD%E4%BA%94%E5%8D%81%E9%9F%B3%E7%AC%A8%E6%8B%99%E8%AE%B0%E5%BF%86/"},{"categories":["学习记录"],"content":"な行 清音 なナ 把 “十三” 算成了 “十” 也太木 “讷 (na)” 了 にニ “你 (ni)” 是 “仁” 者 “二” 心 ぬヌ “奴 (nu)” 隶制度 “又” 出现了 ねネ 有了 “权” 利的奶 (n) 奶是 “福” 气 のノ “NO(no)““0\"和\"1” ","date":"2020-01-05","objectID":"/%E6%97%A5%E8%AF%AD%E4%BA%94%E5%8D%81%E9%9F%B3%E7%AC%A8%E6%8B%99%E8%AE%B0%E5%BF%86/:5:0","tags":["日语"],"title":"日语五十音笨拙记忆","uri":"/%E6%97%A5%E8%AF%AD%E4%BA%94%E5%8D%81%E9%9F%B3%E7%AC%A8%E6%8B%99%E8%AE%B0%E5%BF%86/"},{"categories":["学习记录"],"content":"は行 清音 浊音 半浊音 はハ “哈 (ha)” 八巴狗打 “仗” ba( ば バ) pa( ぱ パ) ひヒ “黑 (hi)” 色的 “U” 型 “匕” 首 bi( び ビ) pi( ぴ ピ) ふフ “小”” 夫 (fu)“子玩” 飞刀 \" bu( ぶ ブ) pu( ぷ プ) へヘ 太 “嗨 (he)” 了两个眼睛都笑弯了 be( べ ベ) pe( ぺ ペ) ほホ 对着 “木” 头 “‘吼 (ho)” 了 “一天” bo( ぼ ボ) po( ぽ ポ) ","date":"2020-01-05","objectID":"/%E6%97%A5%E8%AF%AD%E4%BA%94%E5%8D%81%E9%9F%B3%E7%AC%A8%E6%8B%99%E8%AE%B0%E5%BF%86/:6:0","tags":["日语"],"title":"日语五十音笨拙记忆","uri":"/%E6%97%A5%E8%AF%AD%E4%BA%94%E5%8D%81%E9%9F%B3%E7%AC%A8%E6%8B%99%E8%AE%B0%E5%BF%86/"},{"categories":["学习记录"],"content":"ま行 清音 まマ “天” 天玩 “飞刀”” 吗 (ma)” みミ “三” 个 “H”” 眯 (mi)” 着眼 むム “跪在” 木 (mu)“头上上吊” 么 \" めメ 一个 “女” 的被 × 后被 “灭 (me)\" 了 もモ “七” 个 “毛” 子有阴 “谋 (mo)” ","date":"2020-01-05","objectID":"/%E6%97%A5%E8%AF%AD%E4%BA%94%E5%8D%81%E9%9F%B3%E7%AC%A8%E6%8B%99%E8%AE%B0%E5%BF%86/:7:0","tags":["日语"],"title":"日语五十音笨拙记忆","uri":"/%E6%97%A5%E8%AF%AD%E4%BA%94%E5%8D%81%E9%9F%B3%E7%AC%A8%E6%8B%99%E8%AE%B0%E5%BF%86/"},{"categories":["学习记录"],"content":"や行 清音 やヤ 两个 “牙 (ya)”\" 也 \" 坏了 ゆユ “有 (yu)”\" 一串糖葫芦 “用” 长篓子 \" 装起来 よヨ “哟 (yo)” “支” 付宝 “扫” 码 ","date":"2020-01-05","objectID":"/%E6%97%A5%E8%AF%AD%E4%BA%94%E5%8D%81%E9%9F%B3%E7%AC%A8%E6%8B%99%E8%AE%B0%E5%BF%86/:8:0","tags":["日语"],"title":"日语五十音笨拙记忆","uri":"/%E6%97%A5%E8%AF%AD%E4%BA%94%E5%8D%81%E9%9F%B3%E7%AC%A8%E6%8B%99%E8%AE%B0%E5%BF%86/"},{"categories":["学习记录"],"content":"ら行 清音 らラ “今” 天 “5” 个人 “拉 (ra)” 肚子 りリ 两个像 “立 (ri)” 刀旁 “刂” るル “路 (ru)” 上遇到 “儿” 子 “歹” 徒 れレ 有 “机” 会 “来 (re)” 要 “勾” 住 ろロ “3” 万人 “口” 好 “low(ro)” ","date":"2020-01-05","objectID":"/%E6%97%A5%E8%AF%AD%E4%BA%94%E5%8D%81%E9%9F%B3%E7%AC%A8%E6%8B%99%E8%AE%B0%E5%BF%86/:9:0","tags":["日语"],"title":"日语五十音笨拙记忆","uri":"/%E6%97%A5%E8%AF%AD%E4%BA%94%E5%8D%81%E9%9F%B3%E7%AC%A8%E6%8B%99%E8%AE%B0%E5%BF%86/"},{"categories":["学习记录"],"content":"わ行 清音 わワ “水箱的底儿没了”, 水 “哇 (wa)” 的全漏光了 をヲ 龙 “哦 (o)” ","date":"2020-01-05","objectID":"/%E6%97%A5%E8%AF%AD%E4%BA%94%E5%8D%81%E9%9F%B3%E7%AC%A8%E6%8B%99%E8%AE%B0%E5%BF%86/:10:0","tags":["日语"],"title":"日语五十音笨拙记忆","uri":"/%E6%97%A5%E8%AF%AD%E4%BA%94%E5%8D%81%E9%9F%B3%E7%AC%A8%E6%8B%99%E8%AE%B0%E5%BF%86/"},{"categories":["学习记录"],"content":"拨音 清音 んン “摁 (n)’” 两下 ““铃铛” ","date":"2020-01-05","objectID":"/%E6%97%A5%E8%AF%AD%E4%BA%94%E5%8D%81%E9%9F%B3%E7%AC%A8%E6%8B%99%E8%AE%B0%E5%BF%86/:11:0","tags":["日语"],"title":"日语五十音笨拙记忆","uri":"/%E6%97%A5%E8%AF%AD%E4%BA%94%E5%8D%81%E9%9F%B3%E7%AC%A8%E6%8B%99%E8%AE%B0%E5%BF%86/"},{"categories":["操作系统","终端工具"],"content":"Homebrew 简介 Homebrew 是一款 MacOS 平台下的软件包管理工具，拥有安装、卸载、更新、查看、搜索等很多实用的功能。简单的一条指令，就可以实现包管理，而不用你关心各种依赖和文件路径的情况，十分方便快捷。 Homebrew 的几个核心概念 在正式介绍 Homebrew 的使用之前，我先为你介绍一下 Homebrew 中的一些核心的概念，了解这些概念，就可以帮助你更好的去使用 Homebrew。 词汇 含义 formula (e) 安装包的描述文件，formulae 为复数 cellar 安装好后所在的目录 keg 具体某个包所在的目录，keg 是 cellar 的子目录 bottle 预先编译好的包，不需要现场下载编译源码，速度会快很多；官方库中的包大多都是通过 bottle 方式安装 tap 下载源，可以类比于 Linux 下的包管理器 repository cask 安装 macOS native 应用的扩展，你也可以理解为有图形化界面的应用。 bundle 描述 Homebrew 依赖的扩展 Homebrew 安装 将以下命令粘贴至终端，回车运行 /bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install.sh)\" 如果出现 curl: (7) Failed to connect to raw.githubusercontent.com port 443:xxx，应该是被墙了，挂上梯子即可 export https_proxy=http://127.0.0.1:7890 http_proxy=http://127.0.0.1:7890 all_proxy=socks5://127.0.0.1:7890 Homebrew 更换国内源 ","date":"2020-01-05","objectID":"/macos%E8%BD%AF%E4%BB%B6%E5%8C%85%E7%9A%84%E7%AE%A1%E7%90%86%E5%99%A8homebrew/:0:0","tags":[""],"title":"MacOS软件包的管理器Homebrew","uri":"/macos%E8%BD%AF%E4%BB%B6%E5%8C%85%E7%9A%84%E7%AE%A1%E7%90%86%E5%99%A8homebrew/"},{"categories":["操作系统","终端工具"],"content":"替换默认源 # 步骤一：替换 brew.git cd \"$(brew --repo)\" git remote set-url origin https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/brew.git # 步骤二：替换 homebrew-core.git cd \"$(brew --repo)/Library/Taps/homebrew/homebrew-core\" git remote set-url origin https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/homebrew-core.git #步骤三 brew update ","date":"2020-01-05","objectID":"/macos%E8%BD%AF%E4%BB%B6%E5%8C%85%E7%9A%84%E7%AE%A1%E7%90%86%E5%99%A8homebrew/:1:0","tags":[""],"title":"MacOS软件包的管理器Homebrew","uri":"/macos%E8%BD%AF%E4%BB%B6%E5%8C%85%E7%9A%84%E7%AE%A1%E7%90%86%E5%99%A8homebrew/"},{"categories":["操作系统","终端工具"],"content":"替换 Homebrew Bottles 源 Homebrew 是 OS X 系统的一款开源的包管理器。出于节省时间的考虑，Homebrew 默认从 Homebrew Bottles 源中下载二进制代码包安装。Homebrew Bottles 是 Homebrew 提供的二进制代码包，目前镜像站收录了以下仓库： homebrew/homebrew-core homebrew/homebrew-dupes homebrew/homebrew-games homebrew/homebrew-gui homebrew/homebrew-python homebrew/homebrew-php homebrew/homebrew-science homebrew/homebrew-versions homebrew/homebrew-x11 # 根据自己使用的 shell echo 'export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.tuna.tsinghua.edu.cn/homebrew-bottles' \u003e\u003e ~/.bash_profile # 使配置生效 source ~/.bash_profile 复原默认源 # 步骤一 cd \"$(brew --repo)\" git remote set-url origin https://github.com/Homebrew/brew.git # 步骤二 cd \"$(brew --repo)/Library/Taps/homebrew/homebrew-core\" git remote set-url origin https://github.com/Homebrew/homebrew-core # 步骤三 brew update Homebrew 常用命令 ","date":"2020-01-05","objectID":"/macos%E8%BD%AF%E4%BB%B6%E5%8C%85%E7%9A%84%E7%AE%A1%E7%90%86%E5%99%A8homebrew/:2:0","tags":[""],"title":"MacOS软件包的管理器Homebrew","uri":"/macos%E8%BD%AF%E4%BB%B6%E5%8C%85%E7%9A%84%E7%AE%A1%E7%90%86%E5%99%A8homebrew/"},{"categories":["操作系统","终端工具"],"content":"安装卸载软件 brew --version 或者 brew -v 显示 brew 版本信息 brew install 安装指定软件 brew unistall 卸载指定软件 brew list 显示所有的已安装的软件 brew search text 搜索本地远程仓库的软件，已安装会显示绿色的勾 brew search /text/ 使用正则表达式搜软件 ","date":"2020-01-05","objectID":"/macos%E8%BD%AF%E4%BB%B6%E5%8C%85%E7%9A%84%E7%AE%A1%E7%90%86%E5%99%A8homebrew/:3:0","tags":[""],"title":"MacOS软件包的管理器Homebrew","uri":"/macos%E8%BD%AF%E4%BB%B6%E5%8C%85%E7%9A%84%E7%AE%A1%E7%90%86%E5%99%A8homebrew/"},{"categories":["操作系统","终端工具"],"content":"升级软件相关 brew update 自动升级 homebrew（从 github 下载最新版本） brew outdated 检测已经过时的软件 brew upgrade 升级所有已过时的软件，即列出的以过时软件 brew upgrade 升级指定的软件 brew pin 禁止指定软件升级 brew unpin 解锁禁止升级 brew upgrade --all 升级所有的软件包，包括未清理干净的旧版本的包 ","date":"2020-01-05","objectID":"/macos%E8%BD%AF%E4%BB%B6%E5%8C%85%E7%9A%84%E7%AE%A1%E7%90%86%E5%99%A8homebrew/:4:0","tags":[""],"title":"MacOS软件包的管理器Homebrew","uri":"/macos%E8%BD%AF%E4%BB%B6%E5%8C%85%E7%9A%84%E7%AE%A1%E7%90%86%E5%99%A8homebrew/"},{"categories":["操作系统","终端工具"],"content":"清理相关 brew cleanup -n 列出需要清理的内容 brew cleanup 清理指定的软件过时包 brew cleanup 清理所有的过时软件 brew unistall 卸载指定软件 brew unistall --force 彻底卸载指定软件，包括旧版本 ","date":"2020-01-05","objectID":"/macos%E8%BD%AF%E4%BB%B6%E5%8C%85%E7%9A%84%E7%AE%A1%E7%90%86%E5%99%A8homebrew/:5:0","tags":[""],"title":"MacOS软件包的管理器Homebrew","uri":"/macos%E8%BD%AF%E4%BB%B6%E5%8C%85%E7%9A%84%E7%AE%A1%E7%90%86%E5%99%A8homebrew/"},{"categories":["操作系统","终端工具"],"content":"服务相关 brew services start mysql 启动 Mysql brew services stop mysql 停止 Mysql brew services restart mysql 重启 Mysql brew services list 查看启动列表 ","date":"2020-01-05","objectID":"/macos%E8%BD%AF%E4%BB%B6%E5%8C%85%E7%9A%84%E7%AE%A1%E7%90%86%E5%99%A8homebrew/:6:0","tags":[""],"title":"MacOS软件包的管理器Homebrew","uri":"/macos%E8%BD%AF%E4%BB%B6%E5%8C%85%E7%9A%84%E7%AE%A1%E7%90%86%E5%99%A8homebrew/"},{"categories":["终端工具"],"content":"SSH 简介 SSH 为 Secure Shell 的缩写，由 IETF 的网络小组（Network Working Group）所制定；SSH 为建立在应用层基础上的安全协议。SSH 是目前较可靠，专为远程登录会话和其他网络服务提供安全性的协议。利用 SSH 协议可以有效防止远程管理过程中的信息泄露问题。SSH 最初是 UNIX 系统上的一个程序，后来又迅速扩展到其他操作平台。SSH 在正确使用时可弥补网络中的漏洞。SSH 客户端适用于多种平台。几乎所有 UNIX 平台—包括 HP-UX、Linux、AIX、Solaris、Digital UNIX、Irix，以及其他平台，都可运行 SSH。SSH 登录提供两种认证方式：口令 (密码) 认证方式和密钥认证方式。其中口令 (密码) 认证方式是我们最常用的一种，这里介绍密钥认证方式登录到 linux/unix 的方法。 ","date":"2019-10-09","objectID":"/ssh%E7%9B%B8%E5%85%B3%E7%9A%84%E5%BF%AB%E9%80%9F%E9%85%8D%E7%BD%AE/:1:0","tags":["ssh"],"title":"SSH 相关的快速配置","uri":"/ssh%E7%9B%B8%E5%85%B3%E7%9A%84%E5%BF%AB%E9%80%9F%E9%85%8D%E7%BD%AE/"},{"categories":["终端工具"],"content":"SSH 服务器之间免密登陆配置 ","date":"2019-10-09","objectID":"/ssh%E7%9B%B8%E5%85%B3%E7%9A%84%E5%BF%AB%E9%80%9F%E9%85%8D%E7%BD%AE/:2:0","tags":["ssh"],"title":"SSH 相关的快速配置","uri":"/ssh%E7%9B%B8%E5%85%B3%E7%9A%84%E5%BF%AB%E9%80%9F%E9%85%8D%E7%BD%AE/"},{"categories":["终端工具"],"content":"生成密钥（公钥和私钥） cd $HOME/.ssh ssh-keygen -t rsa # 全部回车默认 参数 -t rsa 表示使用 rsa 算法进行加密，执行后，会在 / home / 当前用户 /.ssh 目录下找到 id_rsa（私钥）和 id_rsa.pub（公钥） ","date":"2019-10-09","objectID":"/ssh%E7%9B%B8%E5%85%B3%E7%9A%84%E5%BF%AB%E9%80%9F%E9%85%8D%E7%BD%AE/:2:1","tags":["ssh"],"title":"SSH 相关的快速配置","uri":"/ssh%E7%9B%B8%E5%85%B3%E7%9A%84%E5%BF%AB%E9%80%9F%E9%85%8D%E7%BD%AE/"},{"categories":["终端工具"],"content":"放置公钥到目标服务器中 cat id_rsa.pub 复制 id_rsa.pub 内的公钥，登陆到目标服务器 cd $HOME/.ssh vi authorized_keys 将复制的公钥粘贴到 authorized_keys 中，authorized_keys 存放远程免密登录的公钥，主要通过这个文件记录多台机器的公钥 以上的步骤就已经完成了 SSH 服务器之间的免密登陆。不过有的场景是一台跳板机和多台服务器完成了 SSH 免密传输，此时想换一台电脑管理这些服务器，可以将之前的跳板机私钥拷贝到新电脑中。 ssh-add ~/.ssh/id_rsa # id_rsa 为之前跳板机的私钥 如果出现提示 Could not open a connection to your authentication agent., 运行如下命令 ssh-agent bash ","date":"2019-10-09","objectID":"/ssh%E7%9B%B8%E5%85%B3%E7%9A%84%E5%BF%AB%E9%80%9F%E9%85%8D%E7%BD%AE/:2:2","tags":["ssh"],"title":"SSH 相关的快速配置","uri":"/ssh%E7%9B%B8%E5%85%B3%E7%9A%84%E5%BF%AB%E9%80%9F%E9%85%8D%E7%BD%AE/"},{"categories":["终端工具"],"content":"GitHub 的免密传输 ","date":"2019-10-09","objectID":"/ssh%E7%9B%B8%E5%85%B3%E7%9A%84%E5%BF%AB%E9%80%9F%E9%85%8D%E7%BD%AE/:3:0","tags":["ssh"],"title":"SSH 相关的快速配置","uri":"/ssh%E7%9B%B8%E5%85%B3%E7%9A%84%E5%BF%AB%E9%80%9F%E9%85%8D%E7%BD%AE/"},{"categories":["终端工具"],"content":"SSH 的免密传输 connecting-to-github-with-ssh 登陆到 Github 中，进入个人设置 提交服务器 SSH 公钥 选择 SSH and GPG keys，粘贴你的服务器公钥 切换项目的传输方式 # （以 HTTPS 切换成 SSH 为例） git remote remove origin git remote add origin git@github.com:Username/Your_Repo_Name.git # 重新设置 track branch git branch --set-upstream-to=origin/master master ","date":"2019-10-09","objectID":"/ssh%E7%9B%B8%E5%85%B3%E7%9A%84%E5%BF%AB%E9%80%9F%E9%85%8D%E7%BD%AE/:3:1","tags":["ssh"],"title":"SSH 相关的快速配置","uri":"/ssh%E7%9B%B8%E5%85%B3%E7%9A%84%E5%BF%AB%E9%80%9F%E9%85%8D%E7%BD%AE/"},{"categories":["终端工具"],"content":"HTTPS 的免密传输 目前都是配置token了 新建文件 vi $HOME/.git-credentials 添加以下内容 # （GitHub 为 github.com，码云为 gitee.com） https://{username}:{password}@github.com 添加 git 配置 git config --global credential.helper store 查看是否添加成功 # 查看 $HOME/.gitconfig 文件，会发现出现一下内容 [credential] helper = store 这样设置存在一定风险，因为密码是明文存放在这个文件里的，比较容易泄露 ","date":"2019-10-09","objectID":"/ssh%E7%9B%B8%E5%85%B3%E7%9A%84%E5%BF%AB%E9%80%9F%E9%85%8D%E7%BD%AE/:3:2","tags":["ssh"],"title":"SSH 相关的快速配置","uri":"/ssh%E7%9B%B8%E5%85%B3%E7%9A%84%E5%BF%AB%E9%80%9F%E9%85%8D%E7%BD%AE/"},{"categories":["终端工具"],"content":"进入 Vim 命令 描述 vim filename 打开或新建文件，并将光标置于第一行首 vim +n filename 打开文件，并将光标置于第 n 行首 vim + flename 打开文件, 并将光标置于最后一 - 行首 vim +/pattern filename 打开文件, 并将光标置于第一一个 与 pattern 匹配的串处 vim -r filename 在上次正用 vim 编辑时发生系统崩溃，恢复 flename vim filename… filename 打开多个文件, 依次编辑 ","date":"2019-08-09","objectID":"/vim%E6%93%8D%E4%BD%9C%E9%80%9F%E6%9F%A5/:1:0","tags":null,"title":"Vim操作速查","uri":"/vim%E6%93%8D%E4%BD%9C%E9%80%9F%E6%9F%A5/"},{"categories":["终端工具"],"content":"Vim 配置 命令 描述 all 列出所有选项设置情况 term 设置终端类型 ignorance 在搜索中忽略大小写 list 显示制表位 (Ctrl+I) 和行尾标志( $) number 显示行号 report 显示由面向行的命令修改过的数目 terse 显示简短的警告信息 warn 在转到别的文件时若没保存当前文件则显示 NO write 信息 nomagic 允许 vi 显示其他用户用 write 写到自己终端上的信息 nowrapscan 禁止 vi 在搜索到达文件两端时，又从另 - - 端开始 mesg 允许 vi 显示其他用户用 write 写到自己终端上的信息 :set number/ set nonumber 显示 / 不显示行号 :set ruler /set noruler 显示不显示标尺 :set hlsearch 高亮显示查找到的单词 :sset nohlsearch 关闭高亮显示 :set nu 显示行号 :set tabstop=8 设置 tab 大小，8 为最常用最普遍的设置 :set softabstop=8 4:4 个空格, 8: 正常的制表符，12: 一一个制表符 4 个空格，16: 两个 :set autoindent 自动缩进 :set cindent C 语言格式里面的自动缩进 ","date":"2019-08-09","objectID":"/vim%E6%93%8D%E4%BD%9C%E9%80%9F%E6%9F%A5/:2:0","tags":null,"title":"Vim操作速查","uri":"/vim%E6%93%8D%E4%BD%9C%E9%80%9F%E6%9F%A5/"},{"categories":["终端工具"],"content":"移动光标 命令 描述 k nk 上向上移动 n 行 j nj 下向下移动 n 行 h nh 左向左移动 n 行 I nl 右向右移动 n 行 Space 光标右移一个字符 Backspace 光标左移一个字符 Enter 光标下移一行 w/W 光标右移一个字至字首 b/B 光标左移一个字至字首 e 或 E 光标右移一个字至字尾 ) 光标移至句尾 ( 光标移至句首 } 光标移至句首 { 光标移至段落结尾 n$ 光标移至第 n 行尾 H 光标移至屏幕顶行 M 光标移至屏幕中间行 L 光标移至屏幕最后行 0 (注意是数字零) 光标移至当前行首 ^ 移动光标到行首第一个非空字符上去 $ 光标移至当前行尾 gg 移到第一行 G 移到最后一行 f 移动光标到当前行的字符 a 上 F 相反 % 移动到与制匹配的括号上去 () ,{},[],\u003c\u003e 等 nG 移动到第 n 行上 G 到最后一行 ","date":"2019-08-09","objectID":"/vim%E6%93%8D%E4%BD%9C%E9%80%9F%E6%9F%A5/:3:0","tags":null,"title":"Vim操作速查","uri":"/vim%E6%93%8D%E4%BD%9C%E9%80%9F%E6%9F%A5/"},{"categories":["终端工具"],"content":"屏幕滚动 命令 描述 Ctrl+u 向文件首翻半屏 Ctrl+d 向文件尾翻半屏 Ctrl+f 向文件尾翻一屏 Ctrl+ b 向文件首翻一屏 nz 将第 n 行滚至屏幕顶部, 不指定 n 时将当前行滚至屏幕顶部 ","date":"2019-08-09","objectID":"/vim%E6%93%8D%E4%BD%9C%E9%80%9F%E6%9F%A5/:4:0","tags":null,"title":"Vim操作速查","uri":"/vim%E6%93%8D%E4%BD%9C%E9%80%9F%E6%9F%A5/"},{"categories":["终端工具"],"content":"插入文本类 命令 描述 i 在光标前 I 在当前行首 a 光标后 A 在当前行尾 o 在当前行之下新开一行 O 在当前行之上新开一行 r 替换当前字符 R 替换当前字符及其后的字符, 直至按 ESC 键 s 从当前光标位置处开始, 以输入的文本替代指定数目的字符 S 删除指定数目的行, 并以所输入文本代替之 ncw/nCW 修改指定数目的字 nCC 修改指定数目的行 ","date":"2019-08-09","objectID":"/vim%E6%93%8D%E4%BD%9C%E9%80%9F%E6%9F%A5/:5:0","tags":null,"title":"Vim操作速查","uri":"/vim%E6%93%8D%E4%BD%9C%E9%80%9F%E6%9F%A5/"},{"categories":["终端工具"],"content":"删除命令 命令 描述 x/X 删除 - 个字符, x 删除光标后的, 而 X 删除光标前的 dw 删除一个单词 (删除光标位置到下一个单词开始的位置) dnw 删除 n 个单词 dne 也可，只是删除到单词尾 do 删至行首 d$ 删至行尾 dd 删除一行 ndd 删除当前行及其后 n-1 行 dnl 向右删除 n 个字母 dnh 向左删除 n 个字母 dnj 向下删除 n 行，当前行 + 其上 n 行 dnk 向上删除 n 行，当期行 + 其下 n 行 cnw[word] 将 n 个 word 改变为 word C$ 改变到行尾 cc 改变整行 shift+j 删除行尾的换行符，下一行接上来了 ","date":"2019-08-09","objectID":"/vim%E6%93%8D%E4%BD%9C%E9%80%9F%E6%9F%A5/:6:0","tags":null,"title":"Vim操作速查","uri":"/vim%E6%93%8D%E4%BD%9C%E9%80%9F%E6%9F%A5/"},{"categories":["终端工具"],"content":"复制粘贴 命令 描述 p 粘贴用 x 或 d 删除的文本 ynw 复制 n 个单词 yy 复制一行 ynl 复制 n 个字符 y$ 复制当前光标至行尾处 Nay 拷贝 n 行 ","date":"2019-08-09","objectID":"/vim%E6%93%8D%E4%BD%9C%E9%80%9F%E6%9F%A5/:7:0","tags":null,"title":"Vim操作速查","uri":"/vim%E6%93%8D%E4%BD%9C%E9%80%9F%E6%9F%A5/"},{"categories":["终端工具"],"content":"撤销 命令 描述 u 撤销前一 - 次的操作 shif+u(U) 撤销对该行的所有操作 ","date":"2019-08-09","objectID":"/vim%E6%93%8D%E4%BD%9C%E9%80%9F%E6%9F%A5/:8:0","tags":null,"title":"Vim操作速查","uri":"/vim%E6%93%8D%E4%BD%9C%E9%80%9F%E6%9F%A5/"},{"categories":["终端工具"],"content":"搜索及替换 命令 描述 /pattern 从光标开始处向文件尾搜索 pattern ?pattern 从光标开始处向文件首搜索 pattern n 在同 - - 方向重复上 - - 次搜索命令 N 在反方向上重复上一 - 次搜索命令 cw newword 替换为 newword n 继续查找 . 执行替换 :s/p1/p2/g 将当前行中所有 p1 均用 p2 替代，g 表示执行用 c 表示需要确认 :n1,n2 s/p1/p2/g 将第 n1 至 n2 行中所有 p1 均用 p2 替代 :g/p1/s//p2/g 将文件中所有 p1 均用 p2 替换 :1,$ s/string1/string2/g 在全 文中将 string1 替换为 string2 ","date":"2019-08-09","objectID":"/vim%E6%93%8D%E4%BD%9C%E9%80%9F%E6%9F%A5/:9:0","tags":null,"title":"Vim操作速查","uri":"/vim%E6%93%8D%E4%BD%9C%E9%80%9F%E6%9F%A5/"},{"categories":["终端工具"],"content":"书签 命令 描述 m[a-z] 在文中做标记, 标记号可为 a-z 的 26 个字母 `a 移动到标记 a 处 ","date":"2019-08-09","objectID":"/vim%E6%93%8D%E4%BD%9C%E9%80%9F%E6%9F%A5/:10:0","tags":null,"title":"Vim操作速查","uri":"/vim%E6%93%8D%E4%BD%9C%E9%80%9F%E6%9F%A5/"},{"categories":["终端工具"],"content":"visual 模式 命令 描述 v 进入 visual 模式 V 进入行的 visual 模式 ctrl+v 进如块操作模式用 o 和 O 改变选择的边的大小 在所有行插入相同的内容如 include\u003c 将光标移到开始插入的位置，按 CTRL+V 进入 VISUAL 模式 , 选择好模块后按 I（shift+i），后插入要插入的文本，按 [ESC] 完成 ","date":"2019-08-09","objectID":"/vim%E6%93%8D%E4%BD%9C%E9%80%9F%E6%9F%A5/:11:0","tags":null,"title":"Vim操作速查","uri":"/vim%E6%93%8D%E4%BD%9C%E9%80%9F%E6%9F%A5/"},{"categories":["终端工具"],"content":"行方式命令 命令 描述 :n1,n2 co n3 将 n1 行到 n2 行之间的内容拷贝到第 n3 行下 :n1,n2 m n3 将 n1 行到 n2 行之间的内容移至到第 n3 行下 :n1,n2 d 将 n1 行到 n2 行之间的内容删除 :n1 ,n2 w!command 将文件中 n1 行至 n2 行的内容作为 command 的输入并执行之 若不指定 n1，n2，则表示将整个文件内容作为 command 的输入 ","date":"2019-08-09","objectID":"/vim%E6%93%8D%E4%BD%9C%E9%80%9F%E6%9F%A5/:12:0","tags":null,"title":"Vim操作速查","uri":"/vim%E6%93%8D%E4%BD%9C%E9%80%9F%E6%9F%A5/"},{"categories":["终端工具"],"content":"宏 命令 描述 q[a-z] 开始记录但前开始的操作为宏 , 名称可为 [a-z] , 然后用 q 终止录制宏 reg 显示当前定义的所有的宏, 用 @[a-z] 来在当前光标处执行宏 [a-z] ","date":"2019-08-09","objectID":"/vim%E6%93%8D%E4%BD%9C%E9%80%9F%E6%9F%A5/:13:0","tags":null,"title":"Vim操作速查","uri":"/vim%E6%93%8D%E4%BD%9C%E9%80%9F%E6%9F%A5/"},{"categories":["终端工具"],"content":"窗口操作 命令 描述 :split 分割一个窗口 :split file.c 为另一个文件 file c 分隔窗口 :nsplit file.c 为另一个文件 file c 分隔窗口, 并指定其行数 ctrl+w 在窗口中切换 :close 关闭当前窗口 ","date":"2019-08-09","objectID":"/vim%E6%93%8D%E4%BD%9C%E9%80%9F%E6%9F%A5/:14:0","tags":null,"title":"Vim操作速查","uri":"/vim%E6%93%8D%E4%BD%9C%E9%80%9F%E6%9F%A5/"},{"categories":["终端工具"],"content":"文件及其他 命令 描述 :q 退出 vi :q! 不保存文件并退出 vi :e filename 打开文件 filename 进行编辑 e! 放弃修改文件内容, 重新载入该文件编辑 :w 保存当前文件 :wq 存盘退出 :ZZ 保存当前文档并退出 Vim :!command 执行 shell 命令 command :rlcommand 将命令 command 的输出结果放到当前行 :n1 ,n2 write temp.c :read file.c 将文件 file.c 的内容插入到当前光标所在的下面 ","date":"2019-08-09","objectID":"/vim%E6%93%8D%E4%BD%9C%E9%80%9F%E6%9F%A5/:15:0","tags":null,"title":"Vim操作速查","uri":"/vim%E6%93%8D%E4%BD%9C%E9%80%9F%E6%9F%A5/"},{"categories":["随笔"],"content":"本文只代表个人见解，不代表任立场，如果您认为我的想法是错的那很正常，因为这是我的想法，如果您觉得您的想法和我一样，那我们就是传说中的 “激友”（对生活冲满激情的朋友）。进入正题。 ","date":"2019-08-09","objectID":"/%E4%BD%9C%E4%B8%BA%E6%8A%80%E6%9C%AF%E4%BA%BA%E5%91%98%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%86%99%E5%8D%9A%E5%AE%A2/:0:0","tags":[""],"title":"作为技术人员为什么要写博客","uri":"/%E4%BD%9C%E4%B8%BA%E6%8A%80%E6%9C%AF%E4%BA%BA%E5%91%98%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%86%99%E5%8D%9A%E5%AE%A2/"},{"categories":["随笔"],"content":"一、我心中的博客 我所以指的写博客，不单只是写一篇文章出来这一结果。而应该是写的这一过程，写过技术文章的朋友应该跟我一样有这么一个过程。 自己了解学习，文章所涉及到的知识点，及知识点衍生出来的知识点。 对学习的知识点进行验证，以确保理论值与实践值保持一致。 构思文章的大纲，哪些部分需要重点写，需要配合实例代码，图片等信息。 动手写，写完后再次检查校正并排版，然后发表。 针对网友的评论中提出的问题进行回复 我写文章一般都会经历以上 5 上步，最终以上 5 步融合成一个结果那就是 “一篇文章” 这一过程也是我心中对的 “写博客” 一词的诠释 ","date":"2019-08-09","objectID":"/%E4%BD%9C%E4%B8%BA%E6%8A%80%E6%9C%AF%E4%BA%BA%E5%91%98%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%86%99%E5%8D%9A%E5%AE%A2/:1:0","tags":[""],"title":"作为技术人员为什么要写博客","uri":"/%E4%BD%9C%E4%B8%BA%E6%8A%80%E6%9C%AF%E4%BA%BA%E5%91%98%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%86%99%E5%8D%9A%E5%AE%A2/"},{"categories":["随笔"],"content":"二、为什么要写博客 ","date":"2019-08-09","objectID":"/%E4%BD%9C%E4%B8%BA%E6%8A%80%E6%9C%AF%E4%BA%BA%E5%91%98%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%86%99%E5%8D%9A%E5%AE%A2/:2:0","tags":[""],"title":"作为技术人员为什么要写博客","uri":"/%E4%BD%9C%E4%B8%BA%E6%8A%80%E6%9C%AF%E4%BA%BA%E5%91%98%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%86%99%E5%8D%9A%E5%AE%A2/"},{"categories":["随笔"],"content":"为自己 写博客对自己的提升是很大的，可能写一篇体现不出来，但是只要你坚持写效果就很明显，好处人个认为有以下几点 强化知识点 在写一篇文章前，你必定是要把以文章中心为主的知识点及衍生的知识点都详细了解一篇，在这一过程中必须会涉及到自己以前所了解过的知识。 人的记忆是存在记忆曲线的需要不断的重复记忆才能长久的记住某一事物，而每写一篇文章时都会查阅资料，在这一过程中必然会遇到以前记住了而现在渐渐淡忘的知识点。 当你再次看到时瞬间就会回想起，此时以前的知识点就得到了强化。 提升学习能力 同一样的人，了解同一知识点，用不同的方法，产生的结果必然会不一样。 找到最佳的学习方法，这也是一种能力，这种能力是经过多次实践探索之后总结出来的。 以前我每次需了解某一种技术时都会先百度看各种搜索结果，发现没有想要的之后，再 Google 因为 Google 的结果与百度的会有所不同，Google 结果中国外的文章相对会多一点。 而偶然点了一个链接进入了博客园，发现就是自己想要的东西，而且把概念，代码，及经验都写上去了，看完之后对我帮助很大。 渐渐的我便开始采这种方法了解新知识概念性的直接看百度百科，实质性的直接 上博客园的 找找看 。 群里的朋友还推荐了一种方法，比如我要学 MVC 园子里很多人都写了 关于 MVC 的一系列文章，把那一系列的文章都看一遍，对于 MVC 就基本有了了解了，这便是学习能力的提升, 对于某种技术用最短的时间做到了比较全面的了解。 提升文字组织能力 这个就不用说了，写博客，既然是写，就必然会有大量的文字，而如何组织文字表达出自己想表达的意思，是长期练习的，而写博客正好帮助你提高了你的文字组织能力。 提升逻辑思维能力 不用说，技术性的东西从来就没的单独存在的，都一层层技术相结合，那在了解某种技术时，自己的思维也是要顺着这种关系逐渐深入的。 比如 MVC，你不能只知道 M 是什么 V 是什么 C 是什么就行了吧，你得知道 M V C 这三者关系是怎样的，又是怎样交互，而你了解之后再把它写出来时，需要清晰逻辑。 ","date":"2019-08-09","objectID":"/%E4%BD%9C%E4%B8%BA%E6%8A%80%E6%9C%AF%E4%BA%BA%E5%91%98%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%86%99%E5%8D%9A%E5%AE%A2/:2:1","tags":[""],"title":"作为技术人员为什么要写博客","uri":"/%E4%BD%9C%E4%B8%BA%E6%8A%80%E6%9C%AF%E4%BA%BA%E5%91%98%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%86%99%E5%8D%9A%E5%AE%A2/"},{"categories":["随笔"],"content":"为他人 有意的 园子里有很多人都写过关于 MVC 框架 WCF 等等系列文章，目的就在于帮助新人快速上手，这个我深有体会，当初我开始学习 MVC 时就是看的 T2 噬菌体的 MVC 系列文章，整篇看完后再配合自己动手对于 MVC 就有了基本的了解了，在次感谢园子里无私献的大牛们。而以上行为就是有意的帮助。 无意的 很多时候在开发项目的过程中，遇到了技术问题，花了时间解决后，有人会写博客记录，并附上解决方法旨在当再次遇到问题时直接看下文章就知道如何处理了。 而碰巧的是，这种问题不止他一个人遇到了，很多人在开发时也遇到了这个问题。 在网上找答案时，就找到了这篇文章，并根据文章提供的解决方法，顺利的解决了问题，这种帮助就是无意的帮助。 ","date":"2019-08-09","objectID":"/%E4%BD%9C%E4%B8%BA%E6%8A%80%E6%9C%AF%E4%BA%BA%E5%91%98%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%86%99%E5%8D%9A%E5%AE%A2/:2:2","tags":[""],"title":"作为技术人员为什么要写博客","uri":"/%E4%BD%9C%E4%B8%BA%E6%8A%80%E6%9C%AF%E4%BA%BA%E5%91%98%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%86%99%E5%8D%9A%E5%AE%A2/"},{"categories":["随笔"],"content":"三、一定要写博客吗 答案肯定是否定的，中国几百万的程序员，如果都写博客，那程序员的春天就来了，但是事实并非如此。 而我所讲的 写博客 的产物并不只是一篇文章，更多的是，对自己能力的提升，自己对知识点的总结。 而发表在博客上只是为了公开，还有很多人喜欢记录在云笔记里面。还有工作很忙，没有空闲时间写出来，因为写技术性的文章，花的时间是很长的。写过的朋友都知道。 ","date":"2019-08-09","objectID":"/%E4%BD%9C%E4%B8%BA%E6%8A%80%E6%9C%AF%E4%BA%BA%E5%91%98%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%86%99%E5%8D%9A%E5%AE%A2/:3:0","tags":[""],"title":"作为技术人员为什么要写博客","uri":"/%E4%BD%9C%E4%B8%BA%E6%8A%80%E6%9C%AF%E4%BA%BA%E5%91%98%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%86%99%E5%8D%9A%E5%AE%A2/"},{"categories":["随笔"],"content":"四、博客会给你带来哪些收获 古人云：一份耕耘，一份收获 以下这些是帮助他人而得到的一些认可，并非主观上去追求的 MVP：微软每年都颁发 MVP 给那些经常与其他专业人士分享知识和专业技能，受人尊敬、信任，而且平易近人的专家。而这个称号则是对你写的博客质量的肯定。 知名度: 文章写得好的人，技术水平肯定也很好，知道的人多了，知名度就有了，比如园子里排名前 10 的大家都知道，都看过他们的文章。 尊敬：对于技术界的大神，都是受人敬仰的，在园子里或者工作中也是一样的，在心里对大神们都是默默的佩服！至少我是这样啦，哈哈~ 也是我学习的榜样！ ","date":"2019-08-09","objectID":"/%E4%BD%9C%E4%B8%BA%E6%8A%80%E6%9C%AF%E4%BA%BA%E5%91%98%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%86%99%E5%8D%9A%E5%AE%A2/:4:0","tags":[""],"title":"作为技术人员为什么要写博客","uri":"/%E4%BD%9C%E4%B8%BA%E6%8A%80%E6%9C%AF%E4%BA%BA%E5%91%98%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%86%99%E5%8D%9A%E5%AE%A2/"},{"categories":["随笔"],"content":"五、总结 我所认的写博客是对自己所了解知识的强化，分享，自身能力的提升。当然 写 博客只是一种方法而已，只要能达到提升自我的效果什么方法都是可以的。 之前有看过一则新闻：即便没有读者，你也要写博客 ，文章也讲解了很多写博客的好处。 而我写博客是希望，能提升自己的综合能力，并把自己的知识与经验分享给大家，如果有幸我的分享帮助了一些人，那将使我更加欣慰。 最后附上一句名言：有些事情你现在不去做，可能以后都不会有机会了！ 转载自：https://mp.weixin.qq.com/s/gBx0SapuMyOY9Gu6gCoaag 原作者：Zery ","date":"2019-08-09","objectID":"/%E4%BD%9C%E4%B8%BA%E6%8A%80%E6%9C%AF%E4%BA%BA%E5%91%98%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%86%99%E5%8D%9A%E5%AE%A2/:5:0","tags":[""],"title":"作为技术人员为什么要写博客","uri":"/%E4%BD%9C%E4%B8%BA%E6%8A%80%E6%9C%AF%E4%BA%BA%E5%91%98%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%86%99%E5%8D%9A%E5%AE%A2/"},{"categories":["终端工具"],"content":"Tmux 简介 Tmux 的全称是 Terminal MUtipleXer，及终端复用软件。顾名思义，它的主要功能就是用于在一个终端窗口中运行多个终端会话并且在你关闭终端窗口之后保持进程的运行。 Tmux 安装 # Ubuntu 或 Debian $ sudo apt-get install tmux # CentOS 或 Fedora $ sudo yum install tmux # Mac $ brew install tmux Tmux 概念 Tmux 中有几个重要概念： 会话（session）: 建立一个 tmux 工作区会话，会话可以长期驻留，重新连接服务器不会丢失，我们只需重新 tmux attach 到之前的工作区就可以恢复会话 窗口（window）: 容纳多个窗格 窗格（pane）: 可以在窗口中分成多个窗格 Tmux 概念图\" Tmux 概念图 Tmux 基本操作 ","date":"2019-08-04","objectID":"/tmux%E7%9A%84quickstart/:0:0","tags":[""],"title":"Tmux的QuickStart","uri":"/tmux%E7%9A%84quickstart/"},{"categories":["终端工具"],"content":"常用命令 tmux new　创建默认名称的会话 tmux new -s mysession　创建名为 mysession 的会话 tmux ls　显示会话列表 tmux a　连接上一个会话 tmux a -t mysession　连接指定会话 tmux rename -t s1 s2　重命名会话 s1 为 s2 tmux kill-session　关闭上次打开的会话 tmux kill-session -t s1　关闭会话 s1 tmux kill-session -a -t s1　关闭除 s1 外的所有会话 tmux kill-server　关闭所有会话 Tmux 默认的快捷键前缀是 ctrl+b，当然你也可以修改它（后文会提到） 以下所有的操作都是激活控制台之后，即键入 Ctrl+b 前提下才可以使用的命令 ","date":"2019-08-04","objectID":"/tmux%E7%9A%84quickstart/:1:0","tags":[""],"title":"Tmux的QuickStart","uri":"/tmux%E7%9A%84quickstart/"},{"categories":["终端工具"],"content":"会话操作（session） ?　列出所有快捷键；按 q 返回 d　脱离当前会话, 可暂时返回 Shell 界面，输入 tmux attach 能够重新进入之前会话 s　选择并切换会话；在同时开启了多个会话时使用 D　选择要脱离的会话；在同时开启了多个会话时使用 :　进入命令行模式；此时可输入支持的命令，例如 kill-server 所有 tmux 会话 [　复制模式，光标移动到复制内容位置，空格键开始，方向键选择复制，回车确认，q/Esc 退出 ]　进入粘贴模式，粘贴之前复制的内容，按 q/Esc 退出 ~　列出提示信息缓存；其中包含了之前 tmux 返回的各种提示信息 t　显示当前的时间 Ctrl+z　挂起当前会话 ","date":"2019-08-04","objectID":"/tmux%E7%9A%84quickstart/:2:0","tags":[""],"title":"Tmux的QuickStart","uri":"/tmux%E7%9A%84quickstart/"},{"categories":["终端工具"],"content":"窗口操作（window） c　创建新窗口 \u0026　关闭当前窗口 数字键　切换到指定窗口 p　切换至上一窗口 n　切换至下一窗口 l　前后窗口间互相切换 w　通过窗口列表切换窗口 ,　重命名当前窗口，便于识别 .　修改当前窗口编号，相当于重新排序 f　在所有窗口中查找关键词，便于窗口多了切换 ","date":"2019-08-04","objectID":"/tmux%E7%9A%84quickstart/:3:0","tags":[""],"title":"Tmux的QuickStart","uri":"/tmux%E7%9A%84quickstart/"},{"categories":["终端工具"],"content":"面板操作（pane） “　将当前面板上下分屏 %　将当前面板左右分屏 x　关闭当前分屏 !　将当前面板置于新窗口, 即新建一个窗口, 其中仅包含当前面板 Ctrl + 方向键　以 1 个单元格为单位移动边缘以调整当前面板大小 Alt + 方向键　以 5 个单元格为单位移动边缘以调整当前面板大小 空格键　可以在默认面板布局中切换，试试就知道了 q　显示面板编号 o　选择当前窗口中下一个面板 方向键　移动光标选择对应面板 {　向前置换当前面板 }　向后置换当前面板 Alt+o　逆时针旋转当前窗口的面板 Ctrl+o　顺时针旋转当前窗口的面板 z　tmux 1.8 新特性，最大化当前所在面板 Tmux 便捷配置 ","date":"2019-08-04","objectID":"/tmux%E7%9A%84quickstart/:4:0","tags":[""],"title":"Tmux的QuickStart","uri":"/tmux%E7%9A%84quickstart/"},{"categories":["终端工具"],"content":"配置文件 #新建 Tmux 配置文件 vi $HOME/.tmux.conf ** 修改 Tmux 快捷键前缀为 ctrl+s，便于操作 ** #设置前缀 set -g prefix ^s #解除 Ctrl+b 与前缀的对应关系 unbind ^b # split window unbind '\"' # vertical split (prefix -) bind - splitw -v unbind % bind | splitw -h # horizontal split (prefix |) #将 r 设置为加载配置文件，并显示 \"reloaded!\" 信息 bind r source-file ~/.tmux.conf \\; display \"Reloaded!\" #up bind k select-pane -U #down bind j select-pane -D #left bind h select-pane -L #right bind l select-pane -R #kill pane bind q killp setw -g mode-keys vi ","date":"2019-08-04","objectID":"/tmux%E7%9A%84quickstart/:5:0","tags":[""],"title":"Tmux的QuickStart","uri":"/tmux%E7%9A%84quickstart/"},{"categories":["终端工具"],"content":"设置 alias 快捷键 alias ta='tmux a -t' alias tf='tail -f' alias tls='tmux ls' alias tnew='tmux new -s' Oh my tmux 🇫🇷 Oh my tmux! My self-contained, pretty \u0026 versatile tmux configuration made with ❤️ https://github.com/gpakosz/.tmux 更好看、强悍的 tmux 配置，有时间可以研究 使用 Tips ","date":"2019-08-04","objectID":"/tmux%E7%9A%84quickstart/:6:0","tags":[""],"title":"Tmux的QuickStart","uri":"/tmux%E7%9A%84quickstart/"},{"categories":["终端工具"],"content":"跳转 Tmux 窗口号为两位数的窗口 通常使用 Prefix + 数字键 可以跳转到指定窗口，但是窗口号如果是 10，当你按下 1 的时候就已经跳转到 1 号窗口了，可以先使用 Prefix + '，然后输入 index ","date":"2019-08-04","objectID":"/tmux%E7%9A%84quickstart/:7:0","tags":[""],"title":"Tmux的QuickStart","uri":"/tmux%E7%9A%84quickstart/"},{"categories":["学习记录"],"content":"时间复杂度 算法的执行时间与算法输入值之间的的关系，即算法的执行效率 ","date":"2019-07-24","objectID":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%B6%E9%97%B4%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/:1:0","tags":["数据结构"],"title":"数据结构与算法之时间、空间复杂度","uri":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%B6%E9%97%B4%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"},{"categories":["学习记录"],"content":"大 O 表示法 用常数 1 取代运行时间中的所有加法常数。 在修改后的运行次数函数中，只保留最高阶项。 如果最高阶项存在且不是 1，则去除与这个项相乘的常数。得到的结果就是大 O 阶 ","date":"2019-07-24","objectID":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%B6%E9%97%B4%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/:1:1","tags":["数据结构"],"title":"数据结构与算法之时间、空间复杂度","uri":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%B6%E9%97%B4%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"},{"categories":["学习记录"],"content":"常见时间复杂度 O(1) 常数阶 def O1(num): i = num j = num*2 return i + j O(logn) 对数阶 def OlogN(num): i = 1 while (i \u003c num): i = i * 2 return i O(n) 线性阶 def ON(num): total = 0 for i in range(num): total += i return total O(nlogn) nlogn 阶 def ONlogN(num): total = 0 for i in range(num): j = 1 while (j \u003c num): total += i+j j = j * 2 return total O(n^2) 平方阶 def ON2(num): total = 0 for i in range(num): for j in range(num): total += i+j return total ","date":"2019-07-24","objectID":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%B6%E9%97%B4%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/:1:2","tags":["数据结构"],"title":"数据结构与算法之时间、空间复杂度","uri":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%B6%E9%97%B4%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"},{"categories":["学习记录"],"content":"对比 Bid-O 对比\" Bid-O 对比 常用时间复杂度所耗费的时间从小到大依次是： O(1) \u003c O(logn) \u003c O(n) \u003c O(nlogn) \u003c O(n^2) \u003c O(n^3) \u003c O(n!) \u003c O(n^n) 相关文档：Big-O Cheat Sheet ","date":"2019-07-24","objectID":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%B6%E9%97%B4%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/:1:3","tags":["数据结构"],"title":"数据结构与算法之时间、空间复杂度","uri":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%B6%E9%97%B4%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"},{"categories":["学习记录"],"content":"空间复杂度 算法的存储空间与输入值之间的关系，表示方法同样也为大 O 表示法 ","date":"2019-07-24","objectID":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%B6%E9%97%B4%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/:2:0","tags":["数据结构"],"title":"数据结构与算法之时间、空间复杂度","uri":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%B6%E9%97%B4%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"},{"categories":["学习记录"],"content":"常见时间复杂度 O(1) 常数阶 def O1(num): total = 0 for i in range(num): total += i return total O(n) 线性阶 def ON(nums) array = [] for num in nums: array.append(num) return array ","date":"2019-07-24","objectID":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%B6%E9%97%B4%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/:2:1","tags":["数据结构"],"title":"数据结构与算法之时间、空间复杂度","uri":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%B6%E9%97%B4%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"},{"categories":["学习记录"],"content":"如何计算 变量：常量时为 O(1），数组、列表则可能是 O(n)、O(n^2) 递归：递归栈 O(n) ","date":"2019-07-24","objectID":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%B6%E9%97%B4%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/:2:2","tags":["数据结构"],"title":"数据结构与算法之时间、空间复杂度","uri":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%B6%E9%97%B4%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"},{"categories":["学习记录"],"content":"最坏情况与平均情况 最坏情况运行时间是一种保证，那就是运行时间不会再长了。在应用中，这是一种最重要的需求，通常，除非特别指定，我们提到的运行时间都是最坏情况的运行时间。平均运行时间是所有情况中最有意义的，因为它是期望的运行时间。一般没有特殊说明的情况下，时间复杂度都是指最坏时间复杂度。 ","date":"2019-07-24","objectID":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%B6%E9%97%B4%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/:2:3","tags":["数据结构"],"title":"数据结构与算法之时间、空间复杂度","uri":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%B6%E9%97%B4%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"},{"categories":["学习记录"],"content":"如何衡量时间 / 空间复杂度 时间和空间复杂度只能二选一 牺牲时间换空间 牺牲空间换时间 通常是优先选择时间复杂度更好的 ","date":"2019-07-24","objectID":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%B6%E9%97%B4%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/:3:0","tags":["数据结构"],"title":"数据结构与算法之时间、空间复杂度","uri":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%B6%E9%97%B4%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"},{"categories":null,"content":"Tip 现就职于一家武汉 SaaS 服务公司，担任服务端开发工程师，主要面向 B 端 不使用抖音、微博 不要复读机重复多次 尊重你的想法，但是对我洗脑 别戳电脑屏幕 ","date":"0001-01-01","objectID":"/about/:0:0","tags":null,"title":"About","uri":"/about/"}]