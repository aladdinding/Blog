[{"categories":["系统设计"],"content":" 单例模式 是保证一个类仅有一个实例，并提供一个访问它的全局访问点。 简单工厂模式 通过专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。 工厂方法模式 定义一个创建产品对象的工厂接口，将实际创建工作推迟到子类中。 抽象工厂模式 提供一个创建一系列相关或者相互依赖的接口，而无需指定它们具体的类。 原型模式 用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。 建造者模式 将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。 简单工厂模式：一个工厂负责创建所有产品（多个类共用一个Create函数） 违反“开闭原则”，添加新产品需要修改工厂逻辑，工厂越来越复杂 工厂方法模式：一个工厂创建一个产品（每个类都有一个Create函数） 系统的可扩展性也就变得非常好，无需修改接口和原类 增加系统中类的个数，复杂度和理解度增加（一个具体产品就需要对应一个具体工厂） 抽象方法模式：一个工厂创建一系列（一个产品族）的产品（一个产品族一个Create） 增加新的产品族很方便，无须修改已有系统，符合“开闭原则” 增加新的产品等级结构麻烦，需要对原有系统进行较大的修改，违背了“开闭原则” 相当于在工厂方法模式的基础下进行了折中 对于产品族来说遵循了开闭原则 对于产品等级结构来说没有遵循开闭原则 如果产品结构等级稳定，那么就相当于完全遵循开闭原则 ","date":"2022-10-24","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/:0:0","tags":["设计模式"],"title":"设计模式之创建型模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"},{"categories":["系统设计"],"content":" 面向对象设计原则为支持可维护性复用而诞生，这些原则蕴含在很多设计模式中，它们是从许多设计方案中总结出的指导性原则。 单一职责原则 类的职责单一，对外只提供一种功能，而引起类变化的原因都应该只有一个。 一个类对外只提供一种功能。 开闭原则 类的改动是通过增加代码进行的，而不是修改源代码。 增加功能时去增加代码而不是修改代码。 里氏替换替换原则 任何抽象类（interface接口）出现的地方都可以用他的实现类进行替换，实际就是虚拟机制，语言级别实现面向对象功能。 依赖倒置原则 依赖于抽象(接口)，不要依赖具体的实现(类)，也就是针对接口编程。 模块与模块依赖抽象而不是具体实现。 接口隔离原则 不应该强迫用户的程序依赖他们不需要的接口方法。一个接口应该只提供一种对外功能，不应该把所有操作都封装到一个接口中去。 合成复用原则 如果使用继承，会导致父类的任何变换都可能影响到子类的行为。如果使用对象组合，就降低了这种依赖关系。对于继承和组合，优先使用组合。 通过组合来实现父类方法。 迪米特法则 一个对象应当对其他对象尽可能少的了解，从而降低各个对象之间的耦合，提高系统的可维护性。例如在一个程序中，各个模块之间相互调用时，通常会提供一个统一的接口来实现。这样其他模块不需要了解另外一个模块的内部实现细节，这样当一个模块内部的实现发生改变时，不会影响其他模块的使用。 依赖第三方来实现解耦。 以上面向对象设计原则对于写代码有什么指导思想呢，我想大致可以分为两点： 对象的职责设置的尽可能单一，后续有需求的更改不需要修改之前的代码。不推荐使用继承（父类发生更改非常容易影响子类），而是多用组合（如Python中常用的mixin，通过组合不同的mixin获得不同的功能）。 在进行系统设计时要考虑三个层次：抽象层、实现层、业务逻辑层。在写业务逻辑层的时候，依赖的是抽象层提供的接口，这样即使是具体实现层的代码改动，或者是需要另一种实现方式，在业务逻辑层也不需要改动。 ","date":"2022-10-07","objectID":"/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/:0:0","tags":["设计模式"],"title":"面向对象设计原则","uri":"/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"},{"categories":["学习记录"],"content":"首先说下自己并不是专门做安全的，此次总结也确实是工作中遇到了这类问题需要解决 当然如果你自己有过搭建服务的经历，或许会在服务的访问记录中看到各种乱七八载的访问 如果有以下情况的话，就送他一个iptables套餐吧 ","date":"2022-05-11","objectID":"/web%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/:0:0","tags":["网络安全"],"title":"Web安全基础学习","uri":"/web%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"},{"categories":["学习记录"],"content":"SQL注入 SQL注入是一种代码注入技术，用于攻击数据驱动的应用程序。 在应用程序中，如果没有做恰当的过滤，则可能使得恶意的SQL语句被插入输入字段中执行（例如将数据库内容转储给攻击者） 报错注入 extractvalue(1, concat(0x5c,(select user()))) updatexml(0x3a,concat(1,(select user())),1) http://ns2.stats.gov.cn/comment/api/index.php?gid=1\u0026page=2\u0026rlist%5B%5D=%40%60%27%60%2C+extractvalue%281%2C+concat_ws%280x20%2C+0x5c%2C%28select+md5%28202072102%29%29%29%29%2C%40%60%27%60 http://14.29.113.88:9292/api/sms_check.php?param=1%27+and+updatexml%281%2Cconcat%280x7e%2C%28SELECT+MD5%281234%29%29%2C0x7e%29%2C1%29--+ 数据路检测（mysql） sleep：sleep(1) 让sql运行多少秒 字符串连接：SELECT CONCAT(’some‘, ‘string’) 报错注入：convert(int, (db_name())) 等等 http://218.13.13.90:8081/fsGovPlatform/js/(select(0)from(select(sleep(34)))v)%2f*'+(select(0)from(select(sleep(34)))v)+'\"\"+(select(0)from(select(sleep(34)))v)+\"\"*%2f/timepicker/jquery-ui-timepicker-addon.js http://210.76.74.50/faq.php?action=grouppermission\u0026gids%5B100%5D%5B0%5D=%29+and+%28select+1+from+%28select+count%28%2A%29%2Cconcat%28%28select+concat%28user%2C0x3a%2Cmd5%281234%29%2C0x3a%29+from+mysql.user+limit+0%2C1%29%2Cfloor%28rand%280%29%2A2%29%29x+from+information_schema.tables+group+by+x%29a%29%23\u0026gids%5B99%5D=%27 http://xwrz.huizhou.gov.cn/invest-client/rzcs/index.html?assureType=123456\u0026minBalance=convert%28int%2Csys.fn_sqlvarbasetostr%28HashBytes%28%27MD5%27%2C%271078491144%27%29%29%29\u0026moneyrateStart=123456\u0026type=123456 ","date":"2022-05-11","objectID":"/web%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/:1:0","tags":["网络安全"],"title":"Web安全基础学习","uri":"/web%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"},{"categories":["学习记录"],"content":"XSS XSS全称为Cross Site Scripting，为了和CSS分开简写为XSS，中文名为跨站脚本。该漏洞发生在用户端，是指在渲染过程中发生了不在预期过程中的JavaScript代码执行。XSS通常被用于获取Cookie、以受攻击者的身份进行操作等行为 # 特征 \u003cscript src=\"...\"\u003e\u003c/script\u003e http://qqt.gdqy.gov.cn/tomcat-docs/appdev/sample/web/hello.jsp?test=\u003cscript\u003ealert(12345)\u003c/script\u003e ","date":"2022-05-11","objectID":"/web%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/:2:0","tags":["网络安全"],"title":"Web安全基础学习","uri":"/web%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"},{"categories":["学习记录"],"content":"CSRF 跨站请求伪造 (Cross-Site Request Forgery, CSRF)，也被称为 One Click Attack 或者 Session Riding ，通常缩写为CSRF，是一种对网站的恶意利用。尽管听起来像XSS，但它与XSS非常不同，XSS利用站点内的信任用户，而CSRF则通过伪装来自受信任用户的请求来利用受信任的网站 ","date":"2022-05-11","objectID":"/web%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/:3:0","tags":["网络安全"],"title":"Web安全基础学习","uri":"/web%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"},{"categories":["学习记录"],"content":"SSRF 服务端请求伪造（Server Side Request Forgery, SSRF）指的是攻击者在未能取得服务器所有权限时，利用服务器漏洞以服务器的身份发送一条构造好的请求给服务器所在内网。SSRF攻击通常针对外部网络无法直接访问的内部系统 通过各种非http协议 file:///path/to/file http://183.63.186.68/Web/file:%2f%2f%2fetc%2fpasswd.html ","date":"2022-05-11","objectID":"/web%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/:4:0","tags":["网络安全"],"title":"Web安全基础学习","uri":"/web%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"},{"categories":["学习记录"],"content":"命令注入 命令注入通常因为指Web应用在服务器上拼接系统命令而造成的漏洞。 该类漏洞通常出现在调用外部程序完成一些功能的情景下。比如一些Web管理界面的配置主机名/IP/掩码/网关、查看系统信息以及关闭重启等功能，或者一些站点提供如ping、nslookup、提供发送邮件、转换图片等功能都可能出现该类漏洞。 ","date":"2022-05-11","objectID":"/web%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/:5:0","tags":["网络安全"],"title":"Web安全基础学习","uri":"/web%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"},{"categories":["学习记录"],"content":"目录穿越 目录穿越（也被称为目录遍历/directory traversal/path traversal）是通过使用 ../ 等目录控制序列或者文件的绝对路径来访问存储在文件系统上的任意文件和目录，特别是应用程序源代码、配置文件、重要的系统文件等 ../ ..\\ ..;/ http://dfz.gd.gov.cn/index/ztlm/szfzg/gctj/nj//../../../../Gemfile ","date":"2022-05-11","objectID":"/web%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/:6:0","tags":["网络安全"],"title":"Web安全基础学习","uri":"/web%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"},{"categories":["学习记录"],"content":"文件读取 考虑读取可能有敏感信息的文件 用户目录下的敏感文件：.bash_history/.zsh_history/.profile/.bashrc/.gitconfig/.viminfopasswd 应用的配置文件：/etc/apache2/apache2.conf, /etc/nginx/nginx.conf 应用的日志文件：/var/log/apache2/access.log, /var/log/nginx/access.log 站点目录下的敏感文件：.svn/entries.git/HEADWEB-INF/web.xml.htaccess 特殊的备份文件：.swp/.swo/.bak/index.php Python的Cache：pycache_init_.cpython-35.pyc http://www.gdzwfw.gov.cn/portal/static//..%c1%9c..%c1%9c..%c1%9c..%c1%9c..%c1%9c..%c1%9c..%c1%9c..%c1%9c/windows/win.ini http://gcjs.jiangmen.cn/framework-ui/src//%2e%2e%5c%2e%2e%5c%2e%2e%5c%2e%2e%5c%2e%2e%5c%2e%2e%5c%2e%2e%5c%2e%2e%5c%2e%2e%5c%2e%2e%5c%2e%2e%5c%2e%2e%5c%2e%2e%5c%2e%2e%5c%2e%2e%5c%2e%2e%5c/etc/passwd http://zfbz.maoming.gov.cn/css/.svn/entries http://ggzy.zhuhai.gov.cn:8092/GPC/.git/HEAD ","date":"2022-05-11","objectID":"/web%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/:7:0","tags":["网络安全"],"title":"Web安全基础学习","uri":"/web%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"},{"categories":["学习记录"],"content":"文件上传 竞争上绕过 有的服务器采用了先保存，再删除不合法文件的方式，在这种服务器中，可以反复上传一个会生成Web Shell的文件并尝试访问，多次之后即可获得Shell http://bbs.968115.cn/backup.sh ","date":"2022-05-11","objectID":"/web%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/:8:0","tags":["网络安全"],"title":"Web安全基础学习","uri":"/web%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"},{"categories":["学习记录"],"content":"文件包含 常见的文件包含漏洞的形式为 \u003c?php include(\"inc/\" . $_GET['file']); ?\u003e 考虑常用的几种包含方式为 同目录包含 file=.htaccess 目录遍历 ?file=../../../../../../../../../var/lib/locate.db 日志注入 ?file=../../../../../../../../../var/log/apache/error.log 利用 /proc/self/environ 其中日志可以使用SSH日志或者Web日志等多种日志来源测试 http://183.63.186.142:8080/.htaccess ","date":"2022-05-11","objectID":"/web%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/:9:0","tags":["网络安全"],"title":"Web安全基础学习","uri":"/web%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"},{"categories":["学习记录"],"content":"XXE 当允许引用外部实体时，可通过构造恶意的XML内容，导致读取任意文件、执行系统命令、探测内网端口、攻击内网网站等后果。一般的XXE攻击，只有在服务器有回显或者报错的基础上才能使用XXE漏洞来读取服务器端文件，但是也可以通过Blind XXE的方式实现攻击 ","date":"2022-05-11","objectID":"/web%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/:10:0","tags":["网络安全"],"title":"Web安全基础学习","uri":"/web%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"},{"categories":["学习记录"],"content":"模版注入 模板引擎用于使用动态数据呈现内容。此上下文数据通常由用户控制并由模板进行格式化，以生成网页、电子邮件等。模板引擎通过使用代码构造（如条件语句、循环等）处理上下文数据，允许在模板中使用强大的语言表达式，以呈现动态内容。如果攻击者能够控制要呈现的模板，则他们将能够注入可暴露上下文数据，甚至在服务器上运行任意命令的表达式 ","date":"2022-05-11","objectID":"/web%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/:11:0","tags":["网络安全"],"title":"Web安全基础学习","uri":"/web%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"},{"categories":["学习记录"],"content":"Xpath注入 XPath注入攻击主要是通过构建特殊的输入，这些输入往往是XPath语法中的一些组合，这些输入将作为参数传入Web 应用程序，通过执行XPath查询而执行入侵者想要的操作，下面以登录验证中的模块为例，说明 XPath注入攻击的实现原理 ","date":"2022-05-11","objectID":"/web%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/:12:0","tags":["网络安全"],"title":"Web安全基础学习","uri":"/web%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"},{"categories":["学习记录"],"content":"逻辑漏洞/业务漏洞 逻辑漏洞是指由于程序逻辑不严导致一些逻辑分支处理错误造成的漏洞。 在实际开发中，因为开发者水平不一没有安全意识，而且业务发展迅速内部测试没有及时到位，所以常常会出现类似的漏洞 ","date":"2022-05-11","objectID":"/web%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/:13:0","tags":["网络安全"],"title":"Web安全基础学习","uri":"/web%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"},{"categories":["学习记录"],"content":"配置安全 弱密码位数过低字符集小为常用密码个人信息相关手机号生日姓名用户名使用键盘模式做密码 敏感文件泄漏.git.svn 数据库Mongo/Redis等数据库无密码且没有限制访问 加密体系在客户端存储私钥 三方库/软件公开漏洞后没有及时更新 ","date":"2022-05-11","objectID":"/web%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/:14:0","tags":["网络安全"],"title":"Web安全基础学习","uri":"/web%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"},{"categories":["学习记录"],"content":"中间件 ","date":"2022-05-11","objectID":"/web%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/:15:0","tags":["网络安全"],"title":"Web安全基础学习","uri":"/web%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"},{"categories":["学习记录"],"content":"Web Cache欺骗攻击 漏洞成因 当代理服务器设置为缓存静态文件并忽略这类文件的caching header时，访问 http://www.example.com/home.php/no-existent.css 时，会发生什么呢？整个响应流程如下： 浏览器请求 http://www.example.com/home.php/no-existent.css ; 服务器返回 http://www.example.com/home.php 的内容(通常来说不会缓存该页面); 响应经过代理服务器; 代理识别该文件有css后缀; 在缓存目录下，代理服务器创建目录 home.php ，将返回的内容作为 non-existent.css 保存。 漏洞利用 攻击者欺骗用户访问 http://www.example.com/home.php/logo.png?www.myhack58.com ,导致含有用户个人信息的页面被缓存，从而能被公开访问到。更严重的情况下，如果返回的内容包含session标识、安全问题的答案，或者csrf token。这样攻击者能接着获得这些信息，因为通常而言大部分网站静态资源都是公开可访问的。 ","date":"2022-05-11","objectID":"/web%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/:16:0","tags":["网络安全"],"title":"Web安全基础学习","uri":"/web%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"},{"categories":["学习记录"],"content":"HTTP走私请求 HTTP请求走私是一种干扰网站处理HTTP请求序列方式的技术，最早在 2005 年的一篇 文章 中被提出。 ","date":"2022-05-11","objectID":"/web%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/:17:0","tags":["网络安全"],"title":"Web安全基础学习","uri":"/web%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"},{"categories":["学习记录"],"content":"注意 文中的url举例均来自某为公司的测试请求，且对方访问是已经签署了访问协议 请不要随意访问文中举例url，更不要批量访问，否则后果自负！！！ ","date":"2022-05-11","objectID":"/web%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/:18:0","tags":["网络安全"],"title":"Web安全基础学习","uri":"/web%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"},{"categories":["终端工具"],"content":" Git Documentation Git 教程 - 廖雪峰 Git 常用命令 git init 初始化本地 git 环境 git clone \u003crepository\u003e 克隆一份代码到本地仓库 git pull 把远程仓库代码更新到本地，等于 git fetch + git merge git pull --rebase origin master 强制把远程仓库的代码更新到当前分支上面 git fetch 把远程库的代码更新到本地 git add . 把本地改动过的文件添加到暂存区中 git commit -m '\u003ccommit message\u003e' 把暂存区中的修改提交到本地库 git push 把本地库的修改提交到远程库中 git push origin \u003cbranch name\u003e 提交一个分支到远程库中 git branch -r/-a 查看远程分支 / 全部分支 git checkout master/bugfix 切换到某个分支 git checkout -b bugfix 新建 bugfix 分支 git checkout -d bugfix 删除 bugfix 分支 git merge master 假设当前在 bugfix 分支上，把 master 分支上的修改同步到 bugfix 分支上 git merge tool 调用 merge 工具 git stash 把未完成的修改保存起来 git stash list 查看所有保存列表 git stash pop 恢复本地分支到缓存状态 git blame \u003cfile name\u003e 查看某个文件每一行的修改记录，谁在什么时候修改的 git status 查看当前分支有哪些修改 git log 查看当前分支上面的日志信息 git diff 查看当前没有 add 的内容 git diff --cached 查看已经 add 但是没有 commit 的内容 git diff HEAD 上面两个命令显示内容的合并 git reset --hard HEAD 撤销本地修改 团队协作 Git 流程 ","date":"2022-04-24","objectID":"/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/:0:0","tags":["git"],"title":"Git常用命令总结","uri":"/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/"},{"categories":["终端工具"],"content":"克隆新项目，完成功能并提交 git clone \u003crepository\u003e 克隆代码仓库 git checkout -b \u003cbranch name\u003e 新建分支 \u003cmodify your code\u003e 完成功能的开发，代码的修改 git add . 把修改添加到暂存区 git commit -m '\u003ccommit message\u003e' 提交修改到 bugfix 分支 \u003creview 代码\u003e git checkout master 切换到 master 分支 git pull 更新代码 git merge \u003cbranch name\u003e 将新建分支合并到 master git push origin \u003cbranch name\u003e 把新建分支的代码 push 到远程仓库 ","date":"2022-04-24","objectID":"/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/:1:0","tags":["git"],"title":"Git常用命令总结","uri":"/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/"},{"categories":["终端工具"],"content":"正在新功能分支开发，需要紧急修复 bug 适用于新功能正在开发还不想提交的情况 因为工作区和暂存区的内容是公共的，不属于任何一个分支，所以就需要git stash临时保存修改 git add . 将当前代码添加暂存 git stash 保存修改 git checkout -b \u003cbugfix\u003e 新建 bugfix 分支 git pull --rebase origin master 主分支代码更新到当前分支 \u003cfix the bug\u003e 修复 bug git add . 添加暂存 git commit -m '\u003ccommit message\u003e' 提交代码 git push origin \u003cbugfix\u003e 推动 bugfix 分支到远程仓库 git checkout \u003cnew feature branch\u003e 回到新功能开发分支 git stash pop 恢复修改 \u003ccontinue develop\u003e 继续开发 ","date":"2022-04-24","objectID":"/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/:2:0","tags":["git"],"title":"Git常用命令总结","uri":"/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/"},{"categories":["编程语言"],"content":"在使用 Python Web 框架 Django 本地 runserver 启动后修改了代码，程序够自动重新加载并执行（live-reload），在开发调试阶段非常实用，可以提高开发效率。 在使用 Go 开发自己的项目或者使用 gin 框架进行本地调试的时候，也需要在文件修改后自动编译运行查看效果，那么则可以使用 air 这个工具。 ","date":"2022-04-21","objectID":"/%E4%BD%BF%E7%94%A8air%E5%AE%9E%E7%8E%B0go%E7%A8%8B%E5%BA%8F%E7%83%AD%E5%8A%A0%E8%BD%BD/:0:0","tags":["Golang"],"title":"使用air实现go程序热加载","uri":"/%E4%BD%BF%E7%94%A8air%E5%AE%9E%E7%8E%B0go%E7%A8%8B%E5%BA%8F%E7%83%AD%E5%8A%A0%E8%BD%BD/"},{"categories":["编程语言"],"content":"AIR air 使用 go 语言开发，可以实现 go 语言应用程序的热加载，它支持以下特性： 彩色日志输出 自定义构建或二进制命令 支持忽略子目录 启动后支持监听新目录 更好的构建流程 air 使用\" air 使用 ","date":"2022-04-21","objectID":"/%E4%BD%BF%E7%94%A8air%E5%AE%9E%E7%8E%B0go%E7%A8%8B%E5%BA%8F%E7%83%AD%E5%8A%A0%E8%BD%BD/:1:0","tags":["Golang"],"title":"使用air实现go程序热加载","uri":"/%E4%BD%BF%E7%94%A8air%E5%AE%9E%E7%8E%B0go%E7%A8%8B%E5%BA%8F%E7%83%AD%E5%8A%A0%E8%BD%BD/"},{"categories":["编程语言"],"content":"安装 由于是 go 语言开发，对于我来说就直接下载二进制文件放到系统 PATH 目录下了，当然也可以使用 go get 、Docker 等方式安装，具体可以查看 Readme 中其他的安装方法，这里就不再赘述了 ","date":"2022-04-21","objectID":"/%E4%BD%BF%E7%94%A8air%E5%AE%9E%E7%8E%B0go%E7%A8%8B%E5%BA%8F%E7%83%AD%E5%8A%A0%E8%BD%BD/:2:0","tags":["Golang"],"title":"使用air实现go程序热加载","uri":"/%E4%BD%BF%E7%94%A8air%E5%AE%9E%E7%8E%B0go%E7%A8%8B%E5%BA%8F%E7%83%AD%E5%8A%A0%E8%BD%BD/"},{"categories":["编程语言"],"content":"使用 写好 .air.conf 文件放在项目目录下然后直接执行 air 命令就行，非常简单 完整的示例以及注释如下，需要新增环境变量或者是命令行参数的可以在 full_bin 前后添加 # [Air](https://github.com/cosmtrek/air) TOML 格式的配置文件 # 工作目录 # 使用 . 或绝对路径，请注意 `tmp_dir` 目录必须在 `root` 目录下 root = \".\" tmp_dir = \"tmp\" [build] # 只需要写你平常编译使用的 shell 命令。你也可以使用 `make` cmd = \"go build -o ./tmp/main .\" # 由 `cmd` 命令得到的二进制文件名 bin = \"tmp/main\" # 自定义的二进制，可以在前方添加环境变量或者是后方添加命令行参数启动 eg：APP_ENV=dev full_bin = \"./tmp/main\" # 监听以下文件扩展名的文件。 include_ext = [\"go\", \"tpl\", \"tmpl\", \"html\"] # 忽略这些文件扩展名或目录 exclude_dir = [\"assets\", \"tmp\", \"vendor\", \"frontend/node_modules\"] # 监听以下指定目录的文件 include_dir = [] # 排除以下文件 exclude_file = [] # 如果文件更改过于频繁，则没有必要在每次更改时都触发构建。可以设置触发构建的延迟时间 delay = 1000 # ms # 发生构建错误时，停止运行旧的二进制文件。 stop_on_error = true # air 的日志文件名，该日志文件放置在你的 `tmp_dir` 中 log = \"air_errors.log\" [log] # 显示日志时间 time = true [color] # 自定义每个部分显示的颜色。如果找不到颜色，使用原始的应用程序日志。 main = \"magenta\" watcher = \"cyan\" build = \"yellow\" runner = \"green\" [misc] # 退出时删除 tmp 目录 clean_on_exit = true 生成并运行的二进制文件会放在当前目录下 tmp 目录，程序结束后会自动删除，非常贴心 ","date":"2022-04-21","objectID":"/%E4%BD%BF%E7%94%A8air%E5%AE%9E%E7%8E%B0go%E7%A8%8B%E5%BA%8F%E7%83%AD%E5%8A%A0%E8%BD%BD/:3:0","tags":["Golang"],"title":"使用air实现go程序热加载","uri":"/%E4%BD%BF%E7%94%A8air%E5%AE%9E%E7%8E%B0go%E7%A8%8B%E5%BA%8F%E7%83%AD%E5%8A%A0%E8%BD%BD/"},{"categories":["随笔"],"content":"必看表演 狂欢大巡游（全园区的大迅游，上午下午各一次，特别热闹） 功夫山庄（动物表演，有海象、海豹、水獭等，建议提前10分钟占好位置） 极地奇缘（海豚表演剧场，建议提前10分钟占好位置） 白鲸之恋（白鲸与饲养员的互动） 人鱼华尔兹（美人鱼演员表演） ","date":"2022-04-04","objectID":"/%E6%AD%A6%E6%B1%89%E6%B5%B7%E6%98%8C%E6%9E%81%E5%9C%B0%E6%B5%B7%E6%B4%8B%E4%B8%96%E7%95%8C%E6%B8%B8%E7%8E%A9tips/:1:0","tags":["武汉"],"title":"武汉海昌极地海洋世界游玩tips","uri":"/%E6%AD%A6%E6%B1%89%E6%B5%B7%E6%98%8C%E6%9E%81%E5%9C%B0%E6%B5%B7%E6%B4%8B%E4%B8%96%E7%95%8C%E6%B8%B8%E7%8E%A9tips/"},{"categories":["随笔"],"content":"各展厅推荐游览方案 企鹅展厅 一定要在企鹅喂食的时间观看，喂食过程很好玩，而且吃完东西的企鹅很活泼，到处跑到处游 白鲸展厅 请务必17点以后去一趟白鲸展厅，那个时候大部分游客都已经玩累了出园回家了，你可以一个人享受整个白鲸展厅，这个时候你会看到不一样的白鲸，强烈推荐！！！ 海底两万里 这里也建议17点以后再去一趟，体验一下一个人的海底，才能值回票价！ ","date":"2022-04-04","objectID":"/%E6%AD%A6%E6%B1%89%E6%B5%B7%E6%98%8C%E6%9E%81%E5%9C%B0%E6%B5%B7%E6%B4%8B%E4%B8%96%E7%95%8C%E6%B8%B8%E7%8E%A9tips/:2:0","tags":["武汉"],"title":"武汉海昌极地海洋世界游玩tips","uri":"/%E6%AD%A6%E6%B1%89%E6%B5%B7%E6%98%8C%E6%9E%81%E5%9C%B0%E6%B5%B7%E6%B4%8B%E4%B8%96%E7%95%8C%E6%B8%B8%E7%8E%A9tips/"},{"categories":["随笔"],"content":"总结 17点以后的海洋公园才是最好玩的海洋公园，不到清场不要离开园区！我入园的时候比较晚，下午2点才入园，以为体验会很赶，但是17点以后的白鲸馆和海底两万里让我感觉赚了！表演尽量都看完，合理安排时间，不要走马观花，多停留一段时间可以看到不一样的场景。 ","date":"2022-04-04","objectID":"/%E6%AD%A6%E6%B1%89%E6%B5%B7%E6%98%8C%E6%9E%81%E5%9C%B0%E6%B5%B7%E6%B4%8B%E4%B8%96%E7%95%8C%E6%B8%B8%E7%8E%A9tips/:3:0","tags":["武汉"],"title":"武汉海昌极地海洋世界游玩tips","uri":"/%E6%AD%A6%E6%B1%89%E6%B5%B7%E6%98%8C%E6%9E%81%E5%9C%B0%E6%B5%B7%E6%B4%8B%E4%B8%96%E7%95%8C%E6%B8%B8%E7%8E%A9tips/"},{"categories":["编程语言"],"content":"Go 语言中的 byte 和 rune 实际上是 uin8 和 int32 类型 byte 一般来表示一些原始数据（如网络中的数据传输） rune 则用来表示 Unciode 字符 在 go 中 string 的底层用的就是 byte 字节数组存储的，它的遍历有两种情况 package main import ( \"fmt\" ) func main() { s := \"abc汉字\" for i := 0; i \u003clen(s); i++ { fmt.Printf(\"%c,\", s[i]) } fmt.Println() for _, r := range s { fmt.Printf(\"%c,\", r) } } // 结果 // a,b,c,æ,±,,å,­,, // a,b,c,汉,字, 想获取字符串中的字符个数需要转换 []rune 数组，获取中文字符下标同理 package main import ( \"fmt\" ) func main() { s := \"你好世界\" fmt.Println(len(s)) fmt.Println(len([]rune(s))) } // 结果 // 12 // 4 ","date":"2021-11-12","objectID":"/golang%E4%B8%AD%E7%9A%84stringrune%E5%92%8Cbyte/:0:0","tags":["Golang"],"title":"Golang中的string、rune和byte","uri":"/golang%E4%B8%AD%E7%9A%84stringrune%E5%92%8Cbyte/"},{"categories":["源码阅读"],"content":"Redis 中字符串的实现并没有完全使用 C 字符串，而是重新定义了简单动态字符串 SDS（Simple Dynamic String）用来表示字符串（Redis 3.2前）。 sds.h/sdshdr struct sdshdr { unsigned int len; // 记录 buf 数组中已使字节的数量 unsigned int free; // 记录 buf 数组中未使用字节的数量 char buf[]; // 字节数组，用于保存字符串 }; buf 数组长度不一定就是字符串长度 + 1（\"\\0\"），还有 free 空间，数组内未使用的字节通过 free 属性记录。 相比于 C 字符串，SDS 有以下优势： 兼容部分 C 字符串函数 sds.c/sdsnew * mystring = sdsnewlen(\"abc\",3); * * You can print the string with printf() as there is an implicit \\0 at the * end of the string. However the string is binary safe and can contain * \\0 characters in the middle, as the length is stored in the sds header. */ sds sdsnewlen(const void *init, size_t initlen) { struct sdshdr *sh; if (init) { sh = zmalloc(sizeof(struct sdshdr)+initlen+1); } else { sh = zcalloc(sizeof(struct sdshdr)+initlen+1); } if (sh == NULL) return NULL; sh-\u003elen = initlen; sh-\u003efree = 0; if (initlen \u0026\u0026 init) memcpy(sh-\u003ebuf, init, initlen); sh-\u003ebuf[initlen] = '\\0'; return (char*)sh-\u003ebuf; } /* Create a new sds string starting from a null termined C string. */ sds sdsnew(const char *init) { size_t initlen = (init == NULL) ? 0 : strlen(init); return sdsnewlen(init, initlen); 从 SDS 的创建逻辑中可以看出 SDS 遵循 C 字符串以空字符（\"\\0\"）结尾。 SDS 中的 len 属性（sds.h/sdslen）同 C 字符串函数 strlen 返回结果相同，即不计算尾部空字符。 这样 SDS 就可以直接重用一部分 C 字符串函数库里面的函数（如打印，显示类函数，\u003cstdio.h\u003e/printf），而字符串的修改操作，则使用 SDS 自定义优化后的函数。 常数复杂度获取字符串长度 C 获取一个 C 字符串的长度，程序必须遍历整个字符串，直到遇到代表字符串结尾的空字符串位置，这个操作的复杂度为 O(N)。 但是对于 SDS 来说，获取字符串长度只需要访问 SDS 中的 len 属性。复杂度仅为 O(1)，确保了获取字符串长度这样的高频操作不会成为 Redis 性能瓶颈。 对于 SDS 的修改操作，SDS 会实时维护 len 属性，如 sds.c/sdscat（追加 C 字符串到 SDS 字符串） /* Append the specified binary-safe string pointed by 't' of 'len' bytes to the * end of the specified sds string 's'. * * After the call, the passed sds string is no longer valid and all the * references must be substituted with the new pointer returned by the call. */ sds sdscatlen(sds s, const void *t, size_t len) { struct sdshdr *sh; size_t curlen = sdslen(s); s = sdsMakeRoomFor(s,len); if (s == NULL) return NULL; sh = (void*) (s-(sizeof(struct sdshdr))); memcpy(s+curlen, t, len); sh-\u003elen = curlen+len; sh-\u003efree = sh-\u003efree-len; s[curlen+len] = '\\0'; return s; } /* Append the specified sds 't' to the existing sds 's'. * * After the call, the modified sds string is no longer valid and all the * references must be substituted with the new pointer returned by the call. */ sds sdscatsds(sds s, const sds t) { return sdscatlen(s, t, sdslen(t)); } 杜绝缓冲区溢出 C 字符串由于不记录自身长度，对其进行修改操作容易造成缓冲区溢出（buffer overflow）。如 C 字符串拼接函数 \u003cstdio.h\u003e/strcat，内存中相邻的字符串 s1 和 s2，对 s1 字符串做拼接操作时，如果没有提前为 s1 分配足够的空间，则 s2 保存的内容会被意外修改。 SDS 内部维护了一个 free 字段，当 SDS API 需要对其进行修改时，API 会调用 sdsMakeRoomForDS 函数检测当前 SDS 的 free 空间是否满足要求，满足直接进行修改；不满足 sdsMakeRoomForDS 则会将 SDS 的空间扩展至执行修改所需的大小，避免缓冲区溢出的情况（如上方 sds.c/sdscat）。 减少修改字符串长度时所需内存重分配次数 Redis 作为数据库，经常被用于速度要求严苛，数据被频繁修改的场景。SDS 实现了 空间预分配 和 惰性空间释放 两种优化策略。 sds.c/sdsMakeRoomFor /* Enlarge the free space at the end of the sds string so that the caller * is sure that after calling this function can overwrite up to addlen * bytes after the end of the string, plus one more byte for nul term. * * Note: this does not change the *length* of the sds string as returned * by sdslen(), but only the free buffer space we have. */ sds sdsMakeRoomFor(sds s, size_t addlen) { struct sdshdr *sh, *newsh; size_t free = sdsavail(s); size_t len, newlen; if (free\u003e= addlen) return s; len = sdslen(s); sh = (void*) (s-(sizeof(struct sdshdr))); newlen = (len+addlen); if (newlen \u003c SDS_MAX_PREALLOC) newlen *= 2; else newlen += SDS_MAX_PREALLOC; newsh = zrealloc(sh, sizeof(struct sdshdr)+newlen+1); if (newsh == NULL) return NULL; newsh-\u003efree = newlen - len; return newsh-\u003ebuf; } ","date":"2021-11-05","objectID":"/redis%E6%BA%90%E7%A0%81%E4%B9%8B%E7%AE%80%E5%8D%95%E5%8A%A8%E6%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2/:0:0","tags":["Redis"],"title":"Redis源码之简单动态字符串","uri":"/redis%E6%BA%90%E7%A0%81%E4%B9%8B%E7%AE%80%E5%8D%95%E5%8A%A8%E6%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"categories":["源码阅读"],"content":"空间预分配 可以发现，在 SDS API 进行字符串新增逻辑中会给 SDS 重新分配 free 空间。 如果 SDS 的长度（len 属性）小于 SDS_MAX_PREALLOC（1024KB=1M），则会分配和 len 属性同样大小的未使用空间给 buf，这时 SDS 的 len 属性和 free 属性值相同。 如果 SDS 长度大于或者等于 SDS_MAX_PREALLOC（1024KB=1M），则会直接给 free 属性分配 SDS_MAX_PREALLOC（1024KB=1M） 的大小。 通过空间预分配策略，Redis 可以减少连续执行字符串增长操作所需的内存重分配次数. ","date":"2021-11-05","objectID":"/redis%E6%BA%90%E7%A0%81%E4%B9%8B%E7%AE%80%E5%8D%95%E5%8A%A8%E6%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2/:1:0","tags":["Redis"],"title":"Redis源码之简单动态字符串","uri":"/redis%E6%BA%90%E7%A0%81%E4%B9%8B%E7%AE%80%E5%8D%95%E5%8A%A8%E6%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"categories":["源码阅读"],"content":"惰性空间释放 sds.c/sdstrim /* Remove the part of the string from left and from right composed just of * contiguous characters found in 'cset', that is a null terminted C string. * * After the call, the modified sds string is no longer valid and all the * references must be substituted with the new pointer returned by the call. * * Example: * * s = sdsnew(\"AA...AA.a.aa.aHelloWorld :::\"); * s = sdstrim(s,\"A. :\"); * printf(\"%s\\n\", s); * * Output will be just \"Hello World\". */ sds sdstrim(sds s, const char *cset) { struct sdshdr *sh = (void*) (s-(sizeof(struct sdshdr))); char *start, *end, *sp, *ep; size_t len; sp = start = s; ep = end = s+sdslen(s)-1; while(sp \u003c= end \u0026\u0026 strchr(cset, *sp)) sp++; while(ep\u003e start \u0026\u0026 strchr(cset, *ep)) ep--; len = (sp\u003e ep) ? 0 : ((ep-sp)+1); if (sh-\u003ebuf != sp) memmove(sh-\u003ebuf, sp, len); sh-\u003ebuf[len] = '\\0'; sh-\u003efree = sh-\u003efree+(sh-\u003elen-len); sh-\u003elen = len; return s; } 可以发现，在进行字符串剪切操作时，多出的 buf 空间并不会直接释放，而是存储在 free 字段中。 同时为了避免内存泄露，SDS 也提供了 sds.c/sdsRemoveFreeSpace 释放 free 空间操作，在 redis.c/clientsCronResizeQueryBuffer 中可以看到，当 querybuf 大于 1024 字节，会进行释放操作。 /* Reallocate the sds string so that it has no free space at the end. The * contained string remains not altered, but next concatenation operations * will require a reallocation. * * After the call, the passed sds string is no longer valid and all the * references must be substituted with the new pointer returned by the call. */ sds sdsRemoveFreeSpace(sds s) { struct sdshdr *sh; sh = (void*) (s-(sizeof(struct sdshdr))); sh = zrealloc(sh, sizeof(struct sdshdr)+sh-\u003elen+1); sh-\u003efree = 0; return sh-\u003ebuf; } /* The client query buffer is an sds.c string that can end with a lot of * free space not used, this function reclaims space if needed. * * The function always returns 0 as it never terminates the client. */ int clientsCronResizeQueryBuffer(redisClient *c) { size_t querybuf_size = sdsAllocSize(c-\u003equerybuf); time_t idletime = server.unixtime - c-\u003elastinteraction; /* There are two conditions to resize the query buffer: * 1) Query buffer is \u003e BIG_ARG and too big for latest peak. * 2) Client is inactive and the buffer is bigger than 1k. */ if (((querybuf_size\u003e REDIS_MBULK_BIG_ARG) \u0026\u0026 (querybuf_size/(c-\u003equerybuf_peak+1)) \u003e 2) || (querybuf_size\u003e 1024 \u0026\u0026 idletime \u003e 2)) { /* Only resize the query buffer if it is actually wasting space. */ if (sdsavail(c-\u003equerybuf) \u003e 1024) { c-\u003equerybuf = sdsRemoveFreeSpace(c-\u003equerybuf); } } /* Reset the peak again to capture the peak memory usage in the next * cycle. */ c-\u003equerybuf_peak = 0; return 0; } 二进制安全 SDS API 都会以处理二进制的方式来处理 SDS 存放在 buf 数组里的数据（如不以 “\\0” 当作字符串结尾），程序不会对其中的数据做任何限制、过滤、或者假设，数据在写入时是什么样的，他被读取时就是什么样子。因此 Redis 可以不仅可以保存文本数据，还可以保存图片、音频、视频、压缩文件这样的二进制数据。 SDS API SDS API\" SDS API ","date":"2021-11-05","objectID":"/redis%E6%BA%90%E7%A0%81%E4%B9%8B%E7%AE%80%E5%8D%95%E5%8A%A8%E6%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2/:2:0","tags":["Redis"],"title":"Redis源码之简单动态字符串","uri":"/redis%E6%BA%90%E7%A0%81%E4%B9%8B%E7%AE%80%E5%8D%95%E5%8A%A8%E6%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"categories":["运维部署"],"content":"有关静态博客部署的文章、视频教程已经很多了 大致总结可以分为三类： Github Pages + Github Action（网站托管，如：Vercel） 本地编译 + rsync 远程服务器 本地编译 + 推送对象存储（七牛云） ","date":"2021-11-04","objectID":"/%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/:0:0","tags":["博客"],"title":"静态博客部署的最佳实践","uri":"/%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"},{"categories":["运维部署"],"content":"最佳实践 本地更新完文章提交推送 触发 Github Action Action 的 workflow 中完成静态资源的编译、推送至云服务器 云服务器 Nginx 访问静态资源 之前博客一直部署在 Github+Vercel，奈何美国服务器延迟太高， 国内的阿里云、腾讯云的网站托管、云开发体验太差， 刚好双十一购入三年的 2 核 4G 8M 带宽的轻量服务器（腾讯云 YYDS）！！！ 趁着周末研究研究如何部署到云服务器上， 总体体验不错，满足了我既要远程编译，Github 托管代码、访问速度要快的需求， 这套流程中你只需要写好文章（不需要编博客译环境），推送至 Github 即可， 没有跑完这整个流程之前还比较担心 Github rsync 到腾讯云服务器会不会要很久，毕竟 Github 服务器在美国 实际测试 30s 内就可以完成整套 workflow，还是比较满意的 PS：首次可能会慢点，后续的 rsync 应该都是增量更新 顺带也开启了 HTTP/2.0，还是挺香的 ","date":"2021-11-04","objectID":"/%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/:1:0","tags":["博客"],"title":"静态博客部署的最佳实践","uri":"/%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"},{"categories":["运维部署"],"content":"部分配置文件 使用 PEM 格式生成公钥私钥 ssh-keygen -m PEM -t rsa -b 4096 生成的公钥追加到 authorized_keys 中 cd .ssh/;cat id_rsa.pub \u003e\u003e authorized_keys ","date":"2021-11-04","objectID":"/%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/:2:0","tags":["博客"],"title":"静态博客部署的最佳实践","uri":"/%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"},{"categories":["运维部署"],"content":"Github Action .github/workflows/main.yml # This is a basic workflow to help you get started with Actionsname:github pages# Controls when the workflow will runon:# Triggers the workflow on push or pull request events but only for the main branchpush:branches:[main]paths-ignore:- '.gitignore'- 'README.md'pull_request:branches:[main]# Allows you to run this workflow manually from the Actions tabworkflow_dispatch:# A workflow run is made up of one or more jobs that can run sequentially or in paralleljobs:# This workflow contains a single job called \"build\"deploy:# The type of runner that the job will run onruns-on:ubuntu-latestconcurrency:group:${{github.workflow}}-${{ github.ref }}# Steps represent a sequence of tasks that will be executed as part of the jobsteps:# Checks-out your repository under $GITHUB_WORKSPACE, so your job can access it- uses:actions/checkout@v2# Runs a single command using the runners shell- name:Setup Hugouses:peaceiris/actions-hugo@v2with:hugo-version:'0.85.0'extended:true- name:Buildrun:hugo --minify# Runs a set of commands using the runners shell- name:Github Deployuses:peaceiris/actions-gh-pages@v3if:github.ref == 'refs/heads/main'with:github_token:${{secrets.ACCESS_TOKEN}}publish_dir:./public# Deploy to Server- name:Serveruses:easingthemes/ssh-deploy@mainenv:SSH_PRIVATE_KEY:${{secrets.SERVER_SSH_KEY}}SOURCE:\"public/\"REMOTE_HOST:${{secrets.REMOTE_HOST}}REMOTE_USER:${{secrets.REMOTE_USER}}TARGET:${{secrets.REMOTE_TARGET}} ","date":"2021-11-04","objectID":"/%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/:2:1","tags":["博客"],"title":"静态博客部署的最佳实践","uri":"/%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"},{"categories":["运维部署"],"content":"Nginx 开启了 HTTP/2.0 HTTP 访问 301 跳转到 HTTPS server { listen 80; listen [::]:80; server_name \u003cyour.domain\u003e; return 301 https://$host$request_uri; } server { listen 443 ssl http2; listen [::]:443 ssl http2; server_name \u003cyour.domain\u003e; ssl_certificate \"\u003cyour.pem\u003e\"; ssl_certificate_key \"\u003cyour.key\u003e\"; ssl_session_cache shared:SSL:1m; ssl_session_timeout 10m; ssl_ciphers HIGH:!aNULL:!MD5; ssl_prefer_server_ciphers on; access_log /var/log/nginx/access.log; error_log /var/log/nginx/error.log; location / { root \u003cyour.dir\u003e/public; index index.html; } } ","date":"2021-11-04","objectID":"/%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/:2:2","tags":["博客"],"title":"静态博客部署的最佳实践","uri":"/%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"},{"categories":["做饭记录"],"content":"处理排骨 排骨冷水下锅，放入生姜、葱段、料酒去腥 水开后撇去浮沫 倒出排骨，冷水冲洗，沥干水分 ","date":"2021-11-04","objectID":"/%E7%82%96%E6%8E%92%E9%AA%A8%E6%B1%A4%E7%9A%84%E6%8A%80%E5%B7%A7/:1:0","tags":null,"title":"炖排骨汤的技巧","uri":"/%E7%82%96%E6%8E%92%E9%AA%A8%E6%B1%A4%E7%9A%84%E6%8A%80%E5%B7%A7/"},{"categories":["做饭记录"],"content":"煎制排骨 热锅凉油放入生姜葱段爆香 倒入沥干水分的排骨煎制两面金黄 淋入料酒去腥 倒入开水淹没过排骨 ","date":"2021-11-04","objectID":"/%E7%82%96%E6%8E%92%E9%AA%A8%E6%B1%A4%E7%9A%84%E6%8A%80%E5%B7%A7/:2:0","tags":null,"title":"炖排骨汤的技巧","uri":"/%E7%82%96%E6%8E%92%E9%AA%A8%E6%B1%A4%E7%9A%84%E6%8A%80%E5%B7%A7/"},{"categories":["做饭记录"],"content":"砂锅炖汤 水沸后转入砂锅 加入姜片、花椒、葱结、料酒去腥 大火炖煮至沸腾 加入配菜，如：玉米、山药、胡萝卜等 转小火继续炖煮 1 小时左右（切记不要炖久了，肉会烂成肉渣） 中途不要放盐，吃的时候在放盐 ","date":"2021-11-04","objectID":"/%E7%82%96%E6%8E%92%E9%AA%A8%E6%B1%A4%E7%9A%84%E6%8A%80%E5%B7%A7/:3:0","tags":null,"title":"炖排骨汤的技巧","uri":"/%E7%82%96%E6%8E%92%E9%AA%A8%E6%B1%A4%E7%9A%84%E6%8A%80%E5%B7%A7/"},{"categories":["编程语言"],"content":"编译 go build [-o 输出名] [-i] [编译标记] [包名] 默认我们 go build 的可执行文件都是当前操作系统可执行的文件，如果我想在 macOS 下编译一个 linux 下可执行文件，那需要怎么做呢？ 只需要指定目标操作系统的平台和处理器架构即可，例如 Window 平台终端下按如下方式指定环境变量。 SET CGO_ENABLED=0 // 禁用 CGO SET GOOS=linux // 目标平台是 linux SET GOARCH=amd64 // 目标处理器架构是 amd64 ","date":"2021-10-29","objectID":"/golang%E8%B7%A8%E5%B9%B3%E5%8F%B0%E7%BC%96%E8%AF%91%E5%8F%8A%E4%BC%98%E5%8C%96%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%93%E7%A7%AF/:1:0","tags":["Golang"],"title":"Golang跨平台编译及优化二进制体积","uri":"/golang%E8%B7%A8%E5%B9%B3%E5%8F%B0%E7%BC%96%E8%AF%91%E5%8F%8A%E4%BC%98%E5%8C%96%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%93%E7%A7%AF/"},{"categories":["编程语言"],"content":"macOS 编译 Linux 和 Windows 平台 64 位 可执行程序: CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build CGO_ENABLED=0 GOOS=windows GOARCH=amd64 go build ","date":"2021-10-29","objectID":"/golang%E8%B7%A8%E5%B9%B3%E5%8F%B0%E7%BC%96%E8%AF%91%E5%8F%8A%E4%BC%98%E5%8C%96%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%93%E7%A7%AF/:1:1","tags":["Golang"],"title":"Golang跨平台编译及优化二进制体积","uri":"/golang%E8%B7%A8%E5%B9%B3%E5%8F%B0%E7%BC%96%E8%AF%91%E5%8F%8A%E4%BC%98%E5%8C%96%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%93%E7%A7%AF/"},{"categories":["编程语言"],"content":"Linux 编译 Mac 和 Windows 平台 64 位可执行程序： CGO_ENABLED=0 GOOS=darwin GOARCH=amd64 go build CGO_ENABLED=0 GOOS=windows GOARCH=amd64 go build ","date":"2021-10-29","objectID":"/golang%E8%B7%A8%E5%B9%B3%E5%8F%B0%E7%BC%96%E8%AF%91%E5%8F%8A%E4%BC%98%E5%8C%96%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%93%E7%A7%AF/:1:2","tags":["Golang"],"title":"Golang跨平台编译及优化二进制体积","uri":"/golang%E8%B7%A8%E5%B9%B3%E5%8F%B0%E7%BC%96%E8%AF%91%E5%8F%8A%E4%BC%98%E5%8C%96%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%93%E7%A7%AF/"},{"categories":["编程语言"],"content":"Windows 编译 Mac 平台 64 位可执行程序 SET CGO_ENABLED=0 SET GOOS=darwin SET GOARCH=amd64 go build ","date":"2021-10-29","objectID":"/golang%E8%B7%A8%E5%B9%B3%E5%8F%B0%E7%BC%96%E8%AF%91%E5%8F%8A%E4%BC%98%E5%8C%96%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%93%E7%A7%AF/:1:3","tags":["Golang"],"title":"Golang跨平台编译及优化二进制体积","uri":"/golang%E8%B7%A8%E5%B9%B3%E5%8F%B0%E7%BC%96%E8%AF%91%E5%8F%8A%E4%BC%98%E5%8C%96%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%93%E7%A7%AF/"},{"categories":["编程语言"],"content":"优化 ","date":"2021-10-29","objectID":"/golang%E8%B7%A8%E5%B9%B3%E5%8F%B0%E7%BC%96%E8%AF%91%E5%8F%8A%E4%BC%98%E5%8C%96%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%93%E7%A7%AF/:2:0","tags":["Golang"],"title":"Golang跨平台编译及优化二进制体积","uri":"/golang%E8%B7%A8%E5%B9%B3%E5%8F%B0%E7%BC%96%E8%AF%91%E5%8F%8A%E4%BC%98%E5%8C%96%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%93%E7%A7%AF/"},{"categories":["编程语言"],"content":"新增args Go 编译器默认编译出来的程序会带有符号表和调试信息，一般来说 release 版本可以去除调试信息以减小二进制体积 go build -ldflags=\"-s -w\" -o server main.go -s：忽略符号表和调试信息 -w：忽略DWARFv3调试信息，使用该选项后将无法使用gdb进行调试 ","date":"2021-10-29","objectID":"/golang%E8%B7%A8%E5%B9%B3%E5%8F%B0%E7%BC%96%E8%AF%91%E5%8F%8A%E4%BC%98%E5%8C%96%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%93%E7%A7%AF/:2:1","tags":["Golang"],"title":"Golang跨平台编译及优化二进制体积","uri":"/golang%E8%B7%A8%E5%B9%B3%E5%8F%B0%E7%BC%96%E8%AF%91%E5%8F%8A%E4%BC%98%E5%8C%96%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%93%E7%A7%AF/"},{"categories":["编程语言"],"content":"使用 upx 减小体积 upx 是一个常用的压缩动态库和可执行文件的工具，通常可减少 50-70% 的体积。 upx 的安装方式非常简单，我们可以直接从 github 下载最新的 release 版本，支持 Windows 和 Linux，在 Ubuntu 或 Mac 可以直接使用包管理工具安装。 upx 有很多参数，最重要的则是压缩率，1-9，1 代表最低压缩率，9 代表最高压缩率。 go build -ldflags=\"-s -w\" -o server main.go \u0026\u0026 upx -9 server upx 压缩后的程序和压缩前的程序一样，无需解压仍然能够正常地运行，这种压缩方法称之为带壳压缩，压缩包含两个部分： 在程序开头或其他合适的地方插入解压代码； 将程序的其他部分压缩。 执行时，也包含两个部分： 首先执行的是程序开头的插入的解压代码，将原来的程序在内存中解压出来； 再执行解压后的程序。 也就是说，upx 在程序执行时，会有额外的解压动作，不过这个耗时几乎可以忽略。 如果对编译后的体积没什么要求的情况下，可以不使用 upx 来压缩。一般在服务器端独立运行的后台服务，无需压缩体积。 ","date":"2021-10-29","objectID":"/golang%E8%B7%A8%E5%B9%B3%E5%8F%B0%E7%BC%96%E8%AF%91%E5%8F%8A%E4%BC%98%E5%8C%96%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%93%E7%A7%AF/:2:2","tags":["Golang"],"title":"Golang跨平台编译及优化二进制体积","uri":"/golang%E8%B7%A8%E5%B9%B3%E5%8F%B0%E7%BC%96%E8%AF%91%E5%8F%8A%E4%BC%98%E5%8C%96%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%93%E7%A7%AF/"},{"categories":["编程语言"],"content":"参考 How to reduce compiled file size? StackOverflow ","date":"2021-10-29","objectID":"/golang%E8%B7%A8%E5%B9%B3%E5%8F%B0%E7%BC%96%E8%AF%91%E5%8F%8A%E4%BC%98%E5%8C%96%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%93%E7%A7%AF/:3:0","tags":["Golang"],"title":"Golang跨平台编译及优化二进制体积","uri":"/golang%E8%B7%A8%E5%B9%B3%E5%8F%B0%E7%BC%96%E8%AF%91%E5%8F%8A%E4%BC%98%E5%8C%96%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%93%E7%A7%AF/"},{"categories":["学习记录"],"content":" 本书主要介绍了计算机系统的基本概念, 包括最底层的内存中的数据表示、流水线指令的构成、虚拟存储器、编译系统、动态加载库以及用户应用等。书中提供了大量实际操作, 可以帮助读者更好地理解程序执行的方式, 改进程序的执行效率。 一本相见恨晚的书，非计科出身果然还是有很长的路要走。 首次阅读确实不是很懂，可以暂时放一放 当有了实际编码经验、抽象思维逻辑再阅读，你会有所收获的！ ","date":"2021-08-21","objectID":"/%E5%AD%A6%E4%B9%A0%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/:0:0","tags":["CSAPP"],"title":"学习《深入理解计算机系统》","uri":"/%E5%AD%A6%E4%B9%A0%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"},{"categories":["学习记录"],"content":"教材 我用阿里云盘分享了「深入理解计算机系统（第三版）.pdf」，你可以不限速下载🚀 复制这段内容打开「阿里云盘」App 即可获取 链接：https://www.aliyundrive.com/s/bTBiCehPPJv ","date":"2021-08-21","objectID":"/%E5%AD%A6%E4%B9%A0%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/:0:1","tags":["CSAPP"],"title":"学习《深入理解计算机系统》","uri":"/%E5%AD%A6%E4%B9%A0%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"},{"categories":["学习记录"],"content":"视频 ","date":"2021-08-21","objectID":"/%E5%AD%A6%E4%B9%A0%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/:0:2","tags":["CSAPP"],"title":"学习《深入理解计算机系统》","uri":"/%E5%AD%A6%E4%B9%A0%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"},{"categories":["学习记录"],"content":"其他 https://github.com/EugeneLiu/translationCSAPP https://www.zhihu.com/question/20354069 ","date":"2021-08-21","objectID":"/%E5%AD%A6%E4%B9%A0%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/:0:3","tags":["CSAPP"],"title":"学习《深入理解计算机系统》","uri":"/%E5%AD%A6%E4%B9%A0%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"},{"categories":["运维部署"],"content":"Confluence Confluence 是一个专业的企业知识管理与协同软件，也可以用于构建企业 wiki。使用简单，但它强大的编辑和站点管理特征能够帮助团队成员之间共享信息、文档协作、集体讨论，信息推送 ","date":"2021-07-25","objectID":"/docker%E9%83%A8%E7%BD%B2%E5%B9%B6%E7%A0%B4%E8%A7%A3confluence%E5%92%8Cjira%E5%8F%8A%E6%8F%92%E4%BB%B6/:1:0","tags":["开源软件"],"title":"Docker部署并破解Confluence和JIRA及插件","uri":"/docker%E9%83%A8%E7%BD%B2%E5%B9%B6%E7%A0%B4%E8%A7%A3confluence%E5%92%8Cjira%E5%8F%8A%E6%8F%92%E4%BB%B6/"},{"categories":["运维部署"],"content":"数据库设置 不建议将数据库部署在 Docker 容器，推荐使用云数据库或者物理机数据库。 文档 Confluence Data Center and Server documentation Database Configuration 数据库设置 选择安装的 Confluence 版本，阅读 Database Setup For MySQL 后，修改Mysql 配置文件，本文以 Mysql 8.0 为例 [mysqld] ... character-set-server=utf8mb4 collation-server=utf8mb4_bin default-storage-engine=INNODB max_allowed_packet=256M innodb_log_file_size=2GB transaction-isolation=READ-COMMITTED binlog_format=row log-bin-trust-function-creators = 1 // 如果为 Mysql5.7，关闭 derived_merge 能优化仪表板加载缓慢 optimizer_switch = derived_merge=off ... 如果 sql_mode = NO_AUTO_VALUE_ON_ZERO，请删除此选项 创建数据库 \u0026 用户 创建数据库 CREATEDATABASE\u003cdatabase-name\u003eCHARACTERSETutf8mb4COLLATEutf8mb4_bin; 创建用户 CREATEuser'\u003cconfluenceuser\u003e'@'localhost'IDENTIFIEDBY'\u003cpassword\u003e'; 如果 Confluence 与数据库不在同一台服务器上运行（或者是 Docker 用户），请用 Confluence 服务器的主机名或 IP 地址替换 localhost（也可以使用 %，表示允许所有 host） 授权 GRANTALLPRIVILEGESON\u003cdatabase-name\u003e.*TO'\u003cconfluenceuser\u003e'@'localhost'WITHGRANTOPTION; ","date":"2021-07-25","objectID":"/docker%E9%83%A8%E7%BD%B2%E5%B9%B6%E7%A0%B4%E8%A7%A3confluence%E5%92%8Cjira%E5%8F%8A%E6%8F%92%E4%BB%B6/:1:1","tags":["开源软件"],"title":"Docker部署并破解Confluence和JIRA及插件","uri":"/docker%E9%83%A8%E7%BD%B2%E5%B9%B6%E7%A0%B4%E8%A7%A3confluence%E5%92%8Cjira%E5%8F%8A%E6%8F%92%E4%BB%B6/"},{"categories":["运维部署"],"content":"Docker Compose 文档 镜像：atlassian/confluence-server 破解插件：atlassian-agent 项目已被私有，无法访问 准备工具 破解插件 atlassian-agent.jar 直接使用仓库内 atlassian-agent.jar 数据库驱动 官方镜像并没有内置 MySQL driver，需要自行下载：Database JDBC Drivers。 Mysql 8.0 下载：mysql-connector-java-8.0.22.jar Mysql 5.7 下载：mysql-connector-java-5.1.48.jar docker-compose.yml version:'3'services:confluence:image:\"atlassian/confluence-server\"volumes:- ./atlassian-agent.jar:/var/atlassian/atlassian-agent.jar- ./mysql-connector-java-8.0.22.jar:/opt/atlassian/confluence/confluence/WEB-INF/lib/mysql-connector-java-8.0.22.jar- ~/your-confluence-home:/var/atlassian/application-data/confluenceenvironment:- JAVA_OPTS=\"-javaagent:/var/atlassian/atlassian-agent.jar\"- JVM_MINIMUM_MEMORY=2048m- JVM_MAXIMUM_MEMORY=2048m- JVM_RESERVED_CODE_CACHE_SIZE=512mports:- \"8090:8090\"restart:always 默认内存分配为 1024m，如果需要覆盖 Confluence Server 的默认内存分配，可以通过环境变量 JVM_MINIMUM_MEMORY、JVM_MAXIMUM_MEMORY、JVM_RESERVED_CODE_CACHE_SIZE 控制最小堆 (Xms) 和最大堆(Xmx)。 # 重新创建容器实现修改 docker-compose up --force-recreate -d 运行 docker-compose up -d 查看日志，发现 ========= agent working ========= 则插件正常运行 ","date":"2021-07-25","objectID":"/docker%E9%83%A8%E7%BD%B2%E5%B9%B6%E7%A0%B4%E8%A7%A3confluence%E5%92%8Cjira%E5%8F%8A%E6%8F%92%E4%BB%B6/:1:2","tags":["开源软件"],"title":"Docker部署并破解Confluence和JIRA及插件","uri":"/docker%E9%83%A8%E7%BD%B2%E5%B9%B6%E7%A0%B4%E8%A7%A3confluence%E5%92%8Cjira%E5%8F%8A%E6%8F%92%E4%BB%B6/"},{"categories":["运维部署"],"content":"初始化配置 破解 破解\" 破解 复制 Server ID BT5W-KP7Q-31DT-PTNG，使用容器内的 Java 环境，进入存放 atlassian-agent.jar 目录，运行下方命令生成 Key java -jar atlassian-agent.jar -d -m test@test.com -n BAT -p 'conf' -o http://localhost:8090 -s BT5W-KP7Q-31DT-PTNG 设置数据库 这里使用的宿主机搭建的 Mysql 8.0，一路下一步即可 配置数据库\" 配置数据库 查看授权细节 授权细节\" 授权细节 ","date":"2021-07-25","objectID":"/docker%E9%83%A8%E7%BD%B2%E5%B9%B6%E7%A0%B4%E8%A7%A3confluence%E5%92%8Cjira%E5%8F%8A%E6%8F%92%E4%BB%B6/:1:3","tags":["开源软件"],"title":"Docker部署并破解Confluence和JIRA及插件","uri":"/docker%E9%83%A8%E7%BD%B2%E5%B9%B6%E7%A0%B4%E8%A7%A3confluence%E5%92%8Cjira%E5%8F%8A%E6%8F%92%E4%BB%B6/"},{"categories":["运维部署"],"content":"插件破解 第三方插件将其应用密钥 / 插件关键字作为 - p 参数。如：-p ‘com.valiantys.spreadsheets’ java -jar atlassian-agent.jar -d -m mytest@mytest.com -n BAT -p 'com.valiantys.spreadsheets' -o http://localhost:8090 -s BDMK-KXF1-H7GV-F7QG 查找新应用，选择你想要的应用插件，点击免费使用，点击接受 \u0026 安装，进入管理应用页面，粘贴生成的许可证，点击更新完成破解 插件破解\" 插件破解 ","date":"2021-07-25","objectID":"/docker%E9%83%A8%E7%BD%B2%E5%B9%B6%E7%A0%B4%E8%A7%A3confluence%E5%92%8Cjira%E5%8F%8A%E6%8F%92%E4%BB%B6/:1:4","tags":["开源软件"],"title":"Docker部署并破解Confluence和JIRA及插件","uri":"/docker%E9%83%A8%E7%BD%B2%E5%B9%B6%E7%A0%B4%E8%A7%A3confluence%E5%92%8Cjira%E5%8F%8A%E6%8F%92%E4%BB%B6/"},{"categories":["运维部署"],"content":"JIRA JIRA 是 Atlassian 公司出品的项目与事务跟踪工具，被广泛应用于缺陷跟踪、客户服务、需求收集、流程审批、任务跟踪、项目跟踪和敏捷管理等工作领域。 Jira 搭建流程和 Confluence 类似，这里不再赘述，附上相关内容 ","date":"2021-07-25","objectID":"/docker%E9%83%A8%E7%BD%B2%E5%B9%B6%E7%A0%B4%E8%A7%A3confluence%E5%92%8Cjira%E5%8F%8A%E6%8F%92%E4%BB%B6/:2:0","tags":["开源软件"],"title":"Docker部署并破解Confluence和JIRA及插件","uri":"/docker%E9%83%A8%E7%BD%B2%E5%B9%B6%E7%A0%B4%E8%A7%A3confluence%E5%92%8Cjira%E5%8F%8A%E6%8F%92%E4%BB%B6/"},{"categories":["运维部署"],"content":"文档 Jira Software Data Center and Server documentation Connecting Jira applications to a database 镜像：atlassian/jira-software ","date":"2021-07-25","objectID":"/docker%E9%83%A8%E7%BD%B2%E5%B9%B6%E7%A0%B4%E8%A7%A3confluence%E5%92%8Cjira%E5%8F%8A%E6%8F%92%E4%BB%B6/:2:1","tags":["开源软件"],"title":"Docker部署并破解Confluence和JIRA及插件","uri":"/docker%E9%83%A8%E7%BD%B2%E5%B9%B6%E7%A0%B4%E8%A7%A3confluence%E5%92%8Cjira%E5%8F%8A%E6%8F%92%E4%BB%B6/"},{"categories":["运维部署"],"content":"破解命令 java -jar atlassian-agent.jar -d -m test@test.com -n BAT -p 'jira' -o http://localhost:8080 -s BT5W-KP7Q-31DT-PTNG ","date":"2021-07-25","objectID":"/docker%E9%83%A8%E7%BD%B2%E5%B9%B6%E7%A0%B4%E8%A7%A3confluence%E5%92%8Cjira%E5%8F%8A%E6%8F%92%E4%BB%B6/:2:2","tags":["开源软件"],"title":"Docker部署并破解Confluence和JIRA及插件","uri":"/docker%E9%83%A8%E7%BD%B2%E5%B9%B6%E7%A0%B4%E8%A7%A3confluence%E5%92%8Cjira%E5%8F%8A%E6%8F%92%E4%BB%B6/"},{"categories":["运维部署"],"content":"配置 Confluence 与 Jira 用户数据对接 进入 Jira 选择用户管理 \u003e Jira 用户服务器 \u003e 添加应用程序 添加应用程序\" 添加应用程序 进入 Confluence \u003e 用户管理 \u003e 用户目录 \u003e 添加目录（目录类型为：Atlassian Jira） 配置jira server\" 配置jira server 将 JIRA Server 顺序顶置最上，点击同步即可将 Jira 用户信息同步到 Confluence 添加目录\" 添加目录 如果是通过备份还原的 Jira 及 Confluence 可以直接禁用之前的用户目录然后移除。其他应用程序关联等设置比较简单，自行操作。 ","date":"2021-07-25","objectID":"/docker%E9%83%A8%E7%BD%B2%E5%B9%B6%E7%A0%B4%E8%A7%A3confluence%E5%92%8Cjira%E5%8F%8A%E6%8F%92%E4%BB%B6/:2:3","tags":["开源软件"],"title":"Docker部署并破解Confluence和JIRA及插件","uri":"/docker%E9%83%A8%E7%BD%B2%E5%B9%B6%E7%A0%B4%E8%A7%A3confluence%E5%92%8Cjira%E5%8F%8A%E6%8F%92%E4%BB%B6/"},{"categories":["运维部署"],"content":"异常记录 ","date":"2021-07-25","objectID":"/docker%E9%83%A8%E7%BD%B2%E5%B9%B6%E7%A0%B4%E8%A7%A3confluence%E5%92%8Cjira%E5%8F%8A%E6%8F%92%E4%BB%B6/:3:0","tags":["开源软件"],"title":"Docker部署并破解Confluence和JIRA及插件","uri":"/docker%E9%83%A8%E7%BD%B2%E5%B9%B6%E7%A0%B4%E8%A7%A3confluence%E5%92%8Cjira%E5%8F%8A%E6%8F%92%E4%BB%B6/"},{"categories":["运维部署"],"content":"Confluence 重启后一段时间内无响应 confluence_1 | WARNING: An illegal reflective access operation has occurred confluence_1 | WARNING: Illegal reflective access by com.atlassian.hibernate.adapter.proxy.BytecodeProviderImpl_ImplementV2Proxy (file:/opt/atlassian/confluence/confluence/WEB-INF/lib/hibernate.adapter-1.0.3.jar) to field java.lang.reflect.Field.modifiers confluence_1 | WARNING: Please consider reporting this to the maintainers of com.atlassian.hibernate.adapter.proxy.BytecodeProviderImpl_ImplementV2Proxy confluence_1 | WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations confluence_1 | WARNING: All illegal access operations will be denied in a future release confluence_1 | Security framework of XStream not explicitly initialized, using predefined black list on your own risk. 类似问题： https://community.atlassian.com/t5/Confluence-questions/Confluence-no-longer-responds-Debugging-articles/qaq-p/1404597 https://community.atlassian.com/t5/Confluence-questions/Illegal-reflective-access-by-BytecodeProviderImpl/qaq-p/1255035 https://community.atlassian.com/t5/Confluence-questions/hibernate-adapter-1-0-3-jar/qaq-p/1281057 不过等待一段时间会自动运行正常。。。 ","date":"2021-07-25","objectID":"/docker%E9%83%A8%E7%BD%B2%E5%B9%B6%E7%A0%B4%E8%A7%A3confluence%E5%92%8Cjira%E5%8F%8A%E6%8F%92%E4%BB%B6/:3:1","tags":["开源软件"],"title":"Docker部署并破解Confluence和JIRA及插件","uri":"/docker%E9%83%A8%E7%BD%B2%E5%B9%B6%E7%A0%B4%E8%A7%A3confluence%E5%92%8Cjira%E5%8F%8A%E6%8F%92%E4%BB%B6/"},{"categories":["运维部署"],"content":"备份文件恢复失败 Unable to complete import: An invalid XML character (Unicode: 0x8) was found in the CDATA section. 解压备份文件，下方文档链接中的中的Jar包处理一下 entities.xml 文件，重新打包 https://confluence.atlassian.com/jira/removing-invalid-characters-from-xml-backups-12079.html ","date":"2021-07-25","objectID":"/docker%E9%83%A8%E7%BD%B2%E5%B9%B6%E7%A0%B4%E8%A7%A3confluence%E5%92%8Cjira%E5%8F%8A%E6%8F%92%E4%BB%B6/:3:2","tags":["开源软件"],"title":"Docker部署并破解Confluence和JIRA及插件","uri":"/docker%E9%83%A8%E7%BD%B2%E5%B9%B6%E7%A0%B4%E8%A7%A3confluence%E5%92%8Cjira%E5%8F%8A%E6%8F%92%E4%BB%B6/"},{"categories":["协议"],"content":"说到支持 HTTPS 协议，第一时间想到的是配置各种复杂的证书。实际上大多数代理服务器能够支持 HTTPS 都是通过 HTTP 协议中的 Web 隧道（也有叫做 HTTP 隧道）功能来实现的。 ","date":"2021-05-10","objectID":"/%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%A6%82%E4%BD%95%E6%94%AF%E6%8C%81https/:0:0","tags":["https"],"title":"代理服务器如何支持 HTTPS","uri":"/%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%A6%82%E4%BD%95%E6%94%AF%E6%8C%81https/"},{"categories":["协议"],"content":"Web 隧道 Web 隧道允许用户通过 HTTP 连接发送非 HTTP 流量（例如 FTP，Telnet，SMTP），这样就可以在 HTTP 上携带其他协议数据了。使用 Web 隧道最常见的原因就是要在 HTTP 链接中嵌入非 HTTP 流量。我们知道很多软件都是实现了自己的应用层协议，但是这些软件都支持设置代理，如 QQ，微信。 Web 隧道是用 HTTP 的 CONNECT 方法建立起来的。CONNECT 方法并不是 HTTP/1.1 核心规范的一部分，但却是一种得到广泛应用的扩展。CONNECT 方法请求隧道网关创建一条到达任意目的服务器和端口的 TCP 连接，并对客户端和服务器之间的后继数据进行盲转发。下面截取《HTTP 权威指南》配图，讲讲 CONNECT 方法如何建立一条 Web 隧道。 Connect 连接\" Connect 连接 客户端首先发送了一条 CONNECT 请求给代理服务器。 代理服务器收到了 CONNECT 请求，解析出报文中客户端希望访问的域名及端口号，然后向目标服务器进行 TCP 连接。（图中是到打开到主机 orders.joes-hardware.com 的标准 SSL 端口 443 的连接） 代理服务器一旦和目标网站建立了 TCP 连接，就发送一条 HTTP 200 Connection Established 的响应来通知客户端 Web 隧道建立成功，可以发送数据了。 此时客户端通过 Web 隧道发送的所有数据都会被代理服务器直接转发给目标网站。（如果是 HTTPS 协议则是各种 SSL 握手信息，加密后的 HTTP 报文） 客户端只有收到 200 Connection Established 才会继续发送数据。如果代理服务器和目标网站连接不成功怎么办呢？代理服务器可以自己灵活自定义：连接目标网站失败 502 Bad Gateway、代理认证未通过 407 Proxy Authentication Required 等等。 ","date":"2021-05-10","objectID":"/%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%A6%82%E4%BD%95%E6%94%AF%E6%8C%81https/:1:0","tags":["https"],"title":"代理服务器如何支持 HTTPS","uri":"/%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%A6%82%E4%BD%95%E6%94%AF%E6%8C%81https/"},{"categories":["协议"],"content":"CONNECT 请求 除了起始行之外，CONNECT 的语法与其他 HTTP 方法类似，只不过是主机名和端口号取代了 URI。其中主机和端口都必须指定，不然代理服务器就不清楚与谁建立连接了。 CONNECT home.netscape.com:443 HTTP/1.0 User-Agent: Mozilla/4.0 CONNECT 请求的 header 通常只会携带建立 Web 隧道所需要的信息，而不包含需要传输的请求信息。 常见的 CONNECT 请求 header： User-Agent：用户设备 Proxy-Authorization：认证信息 Proxy-Connection：是否支持长连接 Connect 请求抓包\" Connect 请求抓包 ","date":"2021-05-10","objectID":"/%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%A6%82%E4%BD%95%E6%94%AF%E6%8C%81https/:1:1","tags":["https"],"title":"代理服务器如何支持 HTTPS","uri":"/%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%A6%82%E4%BD%95%E6%94%AF%E6%8C%81https/"},{"categories":["协议"],"content":"CONNECT 响应 发送了请求之后，客户端会等待来自网关的响应。和普通 HTTP 报文一样，响应码 200 表示成功。按照惯例，响应中的原因短语通常被设置为 “Connection Established”。 HTTP/1.0 200 Connection Established Proxy-Agent: Netscape-Proxy/1.1 与普通 HTTP 响应不同，这个响应并不需要包含 Content-Type 首部。此时连接只是对原始字节进行转接，不再是报文的承载者，所以不需要使用内容类型了。 Connect 响应抓包\" Connect 响应抓包 ","date":"2021-05-10","objectID":"/%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%A6%82%E4%BD%95%E6%94%AF%E6%8C%81https/:1:2","tags":["https"],"title":"代理服务器如何支持 HTTPS","uri":"/%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%A6%82%E4%BD%95%E6%94%AF%E6%8C%81https/"},{"categories":["协议"],"content":"WebSocket 正因为有了 Web 隧道，代理服务器不需要其他应用层协议进行额外的编码解析，只要 Web 隧道建立成功之后即可发送任何非 HTTP 流量， 如 websocket 协议。 在 Python 的 websocket-client 框架中，如果使用 HTTP 代理，首先会对代理发送 CONNECT 连接建立 Web 隧道，然后在传输 ws、wss 协议数据 def _tunnel(sock, host, port, auth): debug(\"Connecting proxy...\") connect_header = \"CONNECT %s:%dHTTP/1.1\\r\\n\" % (host, port) connect_header += \"Host: %s:%d\\r\\n\" % (host, port) # TODO: support digest auth. if auth and auth[0]: auth_str = auth[0] if auth[1]: auth_str += \":\" + auth[1] encoded_str = base64encode(auth_str.encode()).strip().decode().replace('\\n', '') connect_header += \"Proxy-Authorization: Basic %s\\r\\n\" % encoded_str connect_header += \"\\r\\n\" dump(\"request header\", connect_header) send(sock, connect_header) try: status, resp_headers, status_message = read_headers(sock) except Exception as e: raise WebSocketProxyException(str(e)) if status != 200: raise WebSocketProxyException( \"failed CONNECT via proxy status: %r\" % status) return sock ","date":"2021-05-10","objectID":"/%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%A6%82%E4%BD%95%E6%94%AF%E6%8C%81https/:2:0","tags":["https"],"title":"代理服务器如何支持 HTTPS","uri":"/%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%A6%82%E4%BD%95%E6%94%AF%E6%8C%81https/"},{"categories":["协议"],"content":"非 Web 隧道 当然，也有的代理服务器能够在不建立 Web 隧道的情况下，实现了对其他应用层协议的解析，从而实现代理转发的目的。 例如 HTTPS 协议，客户端首先和代理服务器进行代理服务器完成 SSL 握手，代理服务器获取到客户端发送的完整请求（明文），然后在和目标主机进行 SSL 握手，成功后转发用户的请求。最后还要确定使用的 HTTP 客户端是否支持连接 HTTPS 代理，因为绝大多数应用层协议客户端都是通过 Web 隧道使用代理。 在 Python 的 HTTP 客户端框架 urllib3 的 1.26.0 版本 中才添加了对 HTPPS 代理连接的支持。 Added support for HTTPS proxies contacting HTTPS servers (Pull #1923, Pull #1806) proxies = { 'http': 'http://proxy_ip:port', # http 请求 'https': 'http://proxy_ip:port', # CONNECT 请求 'https': 'https://proxy_ip:port' # 与 proxy 进行 ssl } ","date":"2021-05-10","objectID":"/%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%A6%82%E4%BD%95%E6%94%AF%E6%8C%81https/:3:0","tags":["https"],"title":"代理服务器如何支持 HTTPS","uri":"/%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%A6%82%E4%BD%95%E6%94%AF%E6%8C%81https/"},{"categories":[""],"content":"墙的原理 在讨论 vpn、proxy 这些之前，有必要先提一下目前主流防火墙的实现原理。GFW 实现网络封锁的手段主要有两种：dns 劫持和 ip 封锁（除此之外，还有 dns 污染和关键词过滤，这里我们不讨论）。 ","date":"2021-03-20","objectID":"/%E6%B5%85%E8%B0%88vpnproxyshadowsocks%E6%9C%BA%E5%9C%BA%E4%B9%8B%E9%97%B4%E7%9A%84%E8%81%94%E7%B3%BB%E5%92%8C%E5%8C%BA%E5%88%AB/:1:0","tags":[""],"title":"浅谈 vpn、proxy、shadowsocks、机场之间的联系和区别","uri":"/%E6%B5%85%E8%B0%88vpnproxyshadowsocks%E6%9C%BA%E5%9C%BA%E4%B9%8B%E9%97%B4%E7%9A%84%E8%81%94%E7%B3%BB%E5%92%8C%E5%8C%BA%E5%88%AB/"},{"categories":[""],"content":"Dns 劫持 ip 是网络上各主机的 “地址”，要想访问 “别人家”，当然得要有地址。但 ip 是一串数字，是给电脑看的，人记起来太麻烦，所以就有了域名（也就是我们常说的网址）和 dns（网域名称系统，Domain Name System）。 域名是一串英文字符串，方便人记忆。dns 将域名和 ip 关联起来，形成映射。用户访问域名所在的目标网站前，将域名发给 dns 服务器询问这对映射关系，拿到对应的 ip 后就可以在茫茫网海中找到那个 “她” 了。而 GFW 所做的就是站在用户和 dns 服务器之间，破坏它们的正常通讯，并向用户回传一个假 ip。用户拿不到真正的 ip，自然也就访问不到本想访问的网站了。 Dns 劫持是 GFW 早期唯一的技术手段，所以那个时候的用户通过修改 Hosts 文件的方式就可以零成本突破封锁了。 ","date":"2021-03-20","objectID":"/%E6%B5%85%E8%B0%88vpnproxyshadowsocks%E6%9C%BA%E5%9C%BA%E4%B9%8B%E9%97%B4%E7%9A%84%E8%81%94%E7%B3%BB%E5%92%8C%E5%8C%BA%E5%88%AB/:1:1","tags":[""],"title":"浅谈 vpn、proxy、shadowsocks、机场之间的联系和区别","uri":"/%E6%B5%85%E8%B0%88vpnproxyshadowsocks%E6%9C%BA%E5%9C%BA%E4%B9%8B%E9%97%B4%E7%9A%84%E8%81%94%E7%B3%BB%E5%92%8C%E5%8C%BA%E5%88%AB/"},{"categories":[""],"content":"IP 封锁 dns 劫持之后，GFW 引入了 ip 封锁，直接锁住了访问目标网站的去路，用户发往被封锁 ip 的任何数据都会被墙截断。 这个时候，依靠类似于修改 Hosts 文件这种低成本方法突破封锁就显得有些天方夜谭了。那么，解决办法是什么呢？答案是：在第三方架设翻墙服务器，中转与目标服务器间的来往流量。目前为止，GFW 采用的是黑名单模式，像 Google、Facebook 这种在黑名单上的网站的 ip 无法访问，而不在黑名单上的第三方不记名 ip 可以。 于是，一切就很明朗了，我们目前几乎所有的翻墙手段都是基于上述原理实现的。vpn 是，shadowsocks 是，还有一些比较冷门的（比如 v2ray）同样如此，只不过它们的技术细节不同（这个我们不会深入）。 ","date":"2021-03-20","objectID":"/%E6%B5%85%E8%B0%88vpnproxyshadowsocks%E6%9C%BA%E5%9C%BA%E4%B9%8B%E9%97%B4%E7%9A%84%E8%81%94%E7%B3%BB%E5%92%8C%E5%8C%BA%E5%88%AB/:1:2","tags":[""],"title":"浅谈 vpn、proxy、shadowsocks、机场之间的联系和区别","uri":"/%E6%B5%85%E8%B0%88vpnproxyshadowsocks%E6%9C%BA%E5%9C%BA%E4%B9%8B%E9%97%B4%E7%9A%84%E8%81%94%E7%B3%BB%E5%92%8C%E5%8C%BA%E5%88%AB/"},{"categories":[""],"content":"VPN VPN，全称 “虚拟私人网络（Virtual Private Network）” 或者是“虚拟专用网络”，是一种加密通讯技术。vpn 是一个统称，它有很多的具体实现，比如 PPTP、L2TP/IPSec 等。 vpn 最常用的场景就是在外网的小伙伴（如酒店网络，家庭 WIFI 等等）访问公司内部的网络使用，如果不使用 vpn，直接连入公司内网，则数据明文在外网中传输会有被窃听的风险。vpn 是一种加密通讯技术，它被设计出来的目的是数据传输安全和网络匿名。 vpn 出现远早于 GFW，所以它不是为了翻墙而生的。而既然不是为翻墙而生，那从翻墙的角度上讲，vpn 协议就存在诸多问题。使用 VPN，不足之处在于数据分流不灵活，会将开启了 VPN 的设备的所有数据流量全部导向至 VPN 服务器上；另外如果 VPN 服务器上有流量监视软件运行，那么用户所传输的数据将有信息安全威胁；进一步来说，由于 VPN 设计的初衷并不是用于翻墙，因此数据流量的特征非常明显，容易引起审查机构注意，导致被封。 所以，VPN 这种翻墙方式基本已经没落了。但即便如此，vpn 作为过去很长一段时间最主流最热门最常用最为人所知的翻墙手段，已然成为翻墙的代名词。即便是 vpn 已不再常用的今天，当人们谈及翻墙的时候，说得最多的仍是：“你有什么好用的 vpn 吗？”。 ","date":"2021-03-20","objectID":"/%E6%B5%85%E8%B0%88vpnproxyshadowsocks%E6%9C%BA%E5%9C%BA%E4%B9%8B%E9%97%B4%E7%9A%84%E8%81%94%E7%B3%BB%E5%92%8C%E5%8C%BA%E5%88%AB/:2:0","tags":[""],"title":"浅谈 vpn、proxy、shadowsocks、机场之间的联系和区别","uri":"/%E6%B5%85%E8%B0%88vpnproxyshadowsocks%E6%9C%BA%E5%9C%BA%E4%B9%8B%E9%97%B4%E7%9A%84%E8%81%94%E7%B3%BB%E5%92%8C%E5%8C%BA%E5%88%AB/"},{"categories":[""],"content":"Proxy（代理） Proxy（代理）又分为正向代理和反向代理。 ","date":"2021-03-20","objectID":"/%E6%B5%85%E8%B0%88vpnproxyshadowsocks%E6%9C%BA%E5%9C%BA%E4%B9%8B%E9%97%B4%E7%9A%84%E8%81%94%E7%B3%BB%E5%92%8C%E5%8C%BA%E5%88%AB/:3:0","tags":[""],"title":"浅谈 vpn、proxy、shadowsocks、机场之间的联系和区别","uri":"/%E6%B5%85%E8%B0%88vpnproxyshadowsocks%E6%9C%BA%E5%9C%BA%E4%B9%8B%E9%97%B4%E7%9A%84%E8%81%94%E7%B3%BB%E5%92%8C%E5%8C%BA%E5%88%AB/"},{"categories":[""],"content":"正向代理 翻墙所用的代理都是正向代理。正向代理主要有 HTTP、HTTP over TLS(HTTPS)、Socks、Socks over TLS 几种。其中，HTTP 和 Socks 无法用于翻墙，HTTPS 和 Socks over TLS 可以用于翻墙。不过，Socks over TLS 几乎没人用，我们这里就不多说了。 Proxy 的历史同样早于 GFW，它最早被设计出来的目的当然也不是翻墙。正向代理最主要的目的和 vpn 差不多，都是用于匿名，但 HTTP 和 Socks 不能加密，只能匿名，HTTPS 既可以匿名，也可以用于加密通信。 从理论上讲，四种代理协议都可以通过 “用户先将数据发给代理服务器，再由代理服务器转发给目的服务器” 的方法达到翻墙目的。但由于 HTTP 和 Socks 都是明文协议，GFW 可以通过检查数据包内的内容得知用户的真实意图，进而拦截数据包。所以，HTTP 和 Socks 一般只用作本地代理。而 HTTPS 协议是加密通讯，GFW 无法得知数据包内的真实内容，类似于关键词过滤的手段无法施展。不仅如此，HTTPS 代理的流量特征和我们平时访问网站时所产生的 HTTPS 流量几乎一模一样，GFW 无法分辨，稳定性爆表。理论上讲，HTTPS 代理无论是安全性，还是在隐匿性，都要比目前最为流行的 shadowsocks 好。 事实上，在所有已知的翻墙协议中，无论是 vpn 协议，还是代理协议，它应该都是最好的。v2ray 的 vmess over tls 也许能和 HTTPS 代理媲美。但 v2ray 存在的时间较短、使用者较少、社区也没有 HTTPS 代理活跃（从全球范围上看），故而，相比于 HTTPS 代理，vmess 协议潜在的安全漏洞可能要多。 当然，HTTPS 代理也有它的缺点，其中最大的缺点就是配置复杂。即便能用默认参数就用默认参数，用户自己只作最低限度的配置，对新手而言，这也是一个无比痛苦的过程。更别说，想要正常使用 HTTPS 代理，你还要购买域名和证书这些，非常麻烦。所以，即便是在 shadowsocks 出现之前，HTTPS 代理也没在大陆流行起来。这也是造成 v2ray 的小众的主要原因之一（另一个是用户没有从 shadowsocks 迁移到 v2ray 的动力），它的配置同样相当复杂。除此之外，HTTPS 代理只能转发 tcp 流量，对 udp 无能为力。 这里推荐刘亚晨先生的一篇文章「各种加密代理协议的简单对比」。 ","date":"2021-03-20","objectID":"/%E6%B5%85%E8%B0%88vpnproxyshadowsocks%E6%9C%BA%E5%9C%BA%E4%B9%8B%E9%97%B4%E7%9A%84%E8%81%94%E7%B3%BB%E5%92%8C%E5%8C%BA%E5%88%AB/:4:0","tags":[""],"title":"浅谈 vpn、proxy、shadowsocks、机场之间的联系和区别","uri":"/%E6%B5%85%E8%B0%88vpnproxyshadowsocks%E6%9C%BA%E5%9C%BA%E4%B9%8B%E9%97%B4%E7%9A%84%E8%81%94%E7%B3%BB%E5%92%8C%E5%8C%BA%E5%88%AB/"},{"categories":[""],"content":"反向代理 反向代理的作用主要是为服务器做缓存和负载均衡。这里不做过多讨论，感兴趣的朋友可以看 这里。顺带一提，shadowsocks 里也有负载均衡的概念，但 shadowsocks 的负载均衡和反向代理的负载均衡不是一个概念。 反向代理的负载均衡是指：在多个真正的服务器前架设一个代理服务器，用户所有的数据都发给代理服务器，然后代理服务器根据各个真实服务器的状态将数据转发给一个任务较少的服务器处理。这样，服务商既可以架设多个服务器分担任务、减轻压力，用户也只要记一个域名或 ip 就可以了。 而 shadowsocks 的负载均衡是指：每隔一段时间更改一次翻墙服务器，将用户的数据平均发给多个不同的翻墙服务器，以避免发往某一个翻墙服务器的流量过多。 ","date":"2021-03-20","objectID":"/%E6%B5%85%E8%B0%88vpnproxyshadowsocks%E6%9C%BA%E5%9C%BA%E4%B9%8B%E9%97%B4%E7%9A%84%E8%81%94%E7%B3%BB%E5%92%8C%E5%8C%BA%E5%88%AB/:5:0","tags":[""],"title":"浅谈 vpn、proxy、shadowsocks、机场之间的联系和区别","uri":"/%E6%B5%85%E8%B0%88vpnproxyshadowsocks%E6%9C%BA%E5%9C%BA%E4%B9%8B%E9%97%B4%E7%9A%84%E8%81%94%E7%B3%BB%E5%92%8C%E5%8C%BA%E5%88%AB/"},{"categories":[""],"content":"shadowsocks 最后，就是我们的 shadowsocks 闪亮登场了。介绍之前，我这里先附上 shadowsocks 的 官网链接。英文比较好的同学建议看看官网上对 shadowsocks 的介绍。 在 shadowsocks 之前，墙内网民主要依靠寻找现成的技术实现翻墙。比如 vpn、HTTPS、tor 的中继网桥以及之后的 meek 插件等等，虽然也有自己的技术，比如一种依靠 Google 隐藏 ip 实现翻墙的技术（名字忘了）, 但毕竟难成大器，再加上 GFW 逐渐加大对 VPN 的干扰，人们迫切需要一种简单可靠的技术来抵御 GFW 的进攻。 于是，大概是在 2013 年吧（具体时间我也不太清楚），@clowwindy 带着他的 shadowsocks 横空出世。Shadowsocks 同样是一种代理协议，但是作为 clowwindy 为国人设计的专门用于翻墙的代理协议，相对于 vpn，shadowsocks 有着极强的隐匿性；相对于 HTTP 代理，shadowsocks 提供了较为完善的加密方案，虽然比不上 HTTPS 代理和 vpn，但使用的也是成熟的工业级的加密算法，普通个人用户完全不用顾虑；相对于 HTTPS 代理，shadowsocks 的安装配置更为简单，中文社区更为活跃，中文文档教程更完善，更符合中国国情。 Shdadowsocks 最初的版本是由 clowwindy 使用 Python（一种目前非常热门的脚本编程语言）实现的。所以 clowwindy 的版本被称为 Python 版。shadowsocks 有点名气之后，不同的开发者使用不同的编程语言为其写了很多分支版本。比如，@cyfdecyf开发维护的 Go 版本，@madeye开发维护的 libev 版本（由纯 C 语言编写，基于 libev 库开发），由 @librehat 开发维护的 c++ 版，由 @zhou0 开发维护的 Perl 版。这些版本的安装使用指南都可以在 shadowsocks 的官网上查阅。 2015 年，clowwindy 因喝茶事件被迫停止了 shadowsocks 的维护，并删除了其开源在 GitHub 上的代码，Python 版就此停滞。但其它版本仍处于维护更新中。其中，更新最频繁，新技术跟进最快的是由 @madeye 维护的 libev 版本。这里有必要说明下，目前，shadowsocks 协议（请区分 “shadowsocks 协议” 和“shadowsocks 协议的具体实现”这两者的区别）是由 shadowsocks 社区内的成员共同维护，协议上任何新改进都是社区成员共同商讨的结果。但对这些变化，不同的版本的 shadowsocks 跟进速度不同。而跟进速度最快的就是我上面说的 libev 版。无论是 SIP007 确认的 ADEA Ciphers（一种同时进行认证和加密的算法），还是 SIP003 引进的 simple-obfs（tor 开发的一种混淆插件），shadowsocks-libev 都是最早引入自己软件的。 shadowsocks 是 c/s 架构，shadowsocks 的客户端则就是百花齐放了，有我们现在用的小飞机（Shadowsocks），ClashX，移动端等等。 ","date":"2021-03-20","objectID":"/%E6%B5%85%E8%B0%88vpnproxyshadowsocks%E6%9C%BA%E5%9C%BA%E4%B9%8B%E9%97%B4%E7%9A%84%E8%81%94%E7%B3%BB%E5%92%8C%E5%8C%BA%E5%88%AB/:6:0","tags":[""],"title":"浅谈 vpn、proxy、shadowsocks、机场之间的联系和区别","uri":"/%E6%B5%85%E8%B0%88vpnproxyshadowsocks%E6%9C%BA%E5%9C%BA%E4%B9%8B%E9%97%B4%E7%9A%84%E8%81%94%E7%B3%BB%E5%92%8C%E5%8C%BA%E5%88%AB/"},{"categories":[""],"content":"机场 随着 GFW 的不断升级，其实 shadowsocks 流量也会被检测出来，导致部署 shadowsocks 的服务器 IP 被封禁。其实 shadowsocks 还只是众多科学上网协议中的一种，其实还有 ssr（ShadowsocksR），v2ray（改善了 shadowsocks 的一些缺点，更难被 GFW 检测到，不过配置复杂），Trojan（上文提到过，模仿 https 流量，隐蔽性更强）。 由于自己购买国外的 vps 部署的协议随着 GFW 的不断升级是有可能被识别到导致封 IP 的，如果 vps 提供商不支持更换 IP，那么你这台 vps 就浪费了。如果不想被封就需要不断学习新的隐蔽性更好的协议，所以对于个人用户来说，学习成本很高。 这时候，机场服务就应运而生，只需要少量的付费，通过一条订阅就可以拿到上百条支持各种协议的线路，即使是那个节点被封，那随便切换一条就行。如今对于普通用户来说，机场已经成为了最多的科学上网方式。 ","date":"2021-03-20","objectID":"/%E6%B5%85%E8%B0%88vpnproxyshadowsocks%E6%9C%BA%E5%9C%BA%E4%B9%8B%E9%97%B4%E7%9A%84%E8%81%94%E7%B3%BB%E5%92%8C%E5%8C%BA%E5%88%AB/:7:0","tags":[""],"title":"浅谈 vpn、proxy、shadowsocks、机场之间的联系和区别","uri":"/%E6%B5%85%E8%B0%88vpnproxyshadowsocks%E6%9C%BA%E5%9C%BA%E4%B9%8B%E9%97%B4%E7%9A%84%E8%81%94%E7%B3%BB%E5%92%8C%E5%8C%BA%E5%88%AB/"},{"categories":[""],"content":"总结 vpn 是是一种加密通讯技术，它的核心技术是在加密，防窃听上。由于 GFW 刚上的时候 vpn 这项技术成熟，vpn 被迫营业，充当起了第一代翻墙手段。 shadowsocks 闪亮登场，有着很强的隐蔽性，配置简单 GFW 不断升级，更多的隐蔽性强的协议 v2ray，Trojan 机场服务，通过订阅拿到上百条线路，并且协议齐全，如果你不太想折腾并且不追求极致，机场服务是个不错的选择。 参考 https://github.com/sxcool1024/freedom https://github.com/shadowsocks ","date":"2021-03-20","objectID":"/%E6%B5%85%E8%B0%88vpnproxyshadowsocks%E6%9C%BA%E5%9C%BA%E4%B9%8B%E9%97%B4%E7%9A%84%E8%81%94%E7%B3%BB%E5%92%8C%E5%8C%BA%E5%88%AB/:8:0","tags":[""],"title":"浅谈 vpn、proxy、shadowsocks、机场之间的联系和区别","uri":"/%E6%B5%85%E8%B0%88vpnproxyshadowsocks%E6%9C%BA%E5%9C%BA%E4%B9%8B%E9%97%B4%E7%9A%84%E8%81%94%E7%B3%BB%E5%92%8C%E5%8C%BA%E5%88%AB/"},{"categories":["操作系统"],"content":"终端快捷键 快捷键应该是每一个需要和终端天天打交道的程序员必备的技能了，如果你还停留在每次前后左右一个字符一个字符移动光标的话，那你需要好好学习下面的终端快捷键，这可以大大提高你的效率 ","date":"2020-08-21","objectID":"/linux%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%BF%AB%E6%8D%B7%E9%94%AE/:1:0","tags":["linux"],"title":"Linux命令行快捷键","uri":"/linux%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%BF%AB%E6%8D%B7%E9%94%AE/"},{"categories":["操作系统"],"content":"最常用 tab 命令或路径的补全键 ","date":"2020-08-21","objectID":"/linux%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%BF%AB%E6%8D%B7%E9%94%AE/:1:1","tags":["linux"],"title":"Linux命令行快捷键","uri":"/linux%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%BF%AB%E6%8D%B7%E9%94%AE/"},{"categories":["操作系统"],"content":"移动光标 Ctrl + a/Home 切换到命令行开始 Ctrl + e/End 切换到命令行末尾 Ctrl + f 光标向右移动一个字符（相当于方向键右键） Ctrl + b 光标向右移动一个字符（相当于方向键左键） ","date":"2020-08-21","objectID":"/linux%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%BF%AB%E6%8D%B7%E9%94%AE/:1:2","tags":["linux"],"title":"Linux命令行快捷键","uri":"/linux%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%BF%AB%E6%8D%B7%E9%94%AE/"},{"categories":["操作系统"],"content":"剪切、粘贴、清除 Ctrl + l 清除屏幕内容，效果等同于 clear 命令 Ctrl + u 清除剪切光标之前的内容 Ctrl + k 剪切清除光标之后的内容 Ctrl + y 粘贴刚才所删除的字符 Ctrl + w 剪切光标所在处之前的一个词（以空格、标点等为分隔符） Ctrl + h 删除光标所在处的前一个字符（相当于退格键） Ctrl + t 颠倒光标所在处及其之前的字符位置，并将光标移动到下一个字符 Alt + t 交换当前与以前单词的位置 Alt + d 剪切光标之后的词 ","date":"2020-08-21","objectID":"/linux%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%BF%AB%E6%8D%B7%E9%94%AE/:1:3","tags":["linux"],"title":"Linux命令行快捷键","uri":"/linux%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%BF%AB%E6%8D%B7%E9%94%AE/"},{"categories":["操作系统"],"content":"控制快捷键 Ctrl + c 终止命令 Ctrl + s 锁住终端 Ctrl + q 解锁终端 Ctrl + z 转入后台运行, 但在当前用户退出后就会终止 Ctrl + d 退出 shell，logout Ctrl +（x u） 按住 Ctrl 的同时再先后按 x 和 u，撤销刚才的操作 ","date":"2020-08-21","objectID":"/linux%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%BF%AB%E6%8D%B7%E9%94%AE/:1:4","tags":["linux"],"title":"Linux命令行快捷键","uri":"/linux%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%BF%AB%E6%8D%B7%E9%94%AE/"},{"categories":["操作系统"],"content":"重复执行命令、查找历史命令 Ctrl + o 重复执行命令 Ctrl + r 在历史命令中查找 （这个非常好用，输入关键字就调出以前的命令了） history 显示你所有执行过的编号 + 历史命令。这个可以配合 !n（n 是编号）来执行某某历史命令 !! 重复执行最后一条命令 (有四种方法) 使用上方向键，并回车执行。 按 !! 并回车执行。 输入 !-1 并回车执行。 按 Ctrl+P 并回车执行。 !\\$ 显示系统最近的一条参数（最后这个比较有用，比如我先用 cat /etc/hosts，然后我想用 vim 编辑。 一般的做法是先用↑ 显示最后一条命令，然后用 Home 移动到命令最前，删除 cat，然后再输入 vim 命 令。其实完全可以用 vim !$ 来代替） cd - 回到前一个工作路径 ","date":"2020-08-21","objectID":"/linux%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%BF%AB%E6%8D%B7%E9%94%AE/:1:5","tags":["linux"],"title":"Linux命令行快捷键","uri":"/linux%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%BF%AB%E6%8D%B7%E9%94%AE/"},{"categories":["操作系统"],"content":"推荐文档 熟练使用命令行是一种常常被忽视，或被认为难以掌握的技能，但实际上，它会提高你作为工程师的灵活性以及生产力。本文是一份我在 Linux 上工作时，发现的一些命令行使用技巧的摘要。有些技巧非常基础，而另一些则相当复杂，甚至晦涩难懂。这篇文章并不长，但当你能够熟练掌握这里列出的所有技巧时，你就学会了很多关于命令行的东西了。 《命令行的艺术》 ","date":"2020-08-21","objectID":"/linux%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%BF%AB%E6%8D%B7%E9%94%AE/:2:0","tags":["linux"],"title":"Linux命令行快捷键","uri":"/linux%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%BF%AB%E6%8D%B7%E9%94%AE/"},{"categories":["操作系统"],"content":"黑苹果和白苹果最大的区别其实在显示效果上。同样一个网页，白苹果的显示就会细腻很多，而黑苹果颗粒感非常严重，造成上述原因是因为大多数苹果设备的屏幕本身的分辨率很高，如果你的显示器分辨率达到视网膜级别的话，哪怕是黑苹果也是默认开启 HiDPI 的。So 本人的 2k 分辨率显示器就很尴尬了，下面记录一下开启 HiDPI 的过程。 ","date":"2020-07-11","objectID":"/%E9%BB%91%E8%8B%B9%E6%9E%9C%E4%B8%80%E9%94%AE%E5%BC%80%E5%90%AFhidpi/:0:0","tags":["黑苹果"],"title":"黑苹果一键开启 HiDPI","uri":"/%E9%BB%91%E8%8B%B9%E6%9E%9C%E4%B8%80%E9%94%AE%E5%BC%80%E5%90%AFhidpi/"},{"categories":["操作系统"],"content":"HiDPI 的概念 有关 retina 和 HiDPI 那点事 总之 HiDPI 是苹果一个牛逼的显示技术，通过牺牲一定的分辨率实现更细腻的显示效果，这就是为什么 2K 显示器开启 HiDPI 的效果要比 1080P 好的原因了。 ","date":"2020-07-11","objectID":"/%E9%BB%91%E8%8B%B9%E6%9E%9C%E4%B8%80%E9%94%AE%E5%BC%80%E5%90%AFhidpi/:1:0","tags":["黑苹果"],"title":"黑苹果一键开启 HiDPI","uri":"/%E9%BB%91%E8%8B%B9%E6%9E%9C%E4%B8%80%E9%94%AE%E5%BC%80%E5%90%AFhidpi/"},{"categories":["操作系统"],"content":"黑苹果开启原生 HiDPI 终端中运行如下命令 sh -c \"$(curl -fsSL https://raw.githubusercontent.com/xzhih/one-key-hidpi/master/hidpi.sh)\" 如果出现 curl: (7) Failed to connect to raw.githubusercontent.com port 443:xxx，应该是被墙了，可以挂上梯子 export https_proxy=http://127.0.0.1:7890 http_proxy=http://127.0.0.1:7890 all_proxy=socks5://127.0.0.1:7890 终端运行后选择相应分辨率重启即可生效！ ","date":"2020-07-11","objectID":"/%E9%BB%91%E8%8B%B9%E6%9E%9C%E4%B8%80%E9%94%AE%E5%BC%80%E5%90%AFhidpi/:2:0","tags":["黑苹果"],"title":"黑苹果一键开启 HiDPI","uri":"/%E9%BB%91%E8%8B%B9%E6%9E%9C%E4%B8%80%E9%94%AE%E5%BC%80%E5%90%AFhidpi/"},{"categories":["操作系统"],"content":"HiDPI 开启效果 可以看到 HiDPI 开启后，「显示器选项」里面的缩放显示如图所示。可随意选择缩放模式而且不会高糊，在显示上明显感觉图标颗粒感更小了，显示更加细腻了。 ","date":"2020-07-11","objectID":"/%E9%BB%91%E8%8B%B9%E6%9E%9C%E4%B8%80%E9%94%AE%E5%BC%80%E5%90%AFhidpi/:3:0","tags":["黑苹果"],"title":"黑苹果一键开启 HiDPI","uri":"/%E9%BB%91%E8%8B%B9%E6%9E%9C%E4%B8%80%E9%94%AE%E5%BC%80%E5%90%AFhidpi/"},{"categories":["终端工具"],"content":" ApacheBench（ab）是用于对 Apache 超文本传输协议（HTTP）服务器进行基准测试的工具。ab 命令会创建很多的并发访问线程，模拟多个访问者同时对某一 URL 地址进行访问。它的测试目标是基于 URL 的，因此，既可以用来测试 Apache 的负载压力，也可以测试 nginx、lighthttp、tomcat、IIS 等其它 Web 服务器的压力。ab 命令对发出负载的计算机要求很低，既不会占用很高 CPU，也不会占用很多内存，但却会给目标服务器造成巨大的负载，其原理类似 CC 攻击。自己测试使用也须注意，否则一次上太多的负载，可能造成目标服务器因资源耗完，严重时甚至导致死机。 ","date":"2020-05-26","objectID":"/apachebench-http%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/:0:0","tags":[""],"title":"ApacheBench HTTP 服务器基准测试工具使用总结","uri":"/apachebench-http%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"},{"categories":["终端工具"],"content":"ApacheBench 安装 ","date":"2020-05-26","objectID":"/apachebench-http%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/:1:0","tags":[""],"title":"ApacheBench HTTP 服务器基准测试工具使用总结","uri":"/apachebench-http%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"},{"categories":["终端工具"],"content":"macOS Mac 下自带 apache，查看版本： apachectl -v 查看 ab 版本: ab -V ","date":"2020-05-26","objectID":"/apachebench-http%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/:1:1","tags":[""],"title":"ApacheBench HTTP 服务器基准测试工具使用总结","uri":"/apachebench-http%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"},{"categories":["终端工具"],"content":"Window Windows 系统 Apache：下载链接 ","date":"2020-05-26","objectID":"/apachebench-http%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/:1:2","tags":[""],"title":"ApacheBench HTTP 服务器基准测试工具使用总结","uri":"/apachebench-http%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"},{"categories":["终端工具"],"content":"Linux Ubuntu apt-get install apache2-utils CentOS yum -y install httpd-tools ","date":"2020-05-26","objectID":"/apachebench-http%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/:1:3","tags":[""],"title":"ApacheBench HTTP 服务器基准测试工具使用总结","uri":"/apachebench-http%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"},{"categories":["终端工具"],"content":"ApacheBench 使用 ","date":"2020-05-26","objectID":"/apachebench-http%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/:2:0","tags":[""],"title":"ApacheBench HTTP 服务器基准测试工具使用总结","uri":"/apachebench-http%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"},{"categories":["终端工具"],"content":"Options ab 压力测试工具的用法，查看： ab -h # 或者 man ab Usage: ab [options] [http[s]://]hostname[:port]/path Options are: -n requests Number of requests to perform # 在测试会话中所执行的请求个数（本次测试总共要访问页面的次数）。默认时，仅执行一个请求。 -c concurrency Number of multiple requests to make at a time # 一次产生的请求个数（并发数）。默认是一次一个。 -t timelimit Seconds to max. to spend on benchmarking This implies -n 50000 # 测试所进行的最大秒数。其内部隐含值是 - n 50000。它可以使对服务器的测试限制在一个固定的总时间以内。默认时，没有时间限制。 -s timeout Seconds to max. wait for each response Default is 30 seconds # 套接字超时之前要等待的最大秒数。默认值为 30 秒。在 2.4.4 及更高版本中可用。 -b windowsize Size of TCP send/receive buffer, in bytes # TCP 发送 / 接收缓冲区的大小，以字节为单位。 -B address Address to bind to when making outgoing connections # 建立传出连接时要绑定的地址。 -p postfile File containing data to POST. Remember also to set -T # 包含要发布的数据的文件。记住也要设置 - T。 -u putfile File containing data to PUT. Remember also to set -T # 包含数据到 PUT 的文件。记住也要设置 - T。 -T content-type Content-type header to use for POST/PUT data, eg. 'application/x-www-form-urlencoded' Default is 'text/plain' # 用于 POST / PUT 数据的内容类型标头，例如 application/x-www-form-urlencoded。默认值为 text/plain。 -v verbosity How much troubleshooting info to print # 设置详细级别 4 上方将在标题上显示信息，3 上方将显示响应代码（404、200 等），2 上方将显示警告和信息。 -w Print out results in HTML tables # 在 HTML 表格中打印出结果。默认表是两列宽，带有白色背景。 -i Use HEAD instead of GET # 做 HEAD 请求，而不是 GET。 -x attributes String to insert as table attributes # 用作的属性的字符串 \u003ctable\u003e。插入属性。\u003ctable here \u003e -y attributes String to insert as tr attributes # 用作的属性的字符串 \u003ctr\u003e。 -z attributes String to insert as td or th attributes # 用作的属性的字符串 \u003ctd\u003e。 -C attribute Add cookie, eg. 'Apache=1234'. (repeatable) # cookie-name=value 对请求附加一个 Cookie: 行。 其典型形式是 name=value 的一个参数对。此参数可以重复，用逗号分割。 -H attribute Add Arbitrary header line, eg. 'Accept-Encoding: gzip' Inserted after all normal header lines. (repeatable) # 将额外的标头添加到请求。该参数是典型地在一个有效报头线的形式，含有一个冒号分隔的字段值对（即，\"Accept-Encoding: zip/zop;8bit\"）。 -A attribute Add Basic WWW Authentication, the attributes are a colon separated username and password. # 向服务器提供 BASIC 身份验证凭据。用户名和密码用单个: 分隔，并通过编码为 base64 的网络发送。无论服务器是否需要该字符串，都将发送该字符串（即，已发送所需的 401 身份验证）。 -P attribute Add Basic Proxy Authentication, the attributes are a colon separated username and password. # 在代理途中提供 BASIC 身份验证凭据。用户名和密码用单个: 分隔，并通过编码为 base64 的网络发送。不管代理是否需要它都将发送该字符串（即，已发送所需的 407 代理身份验证）。 -X proxy:port Proxyserver and port number to use # 使用代理服务器处理请求。 -V Print version number and exit # 显示版本号并退出。 -k Use HTTP KeepAlive feature # 启用 HTTP KeepAlive 功能，即在一个 HTTP 会话中执行多个请求。默认为 no KeepAlive。 -d Do not show percentiles served table. # 不要显示 “XX [ms] 表中的投放百分比”。（旧版支持）。 -S Do not show confidence estimators and warnings. # 当平均值和中位数相距标准偏差的一倍或两倍以上时，请勿显示中位数和标准偏差值，也不会显示警告 / 错误消息。并默认为最小值 / 平均值 / 最大值。（旧版支持）。 -q Do not show progress when doing more than 150 requests # 当处理 150 个以上的请求时，每 10％或 100 个左右的请求 ab 输出进度计数 stderr。该 -q 标志将禁止显示这些消息。 -l Accept variable document length (use this for dynamic pages) # 如果响应的长度不是恒定的，请不要报告错误。这对于动态页面很有用。在 2.4.7 及更高版本中可用。 -g filename Output collected data to gnuplot format file. # 将所有测量值写为 “gnuplot” 或 TSV（制表符单独值）文件。此文件可以轻松导入到 Gnuplot，IDL，Mathematica，Igor 甚至 Excel 等软件包中。标签位于文件的第一行。 -e filename Output CSV file with percentages served # 编写一个逗号分隔值（CSV）文件，其中包含为每个百分比（从 1％到 100％）提供该百分比请求所花费的时间（以毫秒为单位）。通常，它比 “gnuplot” 文件有用。因为结果已经 “装箱” 了。 -r Don not exit on socket receive errors. # 套接字接收错误时不退出 -m method Method name # 请求的自定义 HTTP 方法。在 2.4.10 及更高版本中可用。 -h Display usage information (this message) # 显示使用情况信息。 -I Disable TLS Server Name Indication (SNI) extension # 禁用 TLS 服务器名称指示 (SNI) 扩展 -Z ciphersuite Specify SSL/TLS cipher suite (See openssl ciphers) # 指定 SSL / TLS 密码套件（请参阅 openssl 密码） -f protocol Specify SSL/TLS protocol (SSL2, TLS1, TLS1.1, TLS1.2 or ALL) # 指定 SSL / TLS 协议（SSL2，SSL3，TLS1，TLS1.1，TLS1.2 或 ALL）。TLS1.1 和 TLS1.2 支持在 2.4.4 及更高版本中提供。 -E certfile Specify optional client certificate chain and private key # 指定可选的客户端证书链和私钥 ","date":"2020-05-26","objectID":"/apachebench-http%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/:2:1","tags":[""],"title":"ApacheBench HTTP 服务器基准测试工具使用总结","uri":"/apachebench-http%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"},{"categories":["终端工具"],"content":"Output 执行命令 ab -n 1000 -c 200 http://pts.aliyun.com/lite/index.htm/ 获取结果分析 # apache 版本信息 This is ApacheBench, Version 2.3 \u003c$Revision: 1843412 $\u003e Copyright 1996 Adam Twiss, Zeus Technology Ltd, http://www.zeustech.net/ Licensed to The Apache Software Foundation, http://www.apache.org/ Benchmarking pts.aliyun.com (be patient) Completed 100 requests Completed 200 requests Completed 300 requests Completed 400 requests Completed 500 requests Completed 600 requests Completed 700 requests Completed 800 requests Completed 900 requests Completed 1000 requests Finished 1000 requests # 请求返回 header 类型 Server Software: Tengine/Aserver # 请求 ip 或者域名 Server Hostname: pts.aliyun.com # 请求端口，当前请求为 https 所以端口为 443，请求 https 端口 80 Server Port: 80 # 从命令行字符串解析请求 URI。 Document Path: /lite/index.htm/ # 这是第一个成功返回的文档的大小（以字节为单位）。如果在测试过程中文档长度发生变化，则将响应视为错误。 Document Length: 357 bytes # 测试期间使用的并发客户端数 Concurrency Level: 200 从建立连接到最后接受完成总时间 Time taken for tests: 1.280 seconds # 完成请求数 Complete requests: 1000 # 失败请求数 Failed requests: 0 # 不在 200 系列响应代码中的响应数。如果所有响应均为 200，则不会打印此字段。 Non-2xx responses: 1000 # 从服务器接收的字节总数 Total transferred: 642000 bytes # HTML 接收字节数，减去了 Total transferred 中 HTTP 响应数据中的头信息的长度 HTML transferred: 357000 bytes # 吞吐率：每秒请求数（总请求数 / 总时间，相当于 LR 中的每秒事务数 TPS） Requests per second: 781.47 [#/sec] (mean) # 用户平均请求等待时间 Time per request: 255.928 [ms] (mean) # 服务器处理每个请求平均响应时间，mean 表示为平均值 Time per request: 1.280 [ms] (mean, across all concurrent requests) # 由公式计算得出的传输速率 totalread / 1024 / timetaken Transfer rate: 489.95 [Kbytes/sec] received # 连接消耗时间分解 Connection Times (ms) min mean[+/-sd] median max 最小值 平均值 标准差 中间值 最大值 Connect: 22 30 4.0 30 38 Processing: 22 95 164.5 34 1200 Waiting: 22 83 154.3 33 1200 Total: 46 125 163.4 66 1227 # 按完成请求的百分比，得出完成请求中花费时间最长的那一个请求的时间，也就是这些请求完成时间的最大值（毫秒） Percentage of the requests served within a certain time (ms) # 50% 请求完成时间的最大值是 66 毫秒 50% 66 66% 69 75% 71 80% 80 90% 317 # 90% 请求完成时间的最大值是 148 毫秒 95% 536 98% 744 99% 825 # // 100% 请求完成时间的最大值是 1227 毫秒（最长请求） 100% 1227 (longest request) ","date":"2020-05-26","objectID":"/apachebench-http%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/:2:2","tags":[""],"title":"ApacheBench HTTP 服务器基准测试工具使用总结","uri":"/apachebench-http%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"},{"categories":["终端工具"],"content":"性能指标 ","date":"2020-05-26","objectID":"/apachebench-http%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/:3:0","tags":[""],"title":"ApacheBench HTTP 服务器基准测试工具使用总结","uri":"/apachebench-http%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"},{"categories":["终端工具"],"content":"1、吞吐率（Requests per second） 服务器并发处理能力的量化描述，单位是 reqs/s，指的是在某个并发用户数下单位时间内处理的请求数。某个并发用户数下单位时间内能处理的最大请求数，称之为最大吞吐率。 记住：吞吐率是基于并发用户数的。这句话代表了两个含义： a、吞吐率和并发用户数相关； b、不同的并发用户数下，吞吐率一般是不同的。 计算公式：总请求数 / 处理完成这些请求数所花费的时间，即： Request per second=Complete requests/Time taken for tests 必须要说明的是，这个数值表示当前机器的整体性能，值越大越好。 ","date":"2020-05-26","objectID":"/apachebench-http%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/:3:1","tags":[""],"title":"ApacheBench HTTP 服务器基准测试工具使用总结","uri":"/apachebench-http%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"},{"categories":["终端工具"],"content":"2、并发连接数（The number of concurrent connections） 并发连接数指的是某个时刻服务器所接受的请求数目，简单的讲，就是一个会话。 ","date":"2020-05-26","objectID":"/apachebench-http%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/:3:2","tags":[""],"title":"ApacheBench HTTP 服务器基准测试工具使用总结","uri":"/apachebench-http%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"},{"categories":["终端工具"],"content":"3、并发用户数（Concurrency Level） 要注意区分这个概念和并发连接数之间的区别，一个用户可能同时会产生多个会话，也即连接数。在 HTTP/1.1 下，IE7 支持两个并发连接，IE8 支持 6 个并发连接，FireFox3 支持 4 个并发连接，所以相应的，我们的并发用户数就得除以这个基数。 ","date":"2020-05-26","objectID":"/apachebench-http%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/:3:3","tags":[""],"title":"ApacheBench HTTP 服务器基准测试工具使用总结","uri":"/apachebench-http%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"},{"categories":["终端工具"],"content":"4、用户平均请求等待时间（Time per request） 计算公式：处理完成所有请求数所花费的时间 /（总请求数 / 并发用户数），即：Time per request=Time taken for tests/（Complete requests/Concurrency Level） ","date":"2020-05-26","objectID":"/apachebench-http%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/:3:4","tags":[""],"title":"ApacheBench HTTP 服务器基准测试工具使用总结","uri":"/apachebench-http%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"},{"categories":["终端工具"],"content":"5、服务器平均请求等待时间（Time per request:across all concurrent requests） 计算公式：处理完成所有请求数所花费的时间 / 总请求数，即： Time taken for/testsComplete requests 可以看到，它是吞吐率的倒数。同时，它也等于用户平均请求等待时间 / 并发用户数，即： Time per request/Concurrency Level ","date":"2020-05-26","objectID":"/apachebench-http%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/:3:5","tags":[""],"title":"ApacheBench HTTP 服务器基准测试工具使用总结","uri":"/apachebench-http%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"},{"categories":["随笔"],"content":"毕业进入公司起，直属 Leader 常常提到：「编程不仅仅是知识和技能，更重要的是去领会编程领域的文化」。 刚进入公司的我似乎并没有马上接受这一点，认为这可能只是所谓的 “玄学” 罢了，所以也就是当作任务记下了，并没有很好的理会。 直到我工作了一年后，疫情期间读完 Leader 发来的一篇《如何成为一名黑客》，文章似乎解答了我初入编程行业的疑惑并且指明了未来的方向。 标题是如何成为一名黑客，这里的黑客并不是我们所认为的在网络中来无影去无踪的 “黑客”。在我看来，这篇文章讲述的是你如何成为一名优秀并且受人尊敬的计算机工程师。 ","date":"2020-04-06","objectID":"/%E5%A6%82%E4%BD%95%E6%88%90%E4%B8%BA%E4%B8%80%E5%90%8D%E9%BB%91%E5%AE%A2/:0:0","tags":null,"title":"如何成为一名黑客","uri":"/%E5%A6%82%E4%BD%95%E6%88%90%E4%B8%BA%E4%B8%80%E5%90%8D%E9%BB%91%E5%AE%A2/"},{"categories":["随笔"],"content":"基本的态度 这个世界充满了令人着迷的问题等着我们去解决 你要从解决问题，磨练技术，以及锻炼智力中得到基本的享受以及动力。的确，回想这一年的工作时光，另我开心的事情莫过于解决了棘手问题，学习了一门新的语言，自己完成的功能第二天就上线，得到了客户的认可等等。 一个问题不应该被解决两次 不应该把宝贵的时间浪费在发明轮子上。初入公司我想着把很多 python2 的代码重构成 python3，现在想想确实浪费时间，应该着重于解决新的问题而不是在旧问题上浪费时间。 无聊和乏味的工作是罪恶的 重复性劳动浪费我们解决新问题的时间，而解决新问题才是最大的价值所在。提取公共函数，将日常的工作变成自动化等等。 崇尚自由 其实这一点并不是很理解，产品经理提出无理的需求？？？ 2020/09/10 更新：这个上升到政治层面就比较好理解了，比如美国打压 WeChat 和 Tik Tok 态度不能代替能力 只具备这些态度并不能使你成为一名黑客，也不能使你成为一个运动健将和摇滚明星。成为一名黑客需要智力、实践、奉献精神、以及辛苦的工作。 ","date":"2020-04-06","objectID":"/%E5%A6%82%E4%BD%95%E6%88%90%E4%B8%BA%E4%B8%80%E5%90%8D%E9%BB%91%E5%AE%A2/:1:0","tags":null,"title":"如何成为一名黑客","uri":"/%E5%A6%82%E4%BD%95%E6%88%90%E4%B8%BA%E4%B8%80%E5%90%8D%E9%BB%91%E5%AE%A2/"},{"categories":["随笔"],"content":"基本的技能 学习如何编程（这里包括以下内容有几句话写的很好，我想全搬运过来） 有一个大体的规律，就是如果你过于偏重使用一种语言，这种语言一方面会成为你得心应手的工具，另一方面也会阻碍你的学习。有这个问题的不只是编程语言，类似 RubyOnRails、CakePHP、以及 Django 的 web 应用框架也有这个问题，它们只会让你肤浅地懂得一些东西，当你碰到难以解决的问题或者需要调试时，你就可能不知所措了。 单单学习编程语言并不会让你达到黑客的程度，甚至连程序员的程度都难企及——你需要脱离某种编程语言的束缚，学习通过编程解决问题的思路。要成为一个真正的黑客，你需要达到几天就能学会一门编程语言的水平，你可以将文档里的信息和你已经掌握的知识结合起来，很快就学会一门编程语言。这意味着你需要先学会机种思路截然不同的语言才行。 编程是一个复杂的技能，我无法给你完整的指南来教会你如何编程，不过我可以告诉你，书本和课程也无法教会你如何编程——很多黑客，或者也许几乎所有的黑客，都是靠自学的。你从书本上学到语言的特点——只是一些皮毛，但要使书面知识成为自身技能，你只能通过实践和虚心向他人学习。因此你要做的就是 (a) 读代码，(b) 写代码。 学习编程就象学习自然语言写作一样。最好的做法是读一些大师的名著，试着自己写点东西，再读些，再写点，再读些，再写点…… 如此往复，直到你的文章具备范文的力量和感觉为止。 学会使用开源的 Unix 系统 Unix 还是 Internet 的操作系统。你可以学会上网却不知道 Unix，但你不了解 Unix 就无法成为一名 Internet 黑客。因此，今天的黑客文化在很大程度上是以 Unix 为核心的。（这点并不总是真的，一些很早的黑客对此一直很不满，但 Unix 和 Internet 之间的联系已是如此之强，就连 Microsoft 这样强力的公司也对此也无可奈何。） 学会使用万维网以及编写 HTML 学会使用 Google，Stack Overflow，Github 等等 学习英语，如果你的水平不够的话 Linus Torvalds 是芬兰人，但他的代码注解是用英语写的（很明显他从没想过其他的可能性）。他流利的英语。是他能够管理全球范围的 Linux 开发人员社区的重要因素，这是一个值得学习的例子。 就算你的母语是英语，这也无法保证你的语言技能足够达到黑客的标准。如果你的写作文字不通、语法混乱、错字连篇，包括我在内的大部分的黑客都会忽略你的存在。虽然写作马虎不一定意味着思考也马虎，但我们发现两者的关联性还是挺强的——马虎的头脑对我们来说毫无价值，如果你写作能力不够，就好好学习写作吧。（划重点，终于知道王哥为什么每次都会特别强调然后纠正我的错别字了） ","date":"2020-04-06","objectID":"/%E5%A6%82%E4%BD%95%E6%88%90%E4%B8%BA%E4%B8%80%E5%90%8D%E9%BB%91%E5%AE%A2/:2:0","tags":null,"title":"如何成为一名黑客","uri":"/%E5%A6%82%E4%BD%95%E6%88%90%E4%B8%BA%E4%B8%80%E5%90%8D%E9%BB%91%E5%AE%A2/"},{"categories":["随笔"],"content":"提高自己在编程圈中的地位 以下就是以后的人生所追求的吧，自己离这些还很遥远。 撰写开源软件 黑客领域里最受尊敬的偶像，是那些写了大型的、好用的、用途广泛的软件，并把它们发布出来，使得每人都在使用他软件的人。 帮助测试并调试开源软件 如果你是个新手，试着找一个你感兴趣的正在开发中的程序，做一个好的 beta 测试员。你会自然地从帮着测试，进步到帮着抓 bug，到最后帮着改程序。你会从中学到很多，而且善因种善果，以后别人也会很乐意帮助你。 发布有用的信息 另一件好事是收集整理有用有趣的信息，做成网页或类似 FAQ 的文档，并且让大家都能看到。技术性 FAQ 的维护者会受到和开源代码的作者一样多的尊敬。（比如 Github 上面很多 awesome language 和国内很多大佬的博客，录制的教程等等） 帮助维护基础设施的运转 黑客文化（还有互联网工程方面的发展）是靠志愿者推动的。要使 Internet 能正常工作，就要有大量枯燥的工作不得不去完成——管理邮件列表和新闻组，维护大型软件库，开发 RFC 和其它技术标准等等。 做这类事情的人会得到很多尊敬，因为每人都知道这些事情费时颇多，而又不象编程那样有趣。做这些事情需要奉献精神。 为黑客文化本身服务 黑客文化没有领袖，这点是确认无疑的。但黑客圈里确实有些文化英雄、部落长者、史学家、还有发言人。如果你在这圈里呆足够长时间，你也许也能成为其中之一。 记住：黑客们不相信他们的部落长者的自夸，因此过分追求这种名誉是危险的。与其奋力追求，不如先摆正自己的位置，等它自己落到你的手中——那时则要做到谦虚和优雅。 常读常新，每隔一段时间读一遍都会有新的收获。最后附上这篇文档。 如何成为一名黑客 ","date":"2020-04-06","objectID":"/%E5%A6%82%E4%BD%95%E6%88%90%E4%B8%BA%E4%B8%80%E5%90%8D%E9%BB%91%E5%AE%A2/:3:0","tags":null,"title":"如何成为一名黑客","uri":"/%E5%A6%82%E4%BD%95%E6%88%90%E4%B8%BA%E4%B8%80%E5%90%8D%E9%BB%91%E5%AE%A2/"},{"categories":["编程语言"],"content":"原文 Beautiful is better than ugly. Explicit is better than implicit. Simple is better than complex. Complex is better than complicated. Flat is better than nested. Sparse is better than dense. Readability counts. Special cases aren’t special enough to break the rules. Although practicality beats purity. Errors should never pass silently. Unless explicitly silenced. In the face of ambiguity, refuse the temptation to guess. There should be one– and preferably only one –obvious way to do it. Although that way may not be obvious at first unless you’re Dutch. Now is better than never. Although never is often better than right now. If the implementation is hard to explain, it’s a bad idea. If the implementation is easy to explain, it may be a good idea. Namespaces are one honking great idea – let’s do more of those! ","date":"2020-01-16","objectID":"/python%E4%B9%8B%E7%A6%85/:1:0","tags":["Python"],"title":"Python之禅","uri":"/python%E4%B9%8B%E7%A6%85/"},{"categories":["编程语言"],"content":"解读 The Zen of Python 是 Python 语言的指导原则，遵循这些基本原则，你就可以像个 Pythonista 一样编程。具体内容你可以在 Python 命令行输 import this 看到： Beautiful is better than ugly. # 优美胜于丑陋（Python 以编写优美的代码为目标） Explicit is better than implicit. # 明了胜于晦涩（优美的代码应当是明了的，命名规范，风格相似） Simple is better than complex. # 简洁胜于复杂（优美的代码应当是简洁的，不要有复杂的内部实现） Complex is better than complicated. # 复杂胜于凌乱（如果复杂不可避免，那代码间也不能有难懂的关系，要保持接口简洁） Flat is better than nested. # 扁平胜于嵌套（优美的代码应当是扁平的，不能有太多的嵌套） Sparse is better than dense. # 间隔胜于紧凑（优美的代码有适当的间隔，不要奢望一行代码解决问题） Readability counts. # 可读性很重要（优美的代码是可读的） Special cases aren’t special enough to break the rules. Although practicality beats purity. # 即便假借特例的实用性之名，也不可违背这些规则（这些规则至高无上） Errors should never pass silently. Unless explicitly silenced. # 不要包容所有错误，除非你确定需要这样做（精准地捕获异常，不写 except:pass 风格的代码） In the face of ambiguity, refuse the temptation to guess. # 当存在多种可能，不要尝试去猜测 There should be one– and preferably only one –obvious way to do it. # 而是尽量找一种，最好是唯一一种明显的解决方案（如果不确定，就用穷举法） Although that way may not be obvious at first unless you’re Dutch. # 虽然这并不容易，因为你不是 Python 之父（这里的 Dutch 是指 Guido） Now is better than never. Although never is often better than right now. # 做也许好过不做，但不假思索就动手还不如不做（动手之前要细思量） If the implementation is hard to explain, it’s a bad idea. # 如果你无法向人描述你的方案，那肯定不是一个好方案 If the implementation is easy to explain, it may be a good idea. # 如果你能向人简洁描述你的方案，那也许是一个好方案（方案测评标准） Namespaces are one honking great idea – let’s do more of those! # 命名空间是一种绝妙的理念，我们应当多加利用（倡导与号召） 这首特别的 “诗” 开始作为一个笑话，但它确实包含了很多关于 Python 背后的哲学真理。Python 之禅已经正式成文 PEP 20，具体内容见：PEP 20 ","date":"2020-01-16","objectID":"/python%E4%B9%8B%E7%A6%85/:2:0","tags":["Python"],"title":"Python之禅","uri":"/python%E4%B9%8B%E7%A6%85/"},{"categories":["学习记录"],"content":"这几天整理了大学期间的书籍，发现了当时选修日语课时自己总结打印出来的的日语五十音巧记，现在看到还有点好笑，不过当时确实帮助自己应付过了期末考试。直到现在两年过去了，自己还是可以背出日语五十音前面几十个，这里就记录一下吧，万一以后有用呢 ^.^ ","date":"2020-01-05","objectID":"/%E6%97%A5%E8%AF%AD%E4%BA%94%E5%8D%81%E9%9F%B3%E7%AC%A8%E6%8B%99%E8%AE%B0%E5%BF%86/:0:0","tags":["日语"],"title":"日语五十音笨拙记忆","uri":"/%E6%97%A5%E8%AF%AD%E4%BA%94%E5%8D%81%E9%9F%B3%E7%AC%A8%E6%8B%99%E8%AE%B0%E5%BF%86/"},{"categories":["学习记录"],"content":"あ行 清音 あア “女” 孩子胖 “了” 一圈, 惨叫了一声 “啊 (a)” いイ 平假名い和片假名イ拼在一起就会组成一个汉字 “以 (i)\"，读音也是以 うウ 平假名う很像字母 W 横过来,“屋 (u)”, 片假名ウ像“家” 字的宝盖头, 有家有房 “屋” えエ “元” 朝的 “工” 人很悲 “哀 (e)” おオ 有学 “术” 的“才”子都很 “傲(o)” 气 ","date":"2020-01-05","objectID":"/%E6%97%A5%E8%AF%AD%E4%BA%94%E5%8D%81%E9%9F%B3%E7%AC%A8%E6%8B%99%E8%AE%B0%E5%BF%86/:1:0","tags":["日语"],"title":"日语五十音笨拙记忆","uri":"/%E6%97%A5%E8%AF%AD%E4%BA%94%E5%8D%81%E9%9F%B3%E7%AC%A8%E6%8B%99%E8%AE%B0%E5%BF%86/"},{"categories":["学习记录"],"content":"か行 清音 浊音 かカ 因为被 “卡 (ka)” 住了，所以要多用 “一点”” 力 \" ga( が ガ) きキ 长得像琵琶, 琵琶调音 key(ki) gi( ぎ ギ) くク 小时候 “小于” 别人, 长大后终于 “大于” 别人, 感动的要 “哭(ku)” 了 gu( ぐ グ) けケ “开 (ke)” 了一 “个” 豆 “汁” 店 ge( げ ゲ) こコ “扣 (ko)” 了“两条鱼” 放在鱼篓里 go( ご ゴ) ","date":"2020-01-05","objectID":"/%E6%97%A5%E8%AF%AD%E4%BA%94%E5%8D%81%E9%9F%B3%E7%AC%A8%E6%8B%99%E8%AE%B0%E5%BF%86/:2:0","tags":["日语"],"title":"日语五十音笨拙记忆","uri":"/%E6%97%A5%E8%AF%AD%E4%BA%94%E5%8D%81%E9%9F%B3%E7%AC%A8%E6%8B%99%E8%AE%B0%E5%BF%86/"},{"categories":["学习记录"],"content":"さ行 清音 浊音 さサ 一个人弯着腿跪在 “艹” 上面, 是不是很 “傻 (sa)” za( ざ ザ) しシ 用 “吸管” 喝水,“吸(shi)” 出来“三点水 ji( じ ジ) すス 一个人上吊 “又”\" 苏 (su)\" 醒了 zu( ず ズ) せセ 世界被 “塞 (se)” 得满满的 ze( ぜ ゼ) そソ 一位艺人比起了 V 字 “手 (so)” zo( ぞ ゾ) ","date":"2020-01-05","objectID":"/%E6%97%A5%E8%AF%AD%E4%BA%94%E5%8D%81%E9%9F%B3%E7%AC%A8%E6%8B%99%E8%AE%B0%E5%BF%86/:3:0","tags":["日语"],"title":"日语五十音笨拙记忆","uri":"/%E6%97%A5%E8%AF%AD%E4%BA%94%E5%8D%81%E9%9F%B3%E7%AC%A8%E6%8B%99%E8%AE%B0%E5%BF%86/"},{"categories":["学习记录"],"content":"た行 清音 浊音 たタ “他 (ta)” 在半夜 “十二” 点的 “夕” 阳下 da( だ ダ) ちチ “吃 (chi)“5 千个包子 ji( ぢ ヂ) つツ 好 “粗 (tsu)” 的一根绳子打了三个结 zu( づ ヅ) てテ 路人 “乙” 撞到了 “行” 人老 “太太 (te)” de( で デ) とト “丫” 头 “拖 (to)” 着一个萝 “卜” do( ど ド) ","date":"2020-01-05","objectID":"/%E6%97%A5%E8%AF%AD%E4%BA%94%E5%8D%81%E9%9F%B3%E7%AC%A8%E6%8B%99%E8%AE%B0%E5%BF%86/:4:0","tags":["日语"],"title":"日语五十音笨拙记忆","uri":"/%E6%97%A5%E8%AF%AD%E4%BA%94%E5%8D%81%E9%9F%B3%E7%AC%A8%E6%8B%99%E8%AE%B0%E5%BF%86/"},{"categories":["学习记录"],"content":"な行 清音 なナ 把 “十三” 算成了 “十” 也太木 “讷 (na)” 了 にニ “你 (ni)” 是 “仁” 者 “二” 心 ぬヌ “奴 (nu)” 隶制度 “又” 出现了 ねネ 有了 “权” 利的奶 (n) 奶是 “福” 气 のノ “NO(no)““0\"和\"1” ","date":"2020-01-05","objectID":"/%E6%97%A5%E8%AF%AD%E4%BA%94%E5%8D%81%E9%9F%B3%E7%AC%A8%E6%8B%99%E8%AE%B0%E5%BF%86/:5:0","tags":["日语"],"title":"日语五十音笨拙记忆","uri":"/%E6%97%A5%E8%AF%AD%E4%BA%94%E5%8D%81%E9%9F%B3%E7%AC%A8%E6%8B%99%E8%AE%B0%E5%BF%86/"},{"categories":["学习记录"],"content":"は行 清音 浊音 半浊音 はハ “哈 (ha)” 八巴狗打 “仗” ba( ば バ) pa( ぱ パ) ひヒ “黑 (hi)” 色的 “U” 型 “匕” 首 bi( び ビ) pi( ぴ ピ) ふフ “小”” 夫 (fu)“子玩” 飞刀 \" bu( ぶ ブ) pu( ぷ プ) へヘ 太 “嗨 (he)” 了两个眼睛都笑弯了 be( べ ベ) pe( ぺ ペ) ほホ 对着 “木” 头 “‘吼 (ho)” 了 “一天” bo( ぼ ボ) po( ぽ ポ) ","date":"2020-01-05","objectID":"/%E6%97%A5%E8%AF%AD%E4%BA%94%E5%8D%81%E9%9F%B3%E7%AC%A8%E6%8B%99%E8%AE%B0%E5%BF%86/:6:0","tags":["日语"],"title":"日语五十音笨拙记忆","uri":"/%E6%97%A5%E8%AF%AD%E4%BA%94%E5%8D%81%E9%9F%B3%E7%AC%A8%E6%8B%99%E8%AE%B0%E5%BF%86/"},{"categories":["学习记录"],"content":"ま行 清音 まマ “天” 天玩 “飞刀”” 吗 (ma)” みミ “三” 个 “H”” 眯 (mi)” 着眼 むム “跪在” 木 (mu)“头上上吊” 么 \" めメ 一个 “女” 的被 × 后被 “灭 (me)\" 了 もモ “七” 个 “毛” 子有阴 “谋 (mo)” ","date":"2020-01-05","objectID":"/%E6%97%A5%E8%AF%AD%E4%BA%94%E5%8D%81%E9%9F%B3%E7%AC%A8%E6%8B%99%E8%AE%B0%E5%BF%86/:7:0","tags":["日语"],"title":"日语五十音笨拙记忆","uri":"/%E6%97%A5%E8%AF%AD%E4%BA%94%E5%8D%81%E9%9F%B3%E7%AC%A8%E6%8B%99%E8%AE%B0%E5%BF%86/"},{"categories":["学习记录"],"content":"や行 清音 やヤ 两个 “牙 (ya)”\" 也 \" 坏了 ゆユ “有 (yu)”\" 一串糖葫芦 “用” 长篓子 \" 装起来 よヨ “哟 (yo)” “支” 付宝 “扫” 码 ","date":"2020-01-05","objectID":"/%E6%97%A5%E8%AF%AD%E4%BA%94%E5%8D%81%E9%9F%B3%E7%AC%A8%E6%8B%99%E8%AE%B0%E5%BF%86/:8:0","tags":["日语"],"title":"日语五十音笨拙记忆","uri":"/%E6%97%A5%E8%AF%AD%E4%BA%94%E5%8D%81%E9%9F%B3%E7%AC%A8%E6%8B%99%E8%AE%B0%E5%BF%86/"},{"categories":["学习记录"],"content":"ら行 清音 らラ “今” 天 “5” 个人 “拉 (ra)” 肚子 りリ 两个像 “立 (ri)” 刀旁 “刂” るル “路 (ru)” 上遇到 “儿” 子 “歹” 徒 れレ 有 “机” 会 “来 (re)” 要 “勾” 住 ろロ “3” 万人 “口” 好 “low(ro)” ","date":"2020-01-05","objectID":"/%E6%97%A5%E8%AF%AD%E4%BA%94%E5%8D%81%E9%9F%B3%E7%AC%A8%E6%8B%99%E8%AE%B0%E5%BF%86/:9:0","tags":["日语"],"title":"日语五十音笨拙记忆","uri":"/%E6%97%A5%E8%AF%AD%E4%BA%94%E5%8D%81%E9%9F%B3%E7%AC%A8%E6%8B%99%E8%AE%B0%E5%BF%86/"},{"categories":["学习记录"],"content":"わ行 清音 わワ “水箱的底儿没了”, 水 “哇 (wa)” 的全漏光了 をヲ 龙 “哦 (o)” ","date":"2020-01-05","objectID":"/%E6%97%A5%E8%AF%AD%E4%BA%94%E5%8D%81%E9%9F%B3%E7%AC%A8%E6%8B%99%E8%AE%B0%E5%BF%86/:10:0","tags":["日语"],"title":"日语五十音笨拙记忆","uri":"/%E6%97%A5%E8%AF%AD%E4%BA%94%E5%8D%81%E9%9F%B3%E7%AC%A8%E6%8B%99%E8%AE%B0%E5%BF%86/"},{"categories":["学习记录"],"content":"拨音 清音 んン “摁 (n)’” 两下 ““铃铛” ","date":"2020-01-05","objectID":"/%E6%97%A5%E8%AF%AD%E4%BA%94%E5%8D%81%E9%9F%B3%E7%AC%A8%E6%8B%99%E8%AE%B0%E5%BF%86/:11:0","tags":["日语"],"title":"日语五十音笨拙记忆","uri":"/%E6%97%A5%E8%AF%AD%E4%BA%94%E5%8D%81%E9%9F%B3%E7%AC%A8%E6%8B%99%E8%AE%B0%E5%BF%86/"},{"categories":["终端工具"],"content":"进入 Vim 命令 描述 vim filename 打开或新建文件，并将光标置于第一行首 vim +n filename 打开文件，并将光标置于第 n 行首 vim + flename 打开文件, 并将光标置于最后一 - 行首 vim +/pattern filename 打开文件, 并将光标置于第一一个 与 pattern 匹配的串处 vim -r filename 在上次正用 vim 编辑时发生系统崩溃，恢复 flename vim filename… filename 打开多个文件, 依次编辑 ","date":"2019-08-09","objectID":"/vim%E6%93%8D%E4%BD%9C%E9%80%9F%E6%9F%A5/:1:0","tags":null,"title":"Vim操作速查","uri":"/vim%E6%93%8D%E4%BD%9C%E9%80%9F%E6%9F%A5/"},{"categories":["终端工具"],"content":"Vim 配置 命令 描述 all 列出所有选项设置情况 term 设置终端类型 ignorance 在搜索中忽略大小写 list 显示制表位 (Ctrl+I) 和行尾标志( $) number 显示行号 report 显示由面向行的命令修改过的数目 terse 显示简短的警告信息 warn 在转到别的文件时若没保存当前文件则显示 NO write 信息 nomagic 允许 vi 显示其他用户用 write 写到自己终端上的信息 nowrapscan 禁止 vi 在搜索到达文件两端时，又从另 - - 端开始 mesg 允许 vi 显示其他用户用 write 写到自己终端上的信息 :set number/ set nonumber 显示 / 不显示行号 :set ruler /set noruler 显示不显示标尺 :set hlsearch 高亮显示查找到的单词 :sset nohlsearch 关闭高亮显示 :set nu 显示行号 :set tabstop=8 设置 tab 大小，8 为最常用最普遍的设置 :set softabstop=8 4:4 个空格, 8: 正常的制表符，12: 一一个制表符 4 个空格，16: 两个 :set autoindent 自动缩进 :set cindent C 语言格式里面的自动缩进 ","date":"2019-08-09","objectID":"/vim%E6%93%8D%E4%BD%9C%E9%80%9F%E6%9F%A5/:2:0","tags":null,"title":"Vim操作速查","uri":"/vim%E6%93%8D%E4%BD%9C%E9%80%9F%E6%9F%A5/"},{"categories":["终端工具"],"content":"移动光标 命令 描述 k nk 上向上移动 n 行 j nj 下向下移动 n 行 h nh 左向左移动 n 行 I nl 右向右移动 n 行 Space 光标右移一个字符 Backspace 光标左移一个字符 Enter 光标下移一行 w/W 光标右移一个字至字首 b/B 光标左移一个字至字首 e 或 E 光标右移一个字至字尾 ) 光标移至句尾 ( 光标移至句首 } 光标移至句首 { 光标移至段落结尾 n$ 光标移至第 n 行尾 H 光标移至屏幕顶行 M 光标移至屏幕中间行 L 光标移至屏幕最后行 0 (注意是数字零) 光标移至当前行首 ^ 移动光标到行首第一个非空字符上去 $ 光标移至当前行尾 gg 移到第一行 G 移到最后一行 f 移动光标到当前行的字符 a 上 F 相反 % 移动到与制匹配的括号上去 () ,{},[],\u003c\u003e 等 nG 移动到第 n 行上 G 到最后一行 ","date":"2019-08-09","objectID":"/vim%E6%93%8D%E4%BD%9C%E9%80%9F%E6%9F%A5/:3:0","tags":null,"title":"Vim操作速查","uri":"/vim%E6%93%8D%E4%BD%9C%E9%80%9F%E6%9F%A5/"},{"categories":["终端工具"],"content":"屏幕滚动 命令 描述 Ctrl+u 向文件首翻半屏 Ctrl+d 向文件尾翻半屏 Ctrl+f 向文件尾翻一屏 Ctrl+ b 向文件首翻一屏 nz 将第 n 行滚至屏幕顶部, 不指定 n 时将当前行滚至屏幕顶部 ","date":"2019-08-09","objectID":"/vim%E6%93%8D%E4%BD%9C%E9%80%9F%E6%9F%A5/:4:0","tags":null,"title":"Vim操作速查","uri":"/vim%E6%93%8D%E4%BD%9C%E9%80%9F%E6%9F%A5/"},{"categories":["终端工具"],"content":"插入文本类 命令 描述 i 在光标前 I 在当前行首 a 光标后 A 在当前行尾 o 在当前行之下新开一行 O 在当前行之上新开一行 r 替换当前字符 R 替换当前字符及其后的字符, 直至按 ESC 键 s 从当前光标位置处开始, 以输入的文本替代指定数目的字符 S 删除指定数目的行, 并以所输入文本代替之 ncw/nCW 修改指定数目的字 nCC 修改指定数目的行 ","date":"2019-08-09","objectID":"/vim%E6%93%8D%E4%BD%9C%E9%80%9F%E6%9F%A5/:5:0","tags":null,"title":"Vim操作速查","uri":"/vim%E6%93%8D%E4%BD%9C%E9%80%9F%E6%9F%A5/"},{"categories":["终端工具"],"content":"删除命令 命令 描述 x/X 删除 - 个字符, x 删除光标后的, 而 X 删除光标前的 dw 删除一个单词 (删除光标位置到下一个单词开始的位置) dnw 删除 n 个单词 dne 也可，只是删除到单词尾 do 删至行首 d$ 删至行尾 dd 删除一行 ndd 删除当前行及其后 n-1 行 dnl 向右删除 n 个字母 dnh 向左删除 n 个字母 dnj 向下删除 n 行，当前行 + 其上 n 行 dnk 向上删除 n 行，当期行 + 其下 n 行 cnw[word] 将 n 个 word 改变为 word C$ 改变到行尾 cc 改变整行 shift+j 删除行尾的换行符，下一行接上来了 ","date":"2019-08-09","objectID":"/vim%E6%93%8D%E4%BD%9C%E9%80%9F%E6%9F%A5/:6:0","tags":null,"title":"Vim操作速查","uri":"/vim%E6%93%8D%E4%BD%9C%E9%80%9F%E6%9F%A5/"},{"categories":["终端工具"],"content":"复制粘贴 命令 描述 p 粘贴用 x 或 d 删除的文本 ynw 复制 n 个单词 yy 复制一行 ynl 复制 n 个字符 y$ 复制当前光标至行尾处 Nay 拷贝 n 行 ","date":"2019-08-09","objectID":"/vim%E6%93%8D%E4%BD%9C%E9%80%9F%E6%9F%A5/:7:0","tags":null,"title":"Vim操作速查","uri":"/vim%E6%93%8D%E4%BD%9C%E9%80%9F%E6%9F%A5/"},{"categories":["终端工具"],"content":"撤销 命令 描述 u 撤销前一 - 次的操作 shif+u(U) 撤销对该行的所有操作 ","date":"2019-08-09","objectID":"/vim%E6%93%8D%E4%BD%9C%E9%80%9F%E6%9F%A5/:8:0","tags":null,"title":"Vim操作速查","uri":"/vim%E6%93%8D%E4%BD%9C%E9%80%9F%E6%9F%A5/"},{"categories":["终端工具"],"content":"搜索及替换 命令 描述 /pattern 从光标开始处向文件尾搜索 pattern ?pattern 从光标开始处向文件首搜索 pattern n 在同 - - 方向重复上 - - 次搜索命令 N 在反方向上重复上一 - 次搜索命令 cw newword 替换为 newword n 继续查找 . 执行替换 :s/p1/p2/g 将当前行中所有 p1 均用 p2 替代，g 表示执行用 c 表示需要确认 :n1,n2 s/p1/p2/g 将第 n1 至 n2 行中所有 p1 均用 p2 替代 :g/p1/s//p2/g 将文件中所有 p1 均用 p2 替换 :1,$ s/string1/string2/g 在全 文中将 string1 替换为 string2 ","date":"2019-08-09","objectID":"/vim%E6%93%8D%E4%BD%9C%E9%80%9F%E6%9F%A5/:9:0","tags":null,"title":"Vim操作速查","uri":"/vim%E6%93%8D%E4%BD%9C%E9%80%9F%E6%9F%A5/"},{"categories":["终端工具"],"content":"书签 命令 描述 m[a-z] 在文中做标记, 标记号可为 a-z 的 26 个字母 `a 移动到标记 a 处 ","date":"2019-08-09","objectID":"/vim%E6%93%8D%E4%BD%9C%E9%80%9F%E6%9F%A5/:10:0","tags":null,"title":"Vim操作速查","uri":"/vim%E6%93%8D%E4%BD%9C%E9%80%9F%E6%9F%A5/"},{"categories":["终端工具"],"content":"visual 模式 命令 描述 v 进入 visual 模式 V 进入行的 visual 模式 ctrl+v 进如块操作模式用 o 和 O 改变选择的边的大小 在所有行插入相同的内容如 include\u003c 将光标移到开始插入的位置，按 CTRL+V 进入 VISUAL 模式 , 选择好模块后按 I（shift+i），后插入要插入的文本，按 [ESC] 完成 ","date":"2019-08-09","objectID":"/vim%E6%93%8D%E4%BD%9C%E9%80%9F%E6%9F%A5/:11:0","tags":null,"title":"Vim操作速查","uri":"/vim%E6%93%8D%E4%BD%9C%E9%80%9F%E6%9F%A5/"},{"categories":["终端工具"],"content":"行方式命令 命令 描述 :n1,n2 co n3 将 n1 行到 n2 行之间的内容拷贝到第 n3 行下 :n1,n2 m n3 将 n1 行到 n2 行之间的内容移至到第 n3 行下 :n1,n2 d 将 n1 行到 n2 行之间的内容删除 :n1 ,n2 w!command 将文件中 n1 行至 n2 行的内容作为 command 的输入并执行之 若不指定 n1，n2，则表示将整个文件内容作为 command 的输入 ","date":"2019-08-09","objectID":"/vim%E6%93%8D%E4%BD%9C%E9%80%9F%E6%9F%A5/:12:0","tags":null,"title":"Vim操作速查","uri":"/vim%E6%93%8D%E4%BD%9C%E9%80%9F%E6%9F%A5/"},{"categories":["终端工具"],"content":"宏 命令 描述 q[a-z] 开始记录但前开始的操作为宏 , 名称可为 [a-z] , 然后用 q 终止录制宏 reg 显示当前定义的所有的宏, 用 @[a-z] 来在当前光标处执行宏 [a-z] ","date":"2019-08-09","objectID":"/vim%E6%93%8D%E4%BD%9C%E9%80%9F%E6%9F%A5/:13:0","tags":null,"title":"Vim操作速查","uri":"/vim%E6%93%8D%E4%BD%9C%E9%80%9F%E6%9F%A5/"},{"categories":["终端工具"],"content":"窗口操作 命令 描述 :split 分割一个窗口 :split file.c 为另一个文件 file c 分隔窗口 :nsplit file.c 为另一个文件 file c 分隔窗口, 并指定其行数 ctrl+w 在窗口中切换 :close 关闭当前窗口 ","date":"2019-08-09","objectID":"/vim%E6%93%8D%E4%BD%9C%E9%80%9F%E6%9F%A5/:14:0","tags":null,"title":"Vim操作速查","uri":"/vim%E6%93%8D%E4%BD%9C%E9%80%9F%E6%9F%A5/"},{"categories":["终端工具"],"content":"文件及其他 命令 描述 :q 退出 vi :q! 不保存文件并退出 vi :e filename 打开文件 filename 进行编辑 e! 放弃修改文件内容, 重新载入该文件编辑 :w 保存当前文件 :wq 存盘退出 :ZZ 保存当前文档并退出 Vim :!command 执行 shell 命令 command :rlcommand 将命令 command 的输出结果放到当前行 :n1 ,n2 write temp.c :read file.c 将文件 file.c 的内容插入到当前光标所在的下面 ","date":"2019-08-09","objectID":"/vim%E6%93%8D%E4%BD%9C%E9%80%9F%E6%9F%A5/:15:0","tags":null,"title":"Vim操作速查","uri":"/vim%E6%93%8D%E4%BD%9C%E9%80%9F%E6%9F%A5/"},{"categories":["随笔"],"content":"本文只代表个人见解，不代表任立场，如果您认为我的想法是错的那很正常，因为这是我的想法，如果您觉得您的想法和我一样，那我们就是传说中的 “激友”（对生活冲满激情的朋友）。进入正题。 ","date":"2019-08-09","objectID":"/%E4%BD%9C%E4%B8%BA%E6%8A%80%E6%9C%AF%E4%BA%BA%E5%91%98%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%86%99%E5%8D%9A%E5%AE%A2/:0:0","tags":[""],"title":"作为技术人员为什么要写博客","uri":"/%E4%BD%9C%E4%B8%BA%E6%8A%80%E6%9C%AF%E4%BA%BA%E5%91%98%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%86%99%E5%8D%9A%E5%AE%A2/"},{"categories":["随笔"],"content":"一、我心中的博客 我所以指的写博客，不单只是写一篇文章出来这一结果。而应该是写的这一过程，写过技术文章的朋友应该跟我一样有这么一个过程。 自己了解学习，文章所涉及到的知识点，及知识点衍生出来的知识点。 对学习的知识点进行验证，以确保理论值与实践值保持一致。 构思文章的大纲，哪些部分需要重点写，需要配合实例代码，图片等信息。 动手写，写完后再次检查校正并排版，然后发表。 针对网友的评论中提出的问题进行回复 我写文章一般都会经历以上 5 上步，最终以上 5 步融合成一个结果那就是 “一篇文章” 这一过程也是我心中对的 “写博客” 一词的诠释 ","date":"2019-08-09","objectID":"/%E4%BD%9C%E4%B8%BA%E6%8A%80%E6%9C%AF%E4%BA%BA%E5%91%98%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%86%99%E5%8D%9A%E5%AE%A2/:1:0","tags":[""],"title":"作为技术人员为什么要写博客","uri":"/%E4%BD%9C%E4%B8%BA%E6%8A%80%E6%9C%AF%E4%BA%BA%E5%91%98%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%86%99%E5%8D%9A%E5%AE%A2/"},{"categories":["随笔"],"content":"二、为什么要写博客 ","date":"2019-08-09","objectID":"/%E4%BD%9C%E4%B8%BA%E6%8A%80%E6%9C%AF%E4%BA%BA%E5%91%98%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%86%99%E5%8D%9A%E5%AE%A2/:2:0","tags":[""],"title":"作为技术人员为什么要写博客","uri":"/%E4%BD%9C%E4%B8%BA%E6%8A%80%E6%9C%AF%E4%BA%BA%E5%91%98%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%86%99%E5%8D%9A%E5%AE%A2/"},{"categories":["随笔"],"content":"为自己 写博客对自己的提升是很大的，可能写一篇体现不出来，但是只要你坚持写效果就很明显，好处人个认为有以下几点 强化知识点 在写一篇文章前，你必定是要把以文章中心为主的知识点及衍生的知识点都详细了解一篇，在这一过程中必须会涉及到自己以前所了解过的知识。 人的记忆是存在记忆曲线的需要不断的重复记忆才能长久的记住某一事物，而每写一篇文章时都会查阅资料，在这一过程中必然会遇到以前记住了而现在渐渐淡忘的知识点。 当你再次看到时瞬间就会回想起，此时以前的知识点就得到了强化。 提升学习能力 同一样的人，了解同一知识点，用不同的方法，产生的结果必然会不一样。 找到最佳的学习方法，这也是一种能力，这种能力是经过多次实践探索之后总结出来的。 以前我每次需了解某一种技术时都会先百度看各种搜索结果，发现没有想要的之后，再 Google 因为 Google 的结果与百度的会有所不同，Google 结果中国外的文章相对会多一点。 而偶然点了一个链接进入了博客园，发现就是自己想要的东西，而且把概念，代码，及经验都写上去了，看完之后对我帮助很大。 渐渐的我便开始采这种方法了解新知识概念性的直接看百度百科，实质性的直接 上博客园的 找找看 。 群里的朋友还推荐了一种方法，比如我要学 MVC 园子里很多人都写了 关于 MVC 的一系列文章，把那一系列的文章都看一遍，对于 MVC 就基本有了了解了，这便是学习能力的提升, 对于某种技术用最短的时间做到了比较全面的了解。 提升文字组织能力 这个就不用说了，写博客，既然是写，就必然会有大量的文字，而如何组织文字表达出自己想表达的意思，是长期练习的，而写博客正好帮助你提高了你的文字组织能力。 提升逻辑思维能力 不用说，技术性的东西从来就没的单独存在的，都一层层技术相结合，那在了解某种技术时，自己的思维也是要顺着这种关系逐渐深入的。 比如 MVC，你不能只知道 M 是什么 V 是什么 C 是什么就行了吧，你得知道 M V C 这三者关系是怎样的，又是怎样交互，而你了解之后再把它写出来时，需要清晰逻辑。 ","date":"2019-08-09","objectID":"/%E4%BD%9C%E4%B8%BA%E6%8A%80%E6%9C%AF%E4%BA%BA%E5%91%98%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%86%99%E5%8D%9A%E5%AE%A2/:2:1","tags":[""],"title":"作为技术人员为什么要写博客","uri":"/%E4%BD%9C%E4%B8%BA%E6%8A%80%E6%9C%AF%E4%BA%BA%E5%91%98%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%86%99%E5%8D%9A%E5%AE%A2/"},{"categories":["随笔"],"content":"为他人 有意的 园子里有很多人都写过关于 MVC 框架 WCF 等等系列文章，目的就在于帮助新人快速上手，这个我深有体会，当初我开始学习 MVC 时就是看的 T2 噬菌体的 MVC 系列文章，整篇看完后再配合自己动手对于 MVC 就有了基本的了解了，在次感谢园子里无私献的大牛们。而以上行为就是有意的帮助。 无意的 很多时候在开发项目的过程中，遇到了技术问题，花了时间解决后，有人会写博客记录，并附上解决方法旨在当再次遇到问题时直接看下文章就知道如何处理了。 而碰巧的是，这种问题不止他一个人遇到了，很多人在开发时也遇到了这个问题。 在网上找答案时，就找到了这篇文章，并根据文章提供的解决方法，顺利的解决了问题，这种帮助就是无意的帮助。 ","date":"2019-08-09","objectID":"/%E4%BD%9C%E4%B8%BA%E6%8A%80%E6%9C%AF%E4%BA%BA%E5%91%98%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%86%99%E5%8D%9A%E5%AE%A2/:2:2","tags":[""],"title":"作为技术人员为什么要写博客","uri":"/%E4%BD%9C%E4%B8%BA%E6%8A%80%E6%9C%AF%E4%BA%BA%E5%91%98%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%86%99%E5%8D%9A%E5%AE%A2/"},{"categories":["随笔"],"content":"三、一定要写博客吗 答案肯定是否定的，中国几百万的程序员，如果都写博客，那程序员的春天就来了，但是事实并非如此。 而我所讲的 写博客 的产物并不只是一篇文章，更多的是，对自己能力的提升，自己对知识点的总结。 而发表在博客上只是为了公开，还有很多人喜欢记录在云笔记里面。还有工作很忙，没有空闲时间写出来，因为写技术性的文章，花的时间是很长的。写过的朋友都知道。 ","date":"2019-08-09","objectID":"/%E4%BD%9C%E4%B8%BA%E6%8A%80%E6%9C%AF%E4%BA%BA%E5%91%98%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%86%99%E5%8D%9A%E5%AE%A2/:3:0","tags":[""],"title":"作为技术人员为什么要写博客","uri":"/%E4%BD%9C%E4%B8%BA%E6%8A%80%E6%9C%AF%E4%BA%BA%E5%91%98%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%86%99%E5%8D%9A%E5%AE%A2/"},{"categories":["随笔"],"content":"四、博客会给你带来哪些收获 古人云：一份耕耘，一份收获 以下这些是帮助他人而得到的一些认可，并非主观上去追求的 MVP：微软每年都颁发 MVP 给那些经常与其他专业人士分享知识和专业技能，受人尊敬、信任，而且平易近人的专家。而这个称号则是对你写的博客质量的肯定。 知名度: 文章写得好的人，技术水平肯定也很好，知道的人多了，知名度就有了，比如园子里排名前 10 的大家都知道，都看过他们的文章。 尊敬：对于技术界的大神，都是受人敬仰的，在园子里或者工作中也是一样的，在心里对大神们都是默默的佩服！至少我是这样啦，哈哈~ 也是我学习的榜样！ ","date":"2019-08-09","objectID":"/%E4%BD%9C%E4%B8%BA%E6%8A%80%E6%9C%AF%E4%BA%BA%E5%91%98%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%86%99%E5%8D%9A%E5%AE%A2/:4:0","tags":[""],"title":"作为技术人员为什么要写博客","uri":"/%E4%BD%9C%E4%B8%BA%E6%8A%80%E6%9C%AF%E4%BA%BA%E5%91%98%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%86%99%E5%8D%9A%E5%AE%A2/"},{"categories":["随笔"],"content":"五、总结 我所认的写博客是对自己所了解知识的强化，分享，自身能力的提升。当然 写 博客只是一种方法而已，只要能达到提升自我的效果什么方法都是可以的。 之前有看过一则新闻：即便没有读者，你也要写博客 ，文章也讲解了很多写博客的好处。 而我写博客是希望，能提升自己的综合能力，并把自己的知识与经验分享给大家，如果有幸我的分享帮助了一些人，那将使我更加欣慰。 最后附上一句名言：有些事情你现在不去做，可能以后都不会有机会了！ 转载自：https://mp.weixin.qq.com/s/gBx0SapuMyOY9Gu6gCoaag 原作者：Zery ","date":"2019-08-09","objectID":"/%E4%BD%9C%E4%B8%BA%E6%8A%80%E6%9C%AF%E4%BA%BA%E5%91%98%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%86%99%E5%8D%9A%E5%AE%A2/:5:0","tags":[""],"title":"作为技术人员为什么要写博客","uri":"/%E4%BD%9C%E4%B8%BA%E6%8A%80%E6%9C%AF%E4%BA%BA%E5%91%98%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%86%99%E5%8D%9A%E5%AE%A2/"},{"categories":["终端工具"],"content":"Tmux 简介 Tmux 的全称是 Terminal MUtipleXer，及终端复用软件。顾名思义，它的主要功能就是用于在一个终端窗口中运行多个终端会话并且在你关闭终端窗口之后保持进程的运行。 Tmux 安装 # Ubuntu 或 Debian $ sudo apt-get install tmux # CentOS 或 Fedora $ sudo yum install tmux # Mac $ brew install tmux Tmux 概念 Tmux 中有几个重要概念： 会话（session）: 建立一个 tmux 工作区会话，会话可以长期驻留，重新连接服务器不会丢失，我们只需重新 tmux attach 到之前的工作区就可以恢复会话 窗口（window）: 容纳多个窗格 窗格（pane）: 可以在窗口中分成多个窗格 Tmux 概念图\" Tmux 概念图 Tmux 基本操作 ","date":"2019-08-04","objectID":"/tmux%E7%9A%84quickstart/:0:0","tags":[""],"title":"Tmux的QuickStart","uri":"/tmux%E7%9A%84quickstart/"},{"categories":["终端工具"],"content":"常用命令 tmux new　创建默认名称的会话 tmux new -s mysession　创建名为 mysession 的会话 tmux ls　显示会话列表 tmux a　连接上一个会话 tmux a -t mysession　连接指定会话 tmux rename -t s1 s2　重命名会话 s1 为 s2 tmux kill-session　关闭上次打开的会话 tmux kill-session -t s1　关闭会话 s1 tmux kill-session -a -t s1　关闭除 s1 外的所有会话 tmux kill-server　关闭所有会话 Tmux 默认的快捷键前缀是 ctrl+b，当然你也可以修改它（后文会提到） 以下所有的操作都是激活控制台之后，即键入 Ctrl+b 前提下才可以使用的命令 ","date":"2019-08-04","objectID":"/tmux%E7%9A%84quickstart/:1:0","tags":[""],"title":"Tmux的QuickStart","uri":"/tmux%E7%9A%84quickstart/"},{"categories":["终端工具"],"content":"会话操作（session） ?　列出所有快捷键；按 q 返回 d　脱离当前会话, 可暂时返回 Shell 界面，输入 tmux attach 能够重新进入之前会话 s　选择并切换会话；在同时开启了多个会话时使用 D　选择要脱离的会话；在同时开启了多个会话时使用 :　进入命令行模式；此时可输入支持的命令，例如 kill-server 所有 tmux 会话 [　复制模式，光标移动到复制内容位置，空格键开始，方向键选择复制，回车确认，q/Esc 退出 ]　进入粘贴模式，粘贴之前复制的内容，按 q/Esc 退出 ~　列出提示信息缓存；其中包含了之前 tmux 返回的各种提示信息 t　显示当前的时间 Ctrl+z　挂起当前会话 ","date":"2019-08-04","objectID":"/tmux%E7%9A%84quickstart/:2:0","tags":[""],"title":"Tmux的QuickStart","uri":"/tmux%E7%9A%84quickstart/"},{"categories":["终端工具"],"content":"窗口操作（window） c　创建新窗口 \u0026　关闭当前窗口 数字键　切换到指定窗口 p　切换至上一窗口 n　切换至下一窗口 l　前后窗口间互相切换 w　通过窗口列表切换窗口 ,　重命名当前窗口，便于识别 .　修改当前窗口编号，相当于重新排序 f　在所有窗口中查找关键词，便于窗口多了切换 ","date":"2019-08-04","objectID":"/tmux%E7%9A%84quickstart/:3:0","tags":[""],"title":"Tmux的QuickStart","uri":"/tmux%E7%9A%84quickstart/"},{"categories":["终端工具"],"content":"面板操作（pane） “　将当前面板上下分屏 %　将当前面板左右分屏 x　关闭当前分屏 !　将当前面板置于新窗口, 即新建一个窗口, 其中仅包含当前面板 Ctrl + 方向键　以 1 个单元格为单位移动边缘以调整当前面板大小 Alt + 方向键　以 5 个单元格为单位移动边缘以调整当前面板大小 空格键　可以在默认面板布局中切换，试试就知道了 q　显示面板编号 o　选择当前窗口中下一个面板 方向键　移动光标选择对应面板 {　向前置换当前面板 }　向后置换当前面板 Alt+o　逆时针旋转当前窗口的面板 Ctrl+o　顺时针旋转当前窗口的面板 z　tmux 1.8 新特性，最大化当前所在面板 Tmux 便捷配置 ","date":"2019-08-04","objectID":"/tmux%E7%9A%84quickstart/:4:0","tags":[""],"title":"Tmux的QuickStart","uri":"/tmux%E7%9A%84quickstart/"},{"categories":["终端工具"],"content":"配置文件 #新建 Tmux 配置文件 vi $HOME/.tmux.conf ** 修改 Tmux 快捷键前缀为 ctrl+s，便于操作 ** #设置前缀 set -g prefix ^s #解除 Ctrl+b 与前缀的对应关系 unbind ^b # split window unbind '\"' # vertical split (prefix -) bind - splitw -v unbind % bind | splitw -h # horizontal split (prefix |) #将 r 设置为加载配置文件，并显示 \"reloaded!\" 信息 bind r source-file ~/.tmux.conf \\; display \"Reloaded!\" #up bind k select-pane -U #down bind j select-pane -D #left bind h select-pane -L #right bind l select-pane -R #kill pane bind q killp setw -g mode-keys vi ","date":"2019-08-04","objectID":"/tmux%E7%9A%84quickstart/:5:0","tags":[""],"title":"Tmux的QuickStart","uri":"/tmux%E7%9A%84quickstart/"},{"categories":["终端工具"],"content":"设置 alias 快捷键 alias ta='tmux a -t' alias tf='tail -f' alias tls='tmux ls' alias tnew='tmux new -s' Oh my tmux 🇫🇷 Oh my tmux! My self-contained, pretty \u0026 versatile tmux configuration made with ❤️ https://github.com/gpakosz/.tmux 更好看、强悍的 tmux 配置，有时间可以研究 使用 Tips ","date":"2019-08-04","objectID":"/tmux%E7%9A%84quickstart/:6:0","tags":[""],"title":"Tmux的QuickStart","uri":"/tmux%E7%9A%84quickstart/"},{"categories":["终端工具"],"content":"跳转 Tmux 窗口号为两位数的窗口 通常使用 Prefix + 数字键 可以跳转到指定窗口，但是窗口号如果是 10，当你按下 1 的时候就已经跳转到 1 号窗口了，可以先使用 Prefix + '，然后输入 index ","date":"2019-08-04","objectID":"/tmux%E7%9A%84quickstart/:7:0","tags":[""],"title":"Tmux的QuickStart","uri":"/tmux%E7%9A%84quickstart/"},{"categories":["学习记录"],"content":"时间复杂度 算法的执行时间与算法输入值之间的的关系，即算法的执行效率 ","date":"2019-07-24","objectID":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%B6%E9%97%B4%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/:1:0","tags":["数据结构"],"title":"数据结构与算法之时间、空间复杂度","uri":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%B6%E9%97%B4%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"},{"categories":["学习记录"],"content":"大 O 表示法 用常数 1 取代运行时间中的所有加法常数。 在修改后的运行次数函数中，只保留最高阶项。 如果最高阶项存在且不是 1，则去除与这个项相乘的常数。得到的结果就是大 O 阶 ","date":"2019-07-24","objectID":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%B6%E9%97%B4%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/:1:1","tags":["数据结构"],"title":"数据结构与算法之时间、空间复杂度","uri":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%B6%E9%97%B4%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"},{"categories":["学习记录"],"content":"常见时间复杂度 O(1) 常数阶 def O1(num): i = num j = num*2 return i + j O(logn) 对数阶 def OlogN(num): i = 1 while (i \u003c num): i = i * 2 return i O(n) 线性阶 def ON(num): total = 0 for i in range(num): total += i return total O(nlogn) nlogn 阶 def ONlogN(num): total = 0 for i in range(num): j = 1 while (j \u003c num): total += i+j j = j * 2 return total O(n^2) 平方阶 def ON2(num): total = 0 for i in range(num): for j in range(num): total += i+j return total ","date":"2019-07-24","objectID":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%B6%E9%97%B4%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/:1:2","tags":["数据结构"],"title":"数据结构与算法之时间、空间复杂度","uri":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%B6%E9%97%B4%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"},{"categories":["学习记录"],"content":"对比 Bid-O 对比\" Bid-O 对比 常用时间复杂度所耗费的时间从小到大依次是： O(1) \u003c O(logn) \u003c O(n) \u003c O(nlogn) \u003c O(n^2) \u003c O(n^3) \u003c O(n!) \u003c O(n^n) 相关文档：Big-O Cheat Sheet ","date":"2019-07-24","objectID":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%B6%E9%97%B4%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/:1:3","tags":["数据结构"],"title":"数据结构与算法之时间、空间复杂度","uri":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%B6%E9%97%B4%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"},{"categories":["学习记录"],"content":"空间复杂度 算法的存储空间与输入值之间的关系，表示方法同样也为大 O 表示法 ","date":"2019-07-24","objectID":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%B6%E9%97%B4%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/:2:0","tags":["数据结构"],"title":"数据结构与算法之时间、空间复杂度","uri":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%B6%E9%97%B4%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"},{"categories":["学习记录"],"content":"常见时间复杂度 O(1) 常数阶 def O1(num): total = 0 for i in range(num): total += i return total O(n) 线性阶 def ON(nums) array = [] for num in nums: array.append(num) return array ","date":"2019-07-24","objectID":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%B6%E9%97%B4%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/:2:1","tags":["数据结构"],"title":"数据结构与算法之时间、空间复杂度","uri":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%B6%E9%97%B4%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"},{"categories":["学习记录"],"content":"如何计算 变量：常量时为 O(1），数组、列表则可能是 O(n)、O(n^2) 递归：递归栈 O(n) ","date":"2019-07-24","objectID":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%B6%E9%97%B4%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/:2:2","tags":["数据结构"],"title":"数据结构与算法之时间、空间复杂度","uri":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%B6%E9%97%B4%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"},{"categories":["学习记录"],"content":"最坏情况与平均情况 最坏情况运行时间是一种保证，那就是运行时间不会再长了。在应用中，这是一种最重要的需求，通常，除非特别指定，我们提到的运行时间都是最坏情况的运行时间。平均运行时间是所有情况中最有意义的，因为它是期望的运行时间。一般没有特殊说明的情况下，时间复杂度都是指最坏时间复杂度。 ","date":"2019-07-24","objectID":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%B6%E9%97%B4%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/:2:3","tags":["数据结构"],"title":"数据结构与算法之时间、空间复杂度","uri":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%B6%E9%97%B4%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"},{"categories":["学习记录"],"content":"如何衡量时间 / 空间复杂度 时间和空间复杂度只能二选一 牺牲时间换空间 牺牲空间换时间 通常是优先选择时间复杂度更好的 ","date":"2019-07-24","objectID":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%B6%E9%97%B4%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/:3:0","tags":["数据结构"],"title":"数据结构与算法之时间、空间复杂度","uri":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%B6%E9%97%B4%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"},{"categories":null,"content":"Tip 今年大约二十六了，居住在武汉 现就职于一家武汉PaaS服务公司，担任服务端开发工程师，主要面向B端 关于我，有以下几点： 不使用推送算法严重的 App，如抖音 反感一件事重复多次 对于迷信无感，崇尚科学 别戳电脑屏幕 ","date":"0001-01-01","objectID":"/about/:0:0","tags":null,"title":"About","uri":"/about/"}]