<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>SOCKS 协议开发记录 | 阿拉丁的博客</title><meta name=keywords content="socks,"><meta name=description content="SOCKS 是一种网络传输协议，主要用于客户端与外网服务器之间通讯的中间传递。SOCKS 是 &ldquo;Socket Secure&rdquo; 的缩写。当防火墙后的客户端要访问外部的服务器时，就跟 SOCKS 代理服务器连接。这个代理服务器控制客户端访问外网的资格，允许的话，就将客户端的请求发往外部的服务器。这个协议最初由 David Koblas 开发，而后由 NEC 的 Ying-Da Lee 将其"><meta name=author content><link rel=canonical href=https://aladdinding.cn/2020/07/SOCKS%E5%8D%8F%E8%AE%AE%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/><meta name=google-site-verification content="G-QY1H3LE9QK"><link crossorigin=anonymous href=/assets/css/stylesheet.min.fcb2dfef1f861f508726aa63fad2809727c9d99081a63847ab71ee83ce0d1203.css integrity="sha256-/LLf7x+GH1CHJqpj+tKAlyfJ2ZCBpjhHq3Hug84NEgM=" rel="preload stylesheet" as=style><link rel=icon href=https://img.aladdinding.cn/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://aladdinding.cn/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://aladdinding.cn/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://aladdinding.cn/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://aladdinding.cn/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.85.0"><script async src="https://www.googletagmanager.com/gtag/js?id=G-QY1H3LE9QK"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag('js',new Date),gtag('config','G-QY1H3LE9QK')</script><meta property="og:title" content="SOCKS 协议开发记录"><meta property="og:description" content="SOCKS 是一种网络传输协议，主要用于客户端与外网服务器之间通讯的中间传递。SOCKS 是 &ldquo;Socket Secure&rdquo; 的缩写。当防火墙后的客户端要访问外部的服务器时，就跟 SOCKS 代理服务器连接。这个代理服务器控制客户端访问外网的资格，允许的话，就将客户端的请求发往外部的服务器。这个协议最初由 David Koblas 开发，而后由 NEC 的 Ying-Da Lee 将其"><meta property="og:type" content="article"><meta property="og:url" content="https://aladdinding.cn/2020/07/SOCKS%E5%8D%8F%E8%AE%AE%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-07-19T00:00:00+00:00"><meta property="article:modified_time" content="2020-07-19T00:00:00+00:00"><meta property="og:site_name" content="Aladdin"><meta name=twitter:card content="summary"><meta name=twitter:title content="SOCKS 协议开发记录"><meta name=twitter:description content="SOCKS 是一种网络传输协议，主要用于客户端与外网服务器之间通讯的中间传递。SOCKS 是 &ldquo;Socket Secure&rdquo; 的缩写。当防火墙后的客户端要访问外部的服务器时，就跟 SOCKS 代理服务器连接。这个代理服务器控制客户端访问外网的资格，允许的话，就将客户端的请求发往外部的服务器。这个协议最初由 David Koblas 开发，而后由 NEC 的 Ying-Da Lee 将其"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://aladdinding.cn/posts/"},{"@type":"ListItem","position":2,"name":"SOCKS 协议开发记录","item":"https://aladdinding.cn/2020/07/SOCKS%E5%8D%8F%E8%AE%AE%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"SOCKS 协议开发记录","name":"SOCKS 协议开发记录","description":"SOCKS 是一种网络传输协议，主要用于客户端与外网服务器之间通讯的中间传递。SOCKS 是 \u0026ldquo;Socket Secure\u0026rdquo; 的缩写。当防火墙后的客户端要访问外部的服务器时，就跟 SOCKS 代理服务器连接。这个代理服务器控制客户端访问外网的资格，允许的话，就将客户端的请求发往外部的服务器。这个协议最初由 David Koblas 开发，而后由 NEC 的 Ying-Da Lee 将其","keywords":["socks",""],"articleBody":" SOCKS 是一种网络传输协议，主要用于客户端与外网服务器之间通讯的中间传递。SOCKS 是 “Socket Secure” 的缩写。当防火墙后的客户端要访问外部的服务器时，就跟 SOCKS 代理服务器连接。这个代理服务器控制客户端访问外网的资格，允许的话，就将客户端的请求发往外部的服务器。这个协议最初由 David Koblas 开发，而后由 NEC 的 Ying-Da Lee 将其扩展到 SOCKS4。最新协议是 SOCKS5，与前一版本相比，增加支持 [UDP](https://zh.wikipedia.org/wiki / 用户数据报协议)、验证，以及IPv6。根据[OSI 模型](https://zh.wikipedia.org/wiki/OSI 模型)，SOCKS 是[会话层](https://zh.wikipedia.org/wiki / 会话层) 的协议，位于 [表示层](https://zh.wikipedia.org/wiki / 表示层) 与[传输层](https://zh.wikipedia.org/wiki / 传输层)之间。SOCKS 协议不提供[加密](https://zh.wikipedia.org/wiki / 加密)。\n SOCKS5 SOCKS 协议版本认证 创建与 SOCKS5 服务器的 TCP 连接后客户端需要先发送请求来确认协议版本及认证方式（以字节为单位）\nclient send # +----+----------+----------+ # |VER | NMETHODS | METHODS | # +----+----------+----------+ # | 1 | 1 | 1 to 255 | # +----+----------+----------+  VER：SOCKS5 协议版本 0x05 NMETHODS：METHODS 所占字节长度 METHODS：客户端支持的认证方式列表，每个方法占 1 字节  0x00 不需要认证 0x01 GSSAPI 0x02 用户名、密码认证 0x03 to 0x7F 由 IANA 分配（保留） 0x80 to 0xFE 私人方法保留 0xFF 无可接受的方法    服务器从客户端提供的 METHODS 中选择一个并通过以下消息通知客户端\nserver reply # +----+--------+ # |VER | METHOD | # +----+--------+ # | 1 | 1 | # +----+--------+   VER：协议版本 0x05\n  METHOD：服务端选中的方法。如果返回 0xFF 表示没有一个认证方法被选中，客户端需要关闭连接。\n  SOCKS 用户名密码认证 如果 SOCKS 协议版本认证中服务端返回的 METHOD 是 0x02，即需要用户名密码认证，则客户端会发送用户名密码认证信息。如果返回的 METHOD 是 0x00，即不需要认证，直接跳转下一步发送 SOCKS 请求信息。\nclient send # +----+------+----------+------+----------+ # |VER | ULEN | UNAME | PLEN | PASSWD | # +----+------+----------+------+----------+ # | 1 | 1 | 1 to 255 | 1 | 1 to 255 | # +----+------+----------+------+----------+  VER：认证协议版本 0x01 ULEN：用户名长度 UNAME： 用户名 PLEN：密码长度 PASSWD：密码  server reply # +----+--------+ # |VER | STATUS | # +----+--------+ # | 1 | 1 | # +----+--------+  VER：认证协议版本 0x01 STATUS：认证状态  0x00 成功 0x01 失败    发送 SOCKS 请求信息 认证结束后客户端就可以发送请求信息。如果认证方法有特殊封装要求，请求必须按照方法所定义的方式进行封装。\nclient send # +----+-----+-------+------+----------+----------+ # |VER | CMD | RSV | ATYP | DST.ADDR | DST.PORT | # +----+-----+-------+------+----------+----------+ # | 1 | 1 | X'00' | 1 | Variable | 2 | # +----+-----+-------+------+----------+----------+  VER：SOCKS5 协议版本 0x05 CMD：SOCK 命令码  0x01 CONNECT 请求 0x02 BIND 请求 0x03 UDP 转发   RSV：0x00 保留 ATYP：DST.ADDR 类型  0x01 IPv4 地址，DST.ADDR 部分 4 字节长度 0x03 域名，DST.ADDR 部分第一个字节为域名长度，DST.ADDR 剩余的内容为域名，没有 \\ 0 结尾。 0x04 IPv6 地址，16 个字节长度。   DST.ADDR：目的地址 DST.PORT：网络字节序表示的目的端口  server reply # +----+-----+-------+------+----------+----------+ # |VER | REP | RSV | ATYP | BND.ADDR | BND.PORT | # +----+-----+-------+------+----------+----------+ # | 1 | 1 | X'00' | 1 | Variable | 2 | # +----+-----+-------+------+----------+----------+  VER：SOCKS5 协议版本 0x05 REP：应答字段  0x00 成功 0x01 常规 SOCKS 服务器连接失败 0x02 现有规则不允许连接 0x03 网络不可达 0x04 主机不可达 0x05 连接被拒 0x06 TTL 超时 0x07 不支持的命令 0x08 不支持的地址类型 0x09 to 0xFF 未定义   RSV：0x00 保留 ATYP：BND.ADDR 类型  0x01 IPv4 地址，DST.ADDR 部分 4 字节长度 0x03 域名，DST.ADDR 部分第一个字节为域名长度，DST.ADDR 剩余的内容为域名，没有 \\ 0 结尾。 0x04 IPv6 地址，16 个字节长度。   BND.ADDR：服务器绑定的地址 BND.PORT：网络字节序表示的服务器绑定的端口  当服务端返回 REP 应答字段为 0x00，即成功时，客户端和服务端之间进行数据透传，完成 SOCKS5 代理。\nSOCKS4 SOCKS 4 只支持 TCP 转发\n发送 SOCKS 请求信息 client send # +----+------+----------+--------+----------+----------+ # |VN | CD | DSTPORT | DSTIP | USERID | NULL | # +----+------+----------+--------+----------+----------+ # | 1 | 1 | 2 | 4 | variable | 1 | # +----+------+----------+--------+----------+----------+  VN：SOCKS4 协议版本 0x04 CD：SOCK 命令码  0x01 CONNECT 请求 0x02 BIND 请求   DSTPORT：目的主机的端口 DSTIP：目的主机的 IP 地址 USERID：用户 USERID NULL：0x00  server reply # +-------+-------+----------+-----------+ # | VN | CD | DSTPORT | DSTIP | # +-------+-------+----------+-----------+ # | 1 | 1 | 2 | 4 | # +-------+-------+----------+-----------+  VN：回复代码的版本，应为 0x00(注意不是 0x04) CD：SOCK 命令码  90(0x5a) 请求得到允许； 91(0x5b) 请求被拒绝或失败； 92(0x5c) 由于 SOCKS 服务器无法连接到客户端的 identd（一个验证身份的进程），请求被拒绝； 93(0x5d) 由于客户端程序与 identd 报告的用户身份不同，连接被拒绝。   DSTPORT：目的主机的端口（和请求包中相同） DSTIP：目的主机的 IP 地址（和请求包中相同）  当服务端返回 CD 字段为 90(0x5a)，即允许时，客户端和服务端之间进行数据透传，完成 SOCKS4 代理。\nSOCKS4a SOCKS4a 协议是 SOCKS4 的一个补丁版，可以在 SOCKS4a 代理服务器上完成 DNS 解析\n发送 SOCKS 请求信息 client send # +----+------+----------+--------+----------+----------+------------+----------+ # |VN | CD | DSTPORT | DSTIP | USERID | NULL | HOSTNAME | NULL | # +----+------+----------+--------+----------+----------+------------+----------+ # | 1 | 1 | 2 | 4 | variable | 1 | variable | 1 | # +----+------+----------+--------+----------+----------+------------+----------+  DSTIP：0.0.0.x，其中 x 是非零，一般都为 1。（原文：such an address is inadmissible as a destination IP address and thus should never occur if the client can resolve the domain name） HOSTNAME：域名  其余字段和 SOCKS4 相同\nserver reply SOCKS4a 代理首先把 HOSTNAME 如：www.example.com 解析成对应的主机 IP 地址，并且和 IP 地址连接上，再向客户端发送和 SOCKS4 一样的响应。当服务端返回 CD 字段为 90(0x5a)，即允许时，客户端和服务端之间进行数据透传，完成 SOCKS4a 代理。\nSOCKS4，SOCKS4a 和 SOCKS5 的区别 比如浏览器使用 SOCKS4 代理访问 www.baidu.com，浏览器先用本地的 DNS 解析把 www.baidu.com 转换成对应的 IP 地址，然后向 SOCKS4 服务器发送报文。如果此时我们的电脑受限本地完成不了 DNS 解析，那怎么办呢？SOCKS4a 就是解决这样的问题的，客户端可以把域名发送到 SOCKS4a 服务器上完成 DNS 解析，发送的 DSTIP 则为 0.0.0.1 这样的假 IP，然后就是和 SOCKS4 一样进行数据转发。SOCKS5 代理和 SOCKS4 SOCKS4a 比，多了一个验证功能和 udp 代理的功能。\nSOCKS 协议 RFC  SOCKS4.protocol.txt and SOCKS4A.protocol.txt for SOCKS 4 and the SOCKS 4A extension, respectively. SOCKS5_rfc1928.txt and SOCKS5_rfc1929.txt for SOCKS 5, and SOCKS 5 Username/Password authentication.  ","wordCount":"2395","inLanguage":"zh","datePublished":"2020-07-19T00:00:00Z","dateModified":"2020-07-19T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://aladdinding.cn/2020/07/SOCKS%E5%8D%8F%E8%AE%AE%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/"},"publisher":{"@type":"Organization","name":"阿拉丁的博客","logo":{"@type":"ImageObject","url":"https://img.aladdinding.cn/favicon.ico"}}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove('dark')</script><noscript><style type=text/css>#theme-toggle,.top-link{display:none}</style></noscript><header class=header><nav class=nav><div class=logo><a href=https://aladdinding.cn/ accesskey=h title="阿拉丁的博客 (Alt + H)">阿拉丁的博客</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://aladdinding.cn/archives/ title=时间轴><span>时间轴</span></a></li><li><a href=https://aladdinding.cn/categories/ title=分类><span>分类</span></a></li><li><a href=https://aladdinding.cn/tags/ title=标签><span>标签</span></a></li><li><a href=https://aladdinding.cn/search/ title="搜索 (Alt + /)" accesskey=/><span>搜索</span></a></li><li><a href=https://aladdinding.cn/about/ title=关于><span>关于</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://aladdinding.cn/>主页</a>&nbsp;»&nbsp;<a href=https://aladdinding.cn/posts/>Posts</a></div><h1 class=post-title>SOCKS 协议开发记录</h1><div class=post-meta>July 19, 2020&nbsp;·&nbsp;5 分钟</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><div class=details>目录</div></summary><div class=inner><ul><li><a href=#socks5 aria-label=SOCKS5>SOCKS5</a><ul><li><a href=#socks-%e5%8d%8f%e8%ae%ae%e7%89%88%e6%9c%ac%e8%ae%a4%e8%af%81 aria-label="SOCKS 协议版本认证">SOCKS 协议版本认证</a><ul><li><a href=#client-send aria-label="client send">client send</a></li><li><a href=#server-reply aria-label="server reply">server reply</a></li></ul></li><li><a href=#socks-%e7%94%a8%e6%88%b7%e5%90%8d%e5%af%86%e7%a0%81%e8%ae%a4%e8%af%81 aria-label="SOCKS 用户名密码认证">SOCKS 用户名密码认证</a><ul><li><a href=#client-send-1 aria-label="client send">client send</a></li><li><a href=#server-reply-1 aria-label="server reply">server reply</a></li></ul></li><li><a href=#%e5%8f%91%e9%80%81-socks-%e8%af%b7%e6%b1%82%e4%bf%a1%e6%81%af aria-label="发送 SOCKS 请求信息">发送 SOCKS 请求信息</a><ul><li><a href=#client-send-2 aria-label="client send">client send</a></li><li><a href=#server-reply-2 aria-label="server reply">server reply</a></li></ul></li></ul></li><li><a href=#socks4 aria-label=SOCKS4>SOCKS4</a><ul><li><a href=#%e5%8f%91%e9%80%81-socks-%e8%af%b7%e6%b1%82%e4%bf%a1%e6%81%af-1 aria-label="发送 SOCKS 请求信息">发送 SOCKS 请求信息</a><ul><li><a href=#client-send-3 aria-label="client send">client send</a></li><li><a href=#server-reply-3 aria-label="server reply">server reply</a></li></ul></li></ul></li><li><a href=#socks4a aria-label=SOCKS4a>SOCKS4a</a><ul><li><a href=#%e5%8f%91%e9%80%81-socks-%e8%af%b7%e6%b1%82%e4%bf%a1%e6%81%af-2 aria-label="发送 SOCKS 请求信息">发送 SOCKS 请求信息</a><ul><li><a href=#client-send-4 aria-label="client send">client send</a></li><li><a href=#server-reply-4 aria-label="server reply">server reply</a></li></ul></li></ul></li><li><a href=#socks4socks4a-%e5%92%8c-socks5-%e7%9a%84%e5%8c%ba%e5%88%ab aria-label="SOCKS4，SOCKS4a 和 SOCKS5 的区别">SOCKS4，SOCKS4a 和 SOCKS5 的区别</a></li><li><a href=#socks-%e5%8d%8f%e8%ae%ae-rfc aria-label="SOCKS 协议 RFC">SOCKS 协议 RFC</a></li></ul></div></details></div><div class=post-content><blockquote><p>SOCKS 是一种网络传输协议，主要用于客户端与外网服务器之间通讯的中间传递。SOCKS 是 &ldquo;Socket Secure&rdquo; 的缩写。当防火墙后的客户端要访问外部的服务器时，就跟 SOCKS 代理服务器连接。这个代理服务器控制客户端访问外网的资格，允许的话，就将客户端的请求发往外部的服务器。这个协议最初由 David Koblas 开发，而后由 NEC 的 Ying-Da Lee 将其扩展到 SOCKS4。最新协议是 SOCKS5，与前一版本相比，增加支持 [UDP](<a href=https://zh.wikipedia.org/wiki>https://zh.wikipedia.org/wiki</a> / 用户数据报协议)、验证，以及<a href=https://zh.wikipedia.org/wiki/IPv6>IPv6</a>。根据[OSI 模型](<a href=https://zh.wikipedia.org/wiki/OSI>https://zh.wikipedia.org/wiki/OSI</a> 模型)，SOCKS 是[会话层](<a href=https://zh.wikipedia.org/wiki>https://zh.wikipedia.org/wiki</a> / 会话层) 的协议，位于 [表示层](<a href=https://zh.wikipedia.org/wiki>https://zh.wikipedia.org/wiki</a> / 表示层) 与[传输层](<a href=https://zh.wikipedia.org/wiki>https://zh.wikipedia.org/wiki</a> / 传输层)之间。SOCKS 协议不提供[加密](<a href=https://zh.wikipedia.org/wiki>https://zh.wikipedia.org/wiki</a> / 加密)。</p></blockquote><h1 id=socks5>SOCKS5<a hidden class=anchor aria-hidden=true href=#socks5>#</a></h1><h2 id=socks-协议版本认证>SOCKS 协议版本认证<a hidden class=anchor aria-hidden=true href=#socks-协议版本认证>#</a></h2><p>创建与 SOCKS5 服务器的 TCP 连接后客户端需要先发送请求来确认协议版本及认证方式（以字节为单位）</p><h3 id=client-send>client send<a hidden class=anchor aria-hidden=true href=#client-send>#</a></h3><pre><code># +----+----------+----------+
# |VER | NMETHODS | METHODS  |
# +----+----------+----------+
# | 1  |    1     | 1 to 255 |
# +----+----------+----------+
</code></pre><ul><li>VER：SOCKS5 协议版本 0x05</li><li>NMETHODS：METHODS 所占字节长度</li><li>METHODS：客户端支持的认证方式列表，每个方法占 1 字节<ul><li>0x00 不需要认证</li><li>0x01 GSSAPI</li><li>0x02 用户名、密码认证</li><li>0x03 to 0x7F 由 IANA 分配（保留）</li><li>0x80 to 0xFE 私人方法保留</li><li>0xFF 无可接受的方法</li></ul></li></ul><p>服务器从客户端提供的 <code>METHODS</code> 中选择一个并通过以下消息通知客户端</p><h3 id=server-reply>server reply<a hidden class=anchor aria-hidden=true href=#server-reply>#</a></h3><pre><code># +----+--------+
# |VER | METHOD |
# +----+--------+
# | 1  |   1    |
# +----+--------+
</code></pre><ul><li><p>VER：协议版本 0x05</p></li><li><p>METHOD：服务端选中的方法。如果返回 0xFF 表示没有一个认证方法被选中，客户端需要关闭连接。</p></li></ul><h2 id=socks-用户名密码认证>SOCKS 用户名密码认证<a hidden class=anchor aria-hidden=true href=#socks-用户名密码认证>#</a></h2><p>如果 SOCKS 协议版本认证中服务端返回的 <code>METHOD</code> 是 <code>0x02</code>，即需要用户名密码认证，则客户端会发送用户名密码认证信息。如果返回的 <code>METHOD</code> 是 <code>0x00</code>，即不需要认证，直接跳转下一步发送 SOCKS 请求信息。</p><h3 id=client-send-1>client send<a hidden class=anchor aria-hidden=true href=#client-send-1>#</a></h3><pre><code># +----+------+----------+------+----------+
# |VER | ULEN |  UNAME   | PLEN |  PASSWD  |
# +----+------+----------+------+----------+
# | 1  |  1   | 1 to 255 |  1   | 1 to 255 |
# +----+------+----------+------+----------+
</code></pre><ul><li>VER：认证协议版本 0x01</li><li>ULEN：用户名长度</li><li>UNAME： 用户名</li><li>PLEN：密码长度</li><li>PASSWD：密码</li></ul><h3 id=server-reply-1>server reply<a hidden class=anchor aria-hidden=true href=#server-reply-1>#</a></h3><pre><code># +----+--------+
# |VER | STATUS |
# +----+--------+
# | 1  |   1    |
# +----+--------+
</code></pre><ul><li>VER：认证协议版本 0x01</li><li>STATUS：认证状态<ul><li>0x00 成功</li><li>0x01 失败</li></ul></li></ul><h2 id=发送-socks-请求信息>发送 SOCKS 请求信息<a hidden class=anchor aria-hidden=true href=#发送-socks-请求信息>#</a></h2><p>认证结束后客户端就可以发送请求信息。如果认证方法有特殊封装要求，请求必须按照方法所定义的方式进行封装。</p><h3 id=client-send-2>client send<a hidden class=anchor aria-hidden=true href=#client-send-2>#</a></h3><pre><code># +----+-----+-------+------+----------+----------+
# |VER | CMD |  RSV  | ATYP | DST.ADDR | DST.PORT |
# +----+-----+-------+------+----------+----------+
# | 1  |  1  | X'00' |  1   | Variable |    2     |
# +----+-----+-------+------+----------+----------+
</code></pre><ul><li>VER：SOCKS5 协议版本 0x05</li><li>CMD：SOCK 命令码<ul><li>0x01 CONNECT 请求</li><li>0x02 BIND 请求</li><li>0x03 UDP 转发</li></ul></li><li>RSV：0x00 保留</li><li>ATYP：DST.ADDR 类型<ul><li>0x01 IPv4 地址，DST.ADDR 部分 4 字节长度</li><li>0x03 域名，DST.ADDR 部分第一个字节为域名长度，DST.ADDR 剩余的内容为域名，没有 \ 0 结尾。</li><li>0x04 IPv6 地址，16 个字节长度。</li></ul></li><li>DST.ADDR：目的地址</li><li>DST.PORT：网络字节序表示的目的端口</li></ul><h3 id=server-reply-2>server reply<a hidden class=anchor aria-hidden=true href=#server-reply-2>#</a></h3><pre><code># +----+-----+-------+------+----------+----------+
# |VER | REP |  RSV  | ATYP | BND.ADDR | BND.PORT |
# +----+-----+-------+------+----------+----------+
# | 1  |  1  | X'00' |  1   | Variable |    2     |
# +----+-----+-------+------+----------+----------+
</code></pre><ul><li>VER：SOCKS5 协议版本 0x05</li><li>REP：应答字段<ul><li>0x00 成功</li><li>0x01 常规 SOCKS 服务器连接失败</li><li>0x02 现有规则不允许连接</li><li>0x03 网络不可达</li><li>0x04 主机不可达</li><li>0x05 连接被拒</li><li>0x06 TTL 超时</li><li>0x07 不支持的命令</li><li>0x08 不支持的地址类型</li><li>0x09 to 0xFF 未定义</li></ul></li><li>RSV：0x00 保留</li><li>ATYP：BND.ADDR 类型<ul><li>0x01 IPv4 地址，DST.ADDR 部分 4 字节长度</li><li>0x03 域名，DST.ADDR 部分第一个字节为域名长度，DST.ADDR 剩余的内容为域名，没有 \ 0 结尾。</li><li>0x04 IPv6 地址，16 个字节长度。</li></ul></li><li>BND.ADDR：服务器绑定的地址</li><li>BND.PORT：网络字节序表示的服务器绑定的端口</li></ul><p>当服务端返回 <code>REP</code> 应答字段为 <code>0x00</code>，即成功时，客户端和服务端之间进行数据透传，完成 SOCKS5 代理。</p><h1 id=socks4>SOCKS4<a hidden class=anchor aria-hidden=true href=#socks4>#</a></h1><p>SOCKS 4 只支持 TCP 转发</p><h2 id=发送-socks-请求信息-1>发送 SOCKS 请求信息<a hidden class=anchor aria-hidden=true href=#发送-socks-请求信息-1>#</a></h2><h3 id=client-send-3>client send<a hidden class=anchor aria-hidden=true href=#client-send-3>#</a></h3><pre><code># +----+------+----------+--------+----------+----------+
# |VN  | CD   |  DSTPORT |  DSTIP |  USERID  |   NULL   |
# +----+------+----------+--------+----------+----------+
# | 1  |  1   |     2    |   4    | variable |    1     |
# +----+------+----------+--------+----------+----------+
</code></pre><ul><li>VN：SOCKS4 协议版本 0x04</li><li>CD：SOCK 命令码<ul><li>0x01 CONNECT 请求</li><li>0x02 BIND 请求</li></ul></li><li>DSTPORT：目的主机的端口</li><li>DSTIP：目的主机的 IP 地址</li><li>USERID：用户 USERID</li><li>NULL：0x00</li></ul><h3 id=server-reply-3>server reply<a hidden class=anchor aria-hidden=true href=#server-reply-3>#</a></h3><pre><code># +-------+-------+----------+-----------+
# |  VN   |   CD  |  DSTPORT |   DSTIP   |
# +-------+-------+----------+-----------+
# |   1   |   1   |     2    |     4     |
# +-------+-------+----------+-----------+
</code></pre><ul><li>VN：回复代码的版本，应为 0x00(注意不是 0x04)</li><li>CD：SOCK 命令码<ul><li>90(0x5a) 请求得到允许；</li><li>91(0x5b) 请求被拒绝或失败；</li><li>92(0x5c) 由于 SOCKS 服务器无法连接到客户端的 identd（一个验证身份的进程），请求被拒绝；</li><li>93(0x5d) 由于客户端程序与 identd 报告的用户身份不同，连接被拒绝。</li></ul></li><li>DSTPORT：目的主机的端口（和请求包中相同）</li><li>DSTIP：目的主机的 IP 地址（和请求包中相同）</li></ul><p>当服务端返回 <code>CD</code> 字段为 <code>90(0x5a)</code>，即允许时，客户端和服务端之间进行数据透传，完成 SOCKS4 代理。</p><h1 id=socks4a>SOCKS4a<a hidden class=anchor aria-hidden=true href=#socks4a>#</a></h1><p>SOCKS4a 协议是 SOCKS4 的一个补丁版，可以在 SOCKS4a 代理服务器上完成 DNS 解析</p><h2 id=发送-socks-请求信息-2>发送 SOCKS 请求信息<a hidden class=anchor aria-hidden=true href=#发送-socks-请求信息-2>#</a></h2><h3 id=client-send-4>client send<a hidden class=anchor aria-hidden=true href=#client-send-4>#</a></h3><pre><code># +----+------+----------+--------+----------+----------+------------+----------+
# |VN  | CD   |  DSTPORT |  DSTIP |  USERID  |   NULL   |  HOSTNAME  |   NULL   |
# +----+------+----------+--------+----------+----------+------------+----------+
# | 1  |  1   |     2    |    4   | variable |    1     |  variable  |    1     |
# +----+------+----------+--------+----------+----------+------------+----------+
</code></pre><ul><li>DSTIP：0.0.0.x，其中 x 是非零，一般都为 1。（原文：such an address is inadmissible as a destination IP address and thus should never occur if the client can resolve the domain name）</li><li>HOSTNAME：域名</li></ul><p>其余字段和 SOCKS4 相同</p><h3 id=server-reply-4>server reply<a hidden class=anchor aria-hidden=true href=#server-reply-4>#</a></h3><p>SOCKS4a 代理首先把 <code>HOSTNAME</code> 如：www.example.com 解析成对应的主机 IP 地址，并且和 IP 地址连接上，再向客户端发送和 SOCKS4 一样的响应。当服务端返回 <code>CD</code> 字段为 <code>90(0x5a)</code>，即允许时，客户端和服务端之间进行数据透传，完成 SOCKS4a 代理。</p><h1 id=socks4socks4a-和-socks5-的区别>SOCKS4，SOCKS4a 和 SOCKS5 的区别<a hidden class=anchor aria-hidden=true href=#socks4socks4a-和-socks5-的区别>#</a></h1><p>比如浏览器使用 SOCKS4 代理访问 <code>www.baidu.com</code>，浏览器先用本地的 DNS 解析把 <code>www.baidu.com</code> 转换成对应的 IP 地址，然后向 SOCKS4 服务器发送报文。如果此时我们的电脑受限本地完成不了 DNS 解析，那怎么办呢？SOCKS4a 就是解决这样的问题的，客户端可以把域名发送到 SOCKS4a 服务器上完成 DNS 解析，发送的 <code>DSTIP</code> 则为 0.0.0.1 这样的假 IP，然后就是和 SOCKS4 一样进行数据转发。SOCKS5 代理和 SOCKS4 SOCKS4a 比，多了一个验证功能和 udp 代理的功能。</p><h1 id=socks-协议-rfc>SOCKS 协议 RFC<a hidden class=anchor aria-hidden=true href=#socks-协议-rfc>#</a></h1><ul><li><a href=https://github.com/cfcs/ocaml-socks/blob/master/rfc/SOCKS4.protocol.txt>SOCKS4.protocol.txt</a> and <a href=https://github.com/cfcs/ocaml-socks/blob/master/rfc/SOCKS4A.protocol.txt>SOCKS4A.protocol.txt</a> for <code>SOCKS 4</code> and the <code>SOCKS 4A</code> extension, respectively.</li><li><a href=https://github.com/cfcs/ocaml-socks/blob/master/rfc/SOCKS5_rfc1928.txt>SOCKS5_rfc1928.txt</a> and <a href=https://github.com/cfcs/ocaml-socks/blob/master/rfc/SOCKS5_rfc1929.txt>SOCKS5_rfc1929.txt</a> for <code>SOCKS 5</code>, and <code>SOCKS 5 Username/Password authentication</code>.</li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://aladdinding.cn/tags/socks/>socks</a></li></ul><nav class=paginav><a class=prev href=https://aladdinding.cn/2020/08/%E4%BD%9C%E4%B8%BA%E6%8A%80%E6%9C%AF%E4%BA%BA%E5%91%98%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%86%99%E5%8D%9A%E5%AE%A2/><span class=title>« 上一页</span><br><span>作为技术人员为什么要写博客</span></a>
<a class=next href=https://aladdinding.cn/2020/07/%E9%BB%91%E8%8B%B9%E6%9E%9C%E4%B8%80%E9%94%AE%E5%BC%80%E5%90%AFHiDPI/><span class=title>下一页 »</span><br><span>黑苹果一键开启 HiDPI</span></a></nav></footer><div class="post bg-white"><script src=https://utteranc.es/client.js repo=aladdinding/aladdinding.github.io issue-term=title theme=github-light crossorigin=anonymous async></script></div></article></main><footer class=footer><span>&copy; 2021 <a href=https://aladdinding.cn/>阿拉丁的博客</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span>
<span><a href=https://beian.miit.gov.cn/ rel="noopener noreferrer" target=_blank>鄂ICP备2021016339号-1</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)"><button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></button></a>
<script>let menu=document.getElementById('menu');menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)},document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script><script>document.querySelectorAll('pre > code').forEach(b=>{const c=b.parentNode.parentNode,a=document.createElement('button');a.classList.add('copy-code'),a.innerText='复制';function d(){a.innerText='已复制！',setTimeout(()=>{a.innerText='复制'},2e3)}a.addEventListener('click',e=>{if('clipboard'in navigator){navigator.clipboard.writeText(b.textContent),d();return}const a=document.createRange();a.selectNodeContents(b);const c=window.getSelection();c.removeAllRanges(),c.addRange(a);try{document.execCommand('copy'),d()}catch(a){}c.removeRange(a)}),c.classList.contains("highlight")?c.appendChild(a):c.parentNode.firstChild==c||(b.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?b.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(a):b.parentNode.appendChild(a))})</script></body></html>